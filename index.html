    <!doctype html>
    <html>
    <head>
    <meta charset="UTF-8">
    <title>Paper OTP</title>

    <script>
    /*
    	Notice of Copyrights and Licenses:
	***********************************
	The paper-otp project, software and embedded resources are copyright rareventure.com.
	Portions of the all-in-one HTML document contain JavaScript codes that are the copyrights of others. 
	The individual copyrights are included throughout the document along with their licenses.
	Included JavaScript libraries are separated with HTML script tags.

	Summary of JavaScript functions with a redistributable license:
	JavaScript function		License
	*******************		***************
	Snap                            BSD License
	sjcl                            BSD and gnu license

	The paper-otp software is available under The MIT License (MIT)
	Copyright (c) 2016 rareventure.com

	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
	associated documentation files (the "Software"), to deal in the Software without restriction, including 
	without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
	sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject 
	to the following conditions:

	The above copyright notice and this permission notice shall be included in all copies or substantial 
	portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
	LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	GitHub Repository: https://github.com/redfish64/paper_otp


* Snap BSD License:

* Copyright (c) 2007-2012, Jure Leskovec
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Stanford University nor the names of its contributors
*       may be used to endorse or promote products derived from this software
*       without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

sjcl license:

Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh, Stanford University.

This is for liability reasons.  (Speaking of which, SJCL comes with NO
WARRANTY WHATSOEVER, express or implied, to the limit of applicable
law.)

SJCL is dual-licensed under the GNU GPL version 2.0 or higher, and a
2-clause BSD license.  You may use SJCL under the terms of either of
these licenses.  For your convenience, the GPL versions 2.0 and 3.0
and the 2-clause BSD license are included here.  Additionally, you may
serve "crunched" copies of sjcl (i.e. those with comments removed,
and other transformations to reduce code size) without any copyright
notice.

SJCL includes JsDoc toolkit, YUI compressor, Closure compressor,
JSLint and the CodeView template in its build system.  These programs'
copyrights are owned by other people.  They are distributed here under
the MPL, MIT, BSD, Apache and JSLint licenses.  Codeview is "free for
download" but has no license attached; it is Copyright 2010 Wouter Bos.

The BSD license is (almost?) strictly more permissive, but the
additionally licensing under the GPL allows us to use OCB 2.0 code
royalty-free (at least, if OCB 2.0's creator Phil Rogaway has anything
to say about it).  Note that if you redistribute SJCL under a license
other than the GPL, you or your users may need to pay patent licensing
fees for OCB 2.0.

There may be patents which apply to SJCL other than Phil Rogaway's OCB
patents.  We suggest that you consult legal counsel before using SJCL
in a commercial project.

*/
</script>

    <script>
// automatically copied from snap.svg-min.js
// Snap.svg 0.4.1
//
// Copyright (c) 2013 – 2015 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// build: 2015-04-13

!function(a){var b,c,d="0.4.2",e="hasOwnProperty",f=/[\.\/]/,g=/\s*,\s*/,h="*",i=function(a,b){return a-b},j={n:{}},k=function(){for(var a=0,b=this.length;b>a;a++)if("undefined"!=typeof this[a])return this[a]},l=function(){for(var a=this.length;--a;)if("undefined"!=typeof this[a])return this[a]},m=function(a,d){a=String(a);var e,f=c,g=Array.prototype.slice.call(arguments,2),h=m.listeners(a),j=0,n=[],o={},p=[],q=b;p.firstDefined=k,p.lastDefined=l,b=a,c=0;for(var r=0,s=h.length;s>r;r++)"zIndex"in h[r]&&(n.push(h[r].zIndex),h[r].zIndex<0&&(o[h[r].zIndex]=h[r]));for(n.sort(i);n[j]<0;)if(e=o[n[j++]],p.push(e.apply(d,g)),c)return c=f,p;for(r=0;s>r;r++)if(e=h[r],"zIndex"in e)if(e.zIndex==n[j]){if(p.push(e.apply(d,g)),c)break;do if(j++,e=o[n[j]],e&&p.push(e.apply(d,g)),c)break;while(e)}else o[e.zIndex]=e;else if(p.push(e.apply(d,g)),c)break;return c=f,b=q,p};m._events=j,m.listeners=function(a){var b,c,d,e,g,i,k,l,m=a.split(f),n=j,o=[n],p=[];for(e=0,g=m.length;g>e;e++){for(l=[],i=0,k=o.length;k>i;i++)for(n=o[i].n,c=[n[m[e]],n[h]],d=2;d--;)b=c[d],b&&(l.push(b),p=p.concat(b.f||[]));o=l}return p},m.on=function(a,b){if(a=String(a),"function"!=typeof b)return function(){};for(var c=a.split(g),d=0,e=c.length;e>d;d++)!function(a){for(var c,d=a.split(f),e=j,g=0,h=d.length;h>g;g++)e=e.n,e=e.hasOwnProperty(d[g])&&e[d[g]]||(e[d[g]]={n:{}});for(e.f=e.f||[],g=0,h=e.f.length;h>g;g++)if(e.f[g]==b){c=!0;break}!c&&e.f.push(b)}(c[d]);return function(a){+a==+a&&(b.zIndex=+a)}},m.f=function(a){var b=[].slice.call(arguments,1);return function(){m.apply(null,[a,null].concat(b).concat([].slice.call(arguments,0)))}},m.stop=function(){c=1},m.nt=function(a){return a?new RegExp("(?:\\.|\\/|^)"+a+"(?:\\.|\\/|$)").test(b):b},m.nts=function(){return b.split(f)},m.off=m.unbind=function(a,b){if(!a)return void(m._events=j={n:{}});var c=a.split(g);if(c.length>1)for(var d=0,i=c.length;i>d;d++)m.off(c[d],b);else{c=a.split(f);var k,l,n,d,i,o,p,q=[j];for(d=0,i=c.length;i>d;d++)for(o=0;o<q.length;o+=n.length-2){if(n=[o,1],k=q[o].n,c[d]!=h)k[c[d]]&&n.push(k[c[d]]);else for(l in k)k[e](l)&&n.push(k[l]);q.splice.apply(q,n)}for(d=0,i=q.length;i>d;d++)for(k=q[d];k.n;){if(b){if(k.f){for(o=0,p=k.f.length;p>o;o++)if(k.f[o]==b){k.f.splice(o,1);break}!k.f.length&&delete k.f}for(l in k.n)if(k.n[e](l)&&k.n[l].f){var r=k.n[l].f;for(o=0,p=r.length;p>o;o++)if(r[o]==b){r.splice(o,1);break}!r.length&&delete k.n[l].f}}else{delete k.f;for(l in k.n)k.n[e](l)&&k.n[l].f&&delete k.n[l].f}k=k.n}}},m.once=function(a,b){var c=function(){return m.unbind(a,c),b.apply(this,arguments)};return m.on(a,c)},m.version=d,m.toString=function(){return"You are running Eve "+d},"undefined"!=typeof module&&module.exports?module.exports=m:"function"==typeof define&&define.amd?define("eve",[],function(){return m}):a.eve=m}(this),function(a,b){if("function"==typeof define&&define.amd)define(["eve"],function(c){return b(a,c)});else if("undefined"!=typeof exports){var c=require("eve");module.exports=b(a,c)}else b(a,a.eve)}(window||this,function(a,b){var c=function(b){var c={},d=a.requestAnimationFrame||a.webkitRequestAnimationFrame||a.mozRequestAnimationFrame||a.oRequestAnimationFrame||a.msRequestAnimationFrame||function(a){setTimeout(a,16)},e=Array.isArray||function(a){return a instanceof Array||"[object Array]"==Object.prototype.toString.call(a)},f=0,g="M"+(+new Date).toString(36),h=function(){return g+(f++).toString(36)},i=Date.now||function(){return+new Date},j=function(a){var b=this;if(null==a)return b.s;var c=b.s-a;b.b+=b.dur*c,b.B+=b.dur*c,b.s=a},k=function(a){var b=this;return null==a?b.spd:void(b.spd=a)},l=function(a){var b=this;return null==a?b.dur:(b.s=b.s*a/b.dur,void(b.dur=a))},m=function(){var a=this;delete c[a.id],a.update(),b("mina.stop."+a.id,a)},n=function(){var a=this;a.pdif||(delete c[a.id],a.update(),a.pdif=a.get()-a.b)},o=function(){var a=this;a.pdif&&(a.b=a.get()-a.pdif,delete a.pdif,c[a.id]=a)},p=function(){var a,b=this;if(e(b.start)){a=[];for(var c=0,d=b.start.length;d>c;c++)a[c]=+b.start[c]+(b.end[c]-b.start[c])*b.easing(b.s)}else a=+b.start+(b.end-b.start)*b.easing(b.s);b.set(a)},q=function(){var a=0;for(var e in c)if(c.hasOwnProperty(e)){var f=c[e],g=f.get();a++,f.s=(g-f.b)/(f.dur/f.spd),f.s>=1&&(delete c[e],f.s=1,a--,function(a){setTimeout(function(){b("mina.finish."+a.id,a)})}(f)),f.update()}a&&d(q)},r=function(a,b,e,f,g,i,s){var t={id:h(),start:a,end:b,b:e,s:0,dur:f-e,spd:1,get:g,set:i,easing:s||r.linear,status:j,speed:k,duration:l,stop:m,pause:n,resume:o,update:p};c[t.id]=t;var u,v=0;for(u in c)if(c.hasOwnProperty(u)&&(v++,2==v))break;return 1==v&&d(q),t};return r.time=i,r.getById=function(a){return c[a]||null},r.linear=function(a){return a},r.easeout=function(a){return Math.pow(a,1.7)},r.easein=function(a){return Math.pow(a,.48)},r.easeinout=function(a){if(1==a)return 1;if(0==a)return 0;var b=.48-a/1.04,c=Math.sqrt(.1734+b*b),d=c-b,e=Math.pow(Math.abs(d),1/3)*(0>d?-1:1),f=-c-b,g=Math.pow(Math.abs(f),1/3)*(0>f?-1:1),h=e+g+.5;return 3*(1-h)*h*h+h*h*h},r.backin=function(a){if(1==a)return 1;var b=1.70158;return a*a*((b+1)*a-b)},r.backout=function(a){if(0==a)return 0;a-=1;var b=1.70158;return a*a*((b+1)*a+b)+1},r.elastic=function(a){return a==!!a?a:Math.pow(2,-10*a)*Math.sin(2*(a-.075)*Math.PI/.3)+1},r.bounce=function(a){var b,c=7.5625,d=2.75;return 1/d>a?b=c*a*a:2/d>a?(a-=1.5/d,b=c*a*a+.75):2.5/d>a?(a-=2.25/d,b=c*a*a+.9375):(a-=2.625/d,b=c*a*a+.984375),b},a.mina=r,r}("undefined"==typeof b?function(){}:b),d=function(a){function c(a,b){if(a){if(a.nodeType)return w(a);if(e(a,"array")&&c.set)return c.set.apply(c,a);if(a instanceof s)return a;if(null==b)return a=y.doc.querySelector(String(a)),w(a)}return a=null==a?"100%":a,b=null==b?"100%":b,new v(a,b)}function d(a,b){if(b){if("#text"==a&&(a=y.doc.createTextNode(b.text||b["#text"]||"")),"#comment"==a&&(a=y.doc.createComment(b.text||b["#text"]||"")),"string"==typeof a&&(a=d(a)),"string"==typeof b)return 1==a.nodeType?"xlink:"==b.substring(0,6)?a.getAttributeNS(T,b.substring(6)):"xml:"==b.substring(0,4)?a.getAttributeNS(U,b.substring(4)):a.getAttribute(b):"text"==b?a.nodeValue:null;if(1==a.nodeType){for(var c in b)if(b[z](c)){var e=A(b[c]);e?"xlink:"==c.substring(0,6)?a.setAttributeNS(T,c.substring(6),e):"xml:"==c.substring(0,4)?a.setAttributeNS(U,c.substring(4),e):a.setAttribute(c,e):a.removeAttribute(c)}}else"text"in b&&(a.nodeValue=b.text)}else a=y.doc.createElementNS(U,a);return a}function e(a,b){return b=A.prototype.toLowerCase.call(b),"finite"==b?isFinite(a):"array"==b&&(a instanceof Array||Array.isArray&&Array.isArray(a))?!0:"null"==b&&null===a||b==typeof a&&null!==a||"object"==b&&a===Object(a)||J.call(a).slice(8,-1).toLowerCase()==b}function f(a){if("function"==typeof a||Object(a)!==a)return a;var b=new a.constructor;for(var c in a)a[z](c)&&(b[c]=f(a[c]));return b}function h(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return a.push(a.splice(c,1)[0])}function i(a,b,c){function d(){var e=Array.prototype.slice.call(arguments,0),f=e.join("␀"),g=d.cache=d.cache||{},i=d.count=d.count||[];return g[z](f)?(h(i,f),c?c(g[f]):g[f]):(i.length>=1e3&&delete g[i.shift()],i.push(f),g[f]=a.apply(b,e),c?c(g[f]):g[f])}return d}function j(a,b,c,d,e,f){if(null==e){var g=a-c,h=b-d;return g||h?(180+180*D.atan2(-h,-g)/H+360)%360:0}return j(a,b,e,f)-j(c,d,e,f)}function k(a){return a%360*H/180}function l(a){return 180*a/H%360}function m(a){var b=[];return a=a.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g,function(a,c,d){return d=d.split(/\s*,\s*|\s+/),"rotate"==c&&1==d.length&&d.push(0,0),"scale"==c&&(d.length>2?d=d.slice(0,2):2==d.length&&d.push(0,0),1==d.length&&d.push(d[0],0,0)),b.push("skewX"==c?["m",1,0,D.tan(k(d[0])),1,0,0]:"skewY"==c?["m",1,D.tan(k(d[0])),0,1,0,0]:[c.charAt(0)].concat(d)),a}),b}function n(a,b){var d=ab(a),e=new c.Matrix;if(d)for(var f=0,g=d.length;g>f;f++){var h,i,j,k,l,m=d[f],n=m.length,o=A(m[0]).toLowerCase(),p=m[0]!=o,q=p?e.invert():0;"t"==o&&2==n?e.translate(m[1],0):"t"==o&&3==n?p?(h=q.x(0,0),i=q.y(0,0),j=q.x(m[1],m[2]),k=q.y(m[1],m[2]),e.translate(j-h,k-i)):e.translate(m[1],m[2]):"r"==o?2==n?(l=l||b,e.rotate(m[1],l.x+l.width/2,l.y+l.height/2)):4==n&&(p?(j=q.x(m[2],m[3]),k=q.y(m[2],m[3]),e.rotate(m[1],j,k)):e.rotate(m[1],m[2],m[3])):"s"==o?2==n||3==n?(l=l||b,e.scale(m[1],m[n-1],l.x+l.width/2,l.y+l.height/2)):4==n?p?(j=q.x(m[2],m[3]),k=q.y(m[2],m[3]),e.scale(m[1],m[1],j,k)):e.scale(m[1],m[1],m[2],m[3]):5==n&&(p?(j=q.x(m[3],m[4]),k=q.y(m[3],m[4]),e.scale(m[1],m[2],j,k)):e.scale(m[1],m[2],m[3],m[4])):"m"==o&&7==n&&e.add(m[1],m[2],m[3],m[4],m[5],m[6])}return e}function o(a){var b=a.node.ownerSVGElement&&w(a.node.ownerSVGElement)||a.node.parentNode&&w(a.node.parentNode)||c.select("svg")||c(0,0),d=b.select("defs"),e=null==d?!1:d.node;return e||(e=u("defs",b.node).node),e}function p(a){return a.node.ownerSVGElement&&w(a.node.ownerSVGElement)||c.select("svg")}function q(a,b,c){function e(a){if(null==a)return I;if(a==+a)return a;d(j,{width:a});try{return j.getBBox().width}catch(b){return 0}}function f(a){if(null==a)return I;if(a==+a)return a;d(j,{height:a});try{return j.getBBox().height}catch(b){return 0}}function g(d,e){null==b?i[d]=e(a.attr(d)||0):d==b&&(i=e(null==c?a.attr(d)||0:c))}var h=p(a).node,i={},j=h.querySelector(".svg---mgr");switch(j||(j=d("rect"),d(j,{x:-9e9,y:-9e9,width:10,height:10,"class":"svg---mgr",fill:"none"}),h.appendChild(j)),a.type){case"rect":g("rx",e),g("ry",f);case"image":g("width",e),g("height",f);case"text":g("x",e),g("y",f);break;case"circle":g("cx",e),g("cy",f),g("r",e);break;case"ellipse":g("cx",e),g("cy",f),g("rx",e),g("ry",f);break;case"line":g("x1",e),g("x2",e),g("y1",f),g("y2",f);break;case"marker":g("refX",e),g("markerWidth",e),g("refY",f),g("markerHeight",f);break;case"radialGradient":g("fx",e),g("fy",f);break;case"tspan":g("dx",e),g("dy",f);break;default:g(b,e)}return h.removeChild(j),i}function r(a){e(a,"array")||(a=Array.prototype.slice.call(arguments,0));for(var b=0,c=0,d=this.node;this[b];)delete this[b++];for(b=0;b<a.length;b++)"set"==a[b].type?a[b].forEach(function(a){d.appendChild(a.node)}):d.appendChild(a[b].node);var f=d.childNodes;for(b=0;b<f.length;b++)this[c++]=w(f[b]);return this}function s(a){if(a.snap in V)return V[a.snap];var b;try{b=a.ownerSVGElement}catch(c){}this.node=a,b&&(this.paper=new v(b)),this.type=a.tagName||a.nodeName;var d=this.id=S(this);if(this.anims={},this._={transform:[]},a.snap=d,V[d]=this,"g"==this.type&&(this.add=r),this.type in{g:1,mask:1,pattern:1,symbol:1})for(var e in v.prototype)v.prototype[z](e)&&(this[e]=v.prototype[e])}function t(a){this.node=a}function u(a,b){var c=d(a);b.appendChild(c);var e=w(c);return e}function v(a,b){var c,e,f,g=v.prototype;if(a&&"svg"==a.tagName){if(a.snap in V)return V[a.snap];var h=a.ownerDocument;c=new s(a),e=a.getElementsByTagName("desc")[0],f=a.getElementsByTagName("defs")[0],e||(e=d("desc"),e.appendChild(h.createTextNode("Created with Snap")),c.node.appendChild(e)),f||(f=d("defs"),c.node.appendChild(f)),c.defs=f;for(var i in g)g[z](i)&&(c[i]=g[i]);c.paper=c.root=c}else c=u("svg",y.doc.body),d(c.node,{height:b,version:1.1,width:a,xmlns:U});return c}function w(a){return a?a instanceof s||a instanceof t?a:a.tagName&&"svg"==a.tagName.toLowerCase()?new v(a):a.tagName&&"object"==a.tagName.toLowerCase()&&"image/svg+xml"==a.type?new v(a.contentDocument.getElementsByTagName("svg")[0]):new s(a):a}function x(a,b){for(var c=0,d=a.length;d>c;c++){var e={type:a[c].type,attr:a[c].attr()},f=a[c].children();b.push(e),f.length&&x(f,e.childNodes=[])}}c.version="0.4.0",c.toString=function(){return"Snap v"+this.version},c._={};var y={win:a.window,doc:a.window.document};c._.glob=y;{var z="hasOwnProperty",A=String,B=parseFloat,C=parseInt,D=Math,E=D.max,F=D.min,G=D.abs,H=(D.pow,D.PI),I=(D.round,""),J=Object.prototype.toString,K=/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,L=(c._.separator=/[,\s]+/,/[\s]*,[\s]*/),M={hs:1,rg:1},N=/([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/gi,O=/([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/gi,P=/(-?\d*\.?\d*(?:e[\-+]?\\d+)?)[\s]*,?[\s]*/gi,Q=0,R="S"+(+new Date).toString(36),S=function(a){return(a&&a.type?a.type:I)+R+(Q++).toString(36)},T="http://www.w3.org/1999/xlink",U="http://www.w3.org/2000/svg",V={};c.url=function(a){return"url('#"+a+"')"}}c._.$=d,c._.id=S,c.format=function(){var a=/\{([^\}]+)\}/g,b=/(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,c=function(a,c,d){var e=d;return c.replace(b,function(a,b,c,d,f){b=b||d,e&&(b in e&&(e=e[b]),"function"==typeof e&&f&&(e=e()))}),e=(null==e||e==d?a:e)+""};return function(b,d){return A(b).replace(a,function(a,b){return c(a,b,d)})}}(),c._.clone=f,c._.cacher=i,c.rad=k,c.deg=l,c.sin=function(a){return D.sin(c.rad(a))},c.tan=function(a){return D.tan(c.rad(a))},c.cos=function(a){return D.cos(c.rad(a))},c.asin=function(a){return c.deg(D.asin(a))},c.acos=function(a){return c.deg(D.acos(a))},c.atan=function(a){return c.deg(D.atan(a))},c.atan2=function(a){return c.deg(D.atan2(a))},c.angle=j,c.len=function(a,b,d,e){return Math.sqrt(c.len2(a,b,d,e))},c.len2=function(a,b,c,d){return(a-c)*(a-c)+(b-d)*(b-d)},c.closestPoint=function(a,b,c){function d(a){var d=a.x-b,e=a.y-c;return d*d+e*e}for(var e,f,g,h,i=a.node,j=i.getTotalLength(),k=j/i.pathSegList.numberOfItems*.125,l=1/0,m=0;j>=m;m+=k)(h=d(g=i.getPointAtLength(m)))<l&&(e=g,f=m,l=h);for(k*=.5;k>.5;){var n,o,p,q,r,s;(p=f-k)>=0&&(r=d(n=i.getPointAtLength(p)))<l?(e=n,f=p,l=r):(q=f+k)<=j&&(s=d(o=i.getPointAtLength(q)))<l?(e=o,f=q,l=s):k*=.5}return e={x:e.x,y:e.y,length:f,distance:Math.sqrt(l)}},c.is=e,c.snapTo=function(a,b,c){if(c=e(c,"finite")?c:10,e(a,"array")){for(var d=a.length;d--;)if(G(a[d]-b)<=c)return a[d]}else{a=+a;var f=b%a;if(c>f)return b-f;if(f>a-c)return b-f+a}return b},c.getRGB=i(function(a){if(!a||(a=A(a)).indexOf("-")+1)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:Z};if("none"==a)return{r:-1,g:-1,b:-1,hex:"none",toString:Z};if(!(M[z](a.toLowerCase().substring(0,2))||"#"==a.charAt())&&(a=W(a)),!a)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:Z};var b,d,f,g,h,i,j=a.match(K);return j?(j[2]&&(f=C(j[2].substring(5),16),d=C(j[2].substring(3,5),16),b=C(j[2].substring(1,3),16)),j[3]&&(f=C((h=j[3].charAt(3))+h,16),d=C((h=j[3].charAt(2))+h,16),b=C((h=j[3].charAt(1))+h,16)),j[4]&&(i=j[4].split(L),b=B(i[0]),"%"==i[0].slice(-1)&&(b*=2.55),d=B(i[1]),"%"==i[1].slice(-1)&&(d*=2.55),f=B(i[2]),"%"==i[2].slice(-1)&&(f*=2.55),"rgba"==j[1].toLowerCase().slice(0,4)&&(g=B(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100)),j[5]?(i=j[5].split(L),b=B(i[0]),"%"==i[0].slice(-1)&&(b/=100),d=B(i[1]),"%"==i[1].slice(-1)&&(d/=100),f=B(i[2]),"%"==i[2].slice(-1)&&(f/=100),("deg"==i[0].slice(-3)||"°"==i[0].slice(-1))&&(b/=360),"hsba"==j[1].toLowerCase().slice(0,4)&&(g=B(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100),c.hsb2rgb(b,d,f,g)):j[6]?(i=j[6].split(L),b=B(i[0]),"%"==i[0].slice(-1)&&(b/=100),d=B(i[1]),"%"==i[1].slice(-1)&&(d/=100),f=B(i[2]),"%"==i[2].slice(-1)&&(f/=100),("deg"==i[0].slice(-3)||"°"==i[0].slice(-1))&&(b/=360),"hsla"==j[1].toLowerCase().slice(0,4)&&(g=B(i[3])),i[3]&&"%"==i[3].slice(-1)&&(g/=100),c.hsl2rgb(b,d,f,g)):(b=F(D.round(b),255),d=F(D.round(d),255),f=F(D.round(f),255),g=F(E(g,0),1),j={r:b,g:d,b:f,toString:Z},j.hex="#"+(16777216|f|d<<8|b<<16).toString(16).slice(1),j.opacity=e(g,"finite")?g:1,j)):{r:-1,g:-1,b:-1,hex:"none",error:1,toString:Z}},c),c.hsb=i(function(a,b,d){return c.hsb2rgb(a,b,d).hex}),c.hsl=i(function(a,b,d){return c.hsl2rgb(a,b,d).hex}),c.rgb=i(function(a,b,c,d){if(e(d,"finite")){var f=D.round;return"rgba("+[f(a),f(b),f(c),+d.toFixed(2)]+")"}return"#"+(16777216|c|b<<8|a<<16).toString(16).slice(1)});var W=function(a){var b=y.doc.getElementsByTagName("head")[0]||y.doc.getElementsByTagName("svg")[0],c="rgb(255, 0, 0)";return(W=i(function(a){if("red"==a.toLowerCase())return c;b.style.color=c,b.style.color=a;var d=y.doc.defaultView.getComputedStyle(b,I).getPropertyValue("color");return d==c?null:d}))(a)},X=function(){return"hsb("+[this.h,this.s,this.b]+")"},Y=function(){return"hsl("+[this.h,this.s,this.l]+")"},Z=function(){return 1==this.opacity||null==this.opacity?this.hex:"rgba("+[this.r,this.g,this.b,this.opacity]+")"},$=function(a,b,d){if(null==b&&e(a,"object")&&"r"in a&&"g"in a&&"b"in a&&(d=a.b,b=a.g,a=a.r),null==b&&e(a,string)){var f=c.getRGB(a);a=f.r,b=f.g,d=f.b}return(a>1||b>1||d>1)&&(a/=255,b/=255,d/=255),[a,b,d]},_=function(a,b,d,f){a=D.round(255*a),b=D.round(255*b),d=D.round(255*d);var g={r:a,g:b,b:d,opacity:e(f,"finite")?f:1,hex:c.rgb(a,b,d),toString:Z};return e(f,"finite")&&(g.opacity=f),g};c.color=function(a){var b;return e(a,"object")&&"h"in a&&"s"in a&&"b"in a?(b=c.hsb2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.opacity=1,a.hex=b.hex):e(a,"object")&&"h"in a&&"s"in a&&"l"in a?(b=c.hsl2rgb(a),a.r=b.r,a.g=b.g,a.b=b.b,a.opacity=1,a.hex=b.hex):(e(a,"string")&&(a=c.getRGB(a)),e(a,"object")&&"r"in a&&"g"in a&&"b"in a&&!("error"in a)?(b=c.rgb2hsl(a),a.h=b.h,a.s=b.s,a.l=b.l,b=c.rgb2hsb(a),a.v=b.b):(a={hex:"none"},a.r=a.g=a.b=a.h=a.s=a.v=a.l=-1,a.error=1)),a.toString=Z,a},c.hsb2rgb=function(a,b,c,d){e(a,"object")&&"h"in a&&"s"in a&&"b"in a&&(c=a.b,b=a.s,d=a.o,a=a.h),a*=360;var f,g,h,i,j;return a=a%360/60,j=c*b,i=j*(1-G(a%2-1)),f=g=h=c-j,a=~~a,f+=[j,i,0,0,i,j][a],g+=[i,j,j,i,0,0][a],h+=[0,0,i,j,j,i][a],_(f,g,h,d)},c.hsl2rgb=function(a,b,c,d){e(a,"object")&&"h"in a&&"s"in a&&"l"in a&&(c=a.l,b=a.s,a=a.h),(a>1||b>1||c>1)&&(a/=360,b/=100,c/=100),a*=360;var f,g,h,i,j;return a=a%360/60,j=2*b*(.5>c?c:1-c),i=j*(1-G(a%2-1)),f=g=h=c-j/2,a=~~a,f+=[j,i,0,0,i,j][a],g+=[i,j,j,i,0,0][a],h+=[0,0,i,j,j,i][a],_(f,g,h,d)},c.rgb2hsb=function(a,b,c){c=$(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g;return f=E(a,b,c),g=f-F(a,b,c),d=0==g?null:f==a?(b-c)/g:f==b?(c-a)/g+2:(a-b)/g+4,d=(d+360)%6*60/360,e=0==g?0:g/f,{h:d,s:e,b:f,toString:X}},c.rgb2hsl=function(a,b,c){c=$(a,b,c),a=c[0],b=c[1],c=c[2];var d,e,f,g,h,i;return g=E(a,b,c),h=F(a,b,c),i=g-h,d=0==i?null:g==a?(b-c)/i:g==b?(c-a)/i+2:(a-b)/i+4,d=(d+360)%6*60/360,f=(g+h)/2,e=0==i?0:.5>f?i/(2*f):i/(2-2*f),{h:d,s:e,l:f,toString:Y}},c.parsePathString=function(a){if(!a)return null;var b=c.path(a);if(b.arr)return c.path.clone(b.arr);var d={a:7,c:6,o:2,h:1,l:2,m:2,r:4,q:4,s:4,t:2,v:1,u:3,z:0},f=[];return e(a,"array")&&e(a[0],"array")&&(f=c.path.clone(a)),f.length||A(a).replace(N,function(a,b,c){var e=[],g=b.toLowerCase();if(c.replace(P,function(a,b){b&&e.push(+b)}),"m"==g&&e.length>2&&(f.push([b].concat(e.splice(0,2))),g="l",b="m"==b?"l":"L"),"o"==g&&1==e.length&&f.push([b,e[0]]),"r"==g)f.push([b].concat(e));else for(;e.length>=d[g]&&(f.push([b].concat(e.splice(0,d[g]))),d[g]););}),f.toString=c.path.toString,b.arr=c.path.clone(f),f};var ab=c.parseTransformString=function(a){if(!a)return null;var b=[];return e(a,"array")&&e(a[0],"array")&&(b=c.path.clone(a)),b.length||A(a).replace(O,function(a,c,d){{var e=[];c.toLowerCase()}d.replace(P,function(a,b){b&&e.push(+b)}),b.push([c].concat(e))}),b.toString=c.path.toString,b};c._.svgTransform2string=m,c._.rgTransform=/^[a-z][\s]*-?\.?\d/i,c._.transform2matrix=n,c._unit2px=q;y.doc.contains||y.doc.compareDocumentPosition?function(a,b){var c=9==a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a==d||!(!d||1!=d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)for(;b;)if(b=b.parentNode,b==a)return!0;return!1};c._.getSomeDefs=o,c._.getSomeSVG=p,c.select=function(a){return a=A(a).replace(/([^\\]):/g,"$1\\:"),w(y.doc.querySelector(a))},c.selectAll=function(a){for(var b=y.doc.querySelectorAll(a),d=(c.set||Array)(),e=0;e<b.length;e++)d.push(w(b[e]));return d},setInterval(function(){for(var a in V)if(V[z](a)){var b=V[a],c=b.node;("svg"!=b.type&&!c.ownerSVGElement||"svg"==b.type&&(!c.parentNode||"ownerSVGElement"in c.parentNode&&!c.ownerSVGElement))&&delete V[a]}},1e4),s.prototype.attr=function(a,c){var d=this,f=d.node;if(!a){if(1!=f.nodeType)return{text:f.nodeValue};for(var g=f.attributes,h={},i=0,j=g.length;j>i;i++)h[g[i].nodeName]=g[i].nodeValue;return h}if(e(a,"string")){if(!(arguments.length>1))return b("snap.util.getattr."+a,d).firstDefined();var k={};k[a]=c,a=k}for(var l in a)a[z](l)&&b("snap.util.attr."+l,d,a[l]);return d},c.parse=function(a){var b=y.doc.createDocumentFragment(),c=!0,d=y.doc.createElement("div");if(a=A(a),a.match(/^\s*<\s*svg(?:\s|>)/)||(a="<svg>"+a+"</svg>",c=!1),d.innerHTML=a,a=d.getElementsByTagName("svg")[0])if(c)b=a;else for(;a.firstChild;)b.appendChild(a.firstChild);return new t(b)},c.fragment=function(){for(var a=Array.prototype.slice.call(arguments,0),b=y.doc.createDocumentFragment(),d=0,e=a.length;e>d;d++){var f=a[d];f.node&&f.node.nodeType&&b.appendChild(f.node),f.nodeType&&b.appendChild(f),"string"==typeof f&&b.appendChild(c.parse(f).node)}return new t(b)},c._.make=u,c._.wrap=w,v.prototype.el=function(a,b){var c=u(a,this.node);return b&&c.attr(b),c},s.prototype.children=function(){for(var a=[],b=this.node.childNodes,d=0,e=b.length;e>d;d++)a[d]=c(b[d]);return a},s.prototype.toJSON=function(){var a=[];return x([this],a),a[0]},b.on("snap.util.getattr",function(){var a=b.nt();a=a.substring(a.lastIndexOf(".")+1);var c=a.replace(/[A-Z]/g,function(a){return"-"+a.toLowerCase()});return bb[z](c)?this.node.ownerDocument.defaultView.getComputedStyle(this.node,null).getPropertyValue(c):d(this.node,a)});var bb={"alignment-baseline":0,"baseline-shift":0,clip:0,"clip-path":0,"clip-rule":0,color:0,"color-interpolation":0,"color-interpolation-filters":0,"color-profile":0,"color-rendering":0,cursor:0,direction:0,display:0,"dominant-baseline":0,"enable-background":0,fill:0,"fill-opacity":0,"fill-rule":0,filter:0,"flood-color":0,"flood-opacity":0,font:0,"font-family":0,"font-size":0,"font-size-adjust":0,"font-stretch":0,"font-style":0,"font-variant":0,"font-weight":0,"glyph-orientation-horizontal":0,"glyph-orientation-vertical":0,"image-rendering":0,kerning:0,"letter-spacing":0,"lighting-color":0,marker:0,"marker-end":0,"marker-mid":0,"marker-start":0,mask:0,opacity:0,overflow:0,"pointer-events":0,"shape-rendering":0,"stop-color":0,"stop-opacity":0,stroke:0,"stroke-dasharray":0,"stroke-dashoffset":0,"stroke-linecap":0,"stroke-linejoin":0,"stroke-miterlimit":0,"stroke-opacity":0,"stroke-width":0,"text-anchor":0,"text-decoration":0,"text-rendering":0,"unicode-bidi":0,visibility:0,"word-spacing":0,"writing-mode":0};b.on("snap.util.attr",function(a){var c=b.nt(),e={};c=c.substring(c.lastIndexOf(".")+1),e[c]=a;var f=c.replace(/-(\w)/gi,function(a,b){return b.toUpperCase()}),g=c.replace(/[A-Z]/g,function(a){return"-"+a.toLowerCase()});bb[z](g)?this.node.style[f]=null==a?I:a:d(this.node,e)}),function(){}(v.prototype),c.ajax=function(a,c,d,f){var g=new XMLHttpRequest,h=S();if(g){if(e(c,"function"))f=d,d=c,c=null;else if(e(c,"object")){var i=[];for(var j in c)c.hasOwnProperty(j)&&i.push(encodeURIComponent(j)+"="+encodeURIComponent(c[j]));c=i.join("&")}return g.open(c?"POST":"GET",a,!0),c&&(g.setRequestHeader("X-Requested-With","XMLHttpRequest"),g.setRequestHeader("Content-type","application/x-www-form-urlencoded")),d&&(b.once("snap.ajax."+h+".0",d),b.once("snap.ajax."+h+".200",d),b.once("snap.ajax."+h+".304",d)),g.onreadystatechange=function(){4==g.readyState&&b("snap.ajax."+h+"."+g.status,f,g)},4==g.readyState?g:(g.send(c),g)}},c.load=function(a,b,d){c.ajax(a,function(a){var e=c.parse(a.responseText);d?b.call(d,e):b(e)})};var cb=function(a){var b=a.getBoundingClientRect(),c=a.ownerDocument,d=c.body,e=c.documentElement,f=e.clientTop||d.clientTop||0,h=e.clientLeft||d.clientLeft||0,i=b.top+(g.win.pageYOffset||e.scrollTop||d.scrollTop)-f,j=b.left+(g.win.pageXOffset||e.scrollLeft||d.scrollLeft)-h;return{y:i,x:j}};return c.getElementByPoint=function(a,b){var c=this,d=(c.canvas,y.doc.elementFromPoint(a,b));if(y.win.opera&&"svg"==d.tagName){var e=cb(d),f=d.createSVGRect();f.x=a-e.x,f.y=b-e.y,f.width=f.height=1;var g=d.getIntersectionList(f,null);g.length&&(d=g[g.length-1])}return d?w(d):null},c.plugin=function(a){a(c,s,v,y,t)},y.win.Snap=c,c}(a||this);return d.plugin(function(d,e,f,g,h){function i(a,b){if(null==b){var c=!0;if(b=a.node.getAttribute("linearGradient"==a.type||"radialGradient"==a.type?"gradientTransform":"pattern"==a.type?"patternTransform":"transform"),!b)return new d.Matrix;b=d._.svgTransform2string(b)}else b=d._.rgTransform.test(b)?o(b).replace(/\.{3}|\u2026/g,a._.transform||""):d._.svgTransform2string(b),n(b,"array")&&(b=d.path?d.path.toString.call(b):o(b)),a._.transform=b;var e=d._.transform2matrix(b,a.getBBox(1));return c?e:void(a.matrix=e)}function j(a){function b(a,b){var c=q(a.node,b);c=c&&c.match(f),c=c&&c[2],c&&"#"==c.charAt()&&(c=c.substring(1),c&&(h[c]=(h[c]||[]).concat(function(c){var d={};d[b]=URL(c),q(a.node,d)})))}function c(a){var b=q(a.node,"xlink:href");b&&"#"==b.charAt()&&(b=b.substring(1),b&&(h[b]=(h[b]||[]).concat(function(b){a.attr("xlink:href","#"+b)})))}for(var d,e=a.selectAll("*"),f=/^\s*url\(("|'|)(.*)\1\)\s*$/,g=[],h={},i=0,j=e.length;j>i;i++){d=e[i],b(d,"fill"),b(d,"stroke"),b(d,"filter"),b(d,"mask"),b(d,"clip-path"),c(d);var k=q(d.node,"id");k&&(q(d.node,{id:d.id}),g.push({old:k,id:d.id}))}for(i=0,j=g.length;j>i;i++){var l=h[g[i].old];if(l)for(var m=0,n=l.length;n>m;m++)l[m](g[i].id)}}function k(a,b,c){return function(d){var e=d.slice(a,b);return 1==e.length&&(e=e[0]),c?c(e):e}}function l(a){return function(){var b=a?"<"+this.type:"",c=this.node.attributes,d=this.node.childNodes;if(a)for(var e=0,f=c.length;f>e;e++)b+=" "+c[e].name+'="'+c[e].value.replace(/"/g,'\\"')+'"';if(d.length){for(a&&(b+=">"),e=0,f=d.length;f>e;e++)3==d[e].nodeType?b+=d[e].nodeValue:1==d[e].nodeType&&(b+=u(d[e]).toString());a&&(b+="</"+this.type+">")}else a&&(b+="/>");return b}}var m=e.prototype,n=d.is,o=String,p=d._unit2px,q=d._.$,r=d._.make,s=d._.getSomeDefs,t="hasOwnProperty",u=d._.wrap;m.getBBox=function(a){if(!d.Matrix||!d.path)return this.node.getBBox();var b=this,c=new d.Matrix;if(b.removed)return d._.box();for(;"use"==b.type;)if(a||(c=c.add(b.transform().localMatrix.translate(b.attr("x")||0,b.attr("y")||0))),b.original)b=b.original;else{var e=b.attr("xlink:href");b=b.original=b.node.ownerDocument.getElementById(e.substring(e.indexOf("#")+1))}var f=b._,g=d.path.get[b.type]||d.path.get.deflt;try{return a?(f.bboxwt=g?d.path.getBBox(b.realPath=g(b)):d._.box(b.node.getBBox()),d._.box(f.bboxwt)):(b.realPath=g(b),b.matrix=b.transform().localMatrix,f.bbox=d.path.getBBox(d.path.map(b.realPath,c.add(b.matrix))),d._.box(f.bbox))}catch(h){return d._.box()}};var v=function(){return this.string};m.transform=function(a){var b=this._;if(null==a){for(var c,e=this,f=new d.Matrix(this.node.getCTM()),g=i(this),h=[g],j=new d.Matrix,k=g.toTransformString(),l=o(g)==o(this.matrix)?o(b.transform):k;"svg"!=e.type&&(e=e.parent());)h.push(i(e));for(c=h.length;c--;)j.add(h[c]);return{string:l,globalMatrix:f,totalMatrix:j,localMatrix:g,diffMatrix:f.clone().add(g.invert()),global:f.toTransformString(),total:j.toTransformString(),local:k,toString:v}}return a instanceof d.Matrix?(this.matrix=a,this._.transform=a.toTransformString()):i(this,a),this.node&&("linearGradient"==this.type||"radialGradient"==this.type?q(this.node,{gradientTransform:this.matrix}):"pattern"==this.type?q(this.node,{patternTransform:this.matrix}):q(this.node,{transform:this.matrix})),this},m.parent=function(){return u(this.node.parentNode)},m.append=m.add=function(a){if(a){if("set"==a.type){var b=this;return a.forEach(function(a){b.add(a)}),this}a=u(a),this.node.appendChild(a.node),a.paper=this.paper}return this},m.appendTo=function(a){return a&&(a=u(a),a.append(this)),this},m.prepend=function(a){if(a){if("set"==a.type){var b,c=this;return a.forEach(function(a){b?b.after(a):c.prepend(a),b=a}),this}a=u(a);var d=a.parent();this.node.insertBefore(a.node,this.node.firstChild),this.add&&this.add(),a.paper=this.paper,this.parent()&&this.parent().add(),d&&d.add()}return this},m.prependTo=function(a){return a=u(a),a.prepend(this),this},m.before=function(a){if("set"==a.type){var b=this;return a.forEach(function(a){var c=a.parent();b.node.parentNode.insertBefore(a.node,b.node),c&&c.add()}),this.parent().add(),this}a=u(a);var c=a.parent();return this.node.parentNode.insertBefore(a.node,this.node),this.parent()&&this.parent().add(),c&&c.add(),a.paper=this.paper,this},m.after=function(a){a=u(a);var b=a.parent();return this.node.nextSibling?this.node.parentNode.insertBefore(a.node,this.node.nextSibling):this.node.parentNode.appendChild(a.node),this.parent()&&this.parent().add(),b&&b.add(),a.paper=this.paper,this},m.insertBefore=function(a){a=u(a);var b=this.parent();return a.node.parentNode.insertBefore(this.node,a.node),this.paper=a.paper,b&&b.add(),a.parent()&&a.parent().add(),this},m.insertAfter=function(a){a=u(a);var b=this.parent();return a.node.parentNode.insertBefore(this.node,a.node.nextSibling),this.paper=a.paper,b&&b.add(),a.parent()&&a.parent().add(),this},m.remove=function(){var a=this.parent();return this.node.parentNode&&this.node.parentNode.removeChild(this.node),delete this.paper,this.removed=!0,a&&a.add(),this},m.select=function(a){return u(this.node.querySelector(a))},m.selectAll=function(a){for(var b=this.node.querySelectorAll(a),c=(d.set||Array)(),e=0;e<b.length;e++)c.push(u(b[e]));return c},m.asPX=function(a,b){return null==b&&(b=this.attr(a)),+p(this,a,b)},m.use=function(){var a,b=this.node.id;return b||(b=this.id,q(this.node,{id:b})),a="linearGradient"==this.type||"radialGradient"==this.type||"pattern"==this.type?r(this.type,this.node.parentNode):r("use",this.node.parentNode),q(a.node,{"xlink:href":"#"+b}),a.original=this,a},m.clone=function(){var a=u(this.node.cloneNode(!0));return q(a.node,"id")&&q(a.node,{id:a.id}),j(a),a.insertAfter(this),a},m.toDefs=function(){var a=s(this);return a.appendChild(this.node),this},m.pattern=m.toPattern=function(a,b,c,d){var e=r("pattern",s(this));return null==a&&(a=this.getBBox()),n(a,"object")&&"x"in a&&(b=a.y,c=a.width,d=a.height,a=a.x),q(e.node,{x:a,y:b,width:c,height:d,patternUnits:"userSpaceOnUse",id:e.id,viewBox:[a,b,c,d].join(" ")}),e.node.appendChild(this.node),e},m.marker=function(a,b,c,d,e,f){var g=r("marker",s(this));return null==a&&(a=this.getBBox()),n(a,"object")&&"x"in a&&(b=a.y,c=a.width,d=a.height,e=a.refX||a.cx,f=a.refY||a.cy,a=a.x),q(g.node,{viewBox:[a,b,c,d].join(" "),markerWidth:c,markerHeight:d,orient:"auto",refX:e||0,refY:f||0,id:g.id}),g.node.appendChild(this.node),g};var w=function(a,b,d,e){"function"!=typeof d||d.length||(e=d,d=c.linear),this.attr=a,this.dur=b,d&&(this.easing=d),e&&(this.callback=e)};d._.Animation=w,d.animation=function(a,b,c,d){return new w(a,b,c,d)},m.inAnim=function(){var a=this,b=[];for(var c in a.anims)a.anims[t](c)&&!function(a){b.push({anim:new w(a._attrs,a.dur,a.easing,a._callback),mina:a,curStatus:a.status(),status:function(b){return a.status(b)},stop:function(){a.stop()}})}(a.anims[c]);return b},d.animate=function(a,d,e,f,g,h){"function"!=typeof g||g.length||(h=g,g=c.linear);var i=c.time(),j=c(a,d,i,i+f,c.time,e,g);return h&&b.once("mina.finish."+j.id,h),j},m.stop=function(){for(var a=this.inAnim(),b=0,c=a.length;c>b;b++)a[b].stop();return this},m.animate=function(a,d,e,f){"function"!=typeof e||e.length||(f=e,e=c.linear),a instanceof w&&(f=a.callback,e=a.easing,d=a.dur,a=a.attr);var g,h,i,j,l=[],m=[],p={},q=this;for(var r in a)if(a[t](r)){q.equal?(j=q.equal(r,o(a[r])),g=j.from,h=j.to,i=j.f):(g=+q.attr(r),h=+a[r]);var s=n(g,"array")?g.length:1;p[r]=k(l.length,l.length+s,i),l=l.concat(g),m=m.concat(h)}var u=c.time(),v=c(l,m,u,u+d,c.time,function(a){var b={};for(var c in p)p[t](c)&&(b[c]=p[c](a));q.attr(b)},e);return q.anims[v.id]=v,v._attrs=a,v._callback=f,b("snap.animcreated."+q.id,v),b.once("mina.finish."+v.id,function(){delete q.anims[v.id],f&&f.call(q)}),b.once("mina.stop."+v.id,function(){delete q.anims[v.id]}),q};var x={};m.data=function(a,c){var e=x[this.id]=x[this.id]||{};if(0==arguments.length)return b("snap.data.get."+this.id,this,e,null),e;
if(1==arguments.length){if(d.is(a,"object")){for(var f in a)a[t](f)&&this.data(f,a[f]);return this}return b("snap.data.get."+this.id,this,e[a],a),e[a]}return e[a]=c,b("snap.data.set."+this.id,this,c,a),this},m.removeData=function(a){return null==a?x[this.id]={}:x[this.id]&&delete x[this.id][a],this},m.outerSVG=m.toString=l(1),m.innerSVG=l(),m.toDataURL=function(){if(a&&a.btoa){var b=this.getBBox(),c=d.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>',{x:+b.x.toFixed(3),y:+b.y.toFixed(3),width:+b.width.toFixed(3),height:+b.height.toFixed(3),contents:this.outerSVG()});return"data:image/svg+xml;base64,"+btoa(unescape(encodeURIComponent(c)))}},h.prototype.select=m.select,h.prototype.selectAll=m.selectAll}),d.plugin(function(a){function b(a,b,d,e,f,g){return null==b&&"[object SVGMatrix]"==c.call(a)?(this.a=a.a,this.b=a.b,this.c=a.c,this.d=a.d,this.e=a.e,void(this.f=a.f)):void(null!=a?(this.a=+a,this.b=+b,this.c=+d,this.d=+e,this.e=+f,this.f=+g):(this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0))}var c=Object.prototype.toString,d=String,e=Math,f="";!function(c){function g(a){return a[0]*a[0]+a[1]*a[1]}function h(a){var b=e.sqrt(g(a));a[0]&&(a[0]/=b),a[1]&&(a[1]/=b)}c.add=function(a,c,d,e,f,g){var h,i,j,k,l=[[],[],[]],m=[[this.a,this.c,this.e],[this.b,this.d,this.f],[0,0,1]],n=[[a,d,f],[c,e,g],[0,0,1]];for(a&&a instanceof b&&(n=[[a.a,a.c,a.e],[a.b,a.d,a.f],[0,0,1]]),h=0;3>h;h++)for(i=0;3>i;i++){for(k=0,j=0;3>j;j++)k+=m[h][j]*n[j][i];l[h][i]=k}return this.a=l[0][0],this.b=l[1][0],this.c=l[0][1],this.d=l[1][1],this.e=l[0][2],this.f=l[1][2],this},c.invert=function(){var a=this,c=a.a*a.d-a.b*a.c;return new b(a.d/c,-a.b/c,-a.c/c,a.a/c,(a.c*a.f-a.d*a.e)/c,(a.b*a.e-a.a*a.f)/c)},c.clone=function(){return new b(this.a,this.b,this.c,this.d,this.e,this.f)},c.translate=function(a,b){return this.add(1,0,0,1,a,b)},c.scale=function(a,b,c,d){return null==b&&(b=a),(c||d)&&this.add(1,0,0,1,c,d),this.add(a,0,0,b,0,0),(c||d)&&this.add(1,0,0,1,-c,-d),this},c.rotate=function(b,c,d){b=a.rad(b),c=c||0,d=d||0;var f=+e.cos(b).toFixed(9),g=+e.sin(b).toFixed(9);return this.add(f,g,-g,f,c,d),this.add(1,0,0,1,-c,-d)},c.x=function(a,b){return a*this.a+b*this.c+this.e},c.y=function(a,b){return a*this.b+b*this.d+this.f},c.get=function(a){return+this[d.fromCharCode(97+a)].toFixed(4)},c.toString=function(){return"matrix("+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)].join()+")"},c.offset=function(){return[this.e.toFixed(4),this.f.toFixed(4)]},c.determinant=function(){return this.a*this.d-this.b*this.c},c.split=function(){var b={};b.dx=this.e,b.dy=this.f;var c=[[this.a,this.c],[this.b,this.d]];b.scalex=e.sqrt(g(c[0])),h(c[0]),b.shear=c[0][0]*c[1][0]+c[0][1]*c[1][1],c[1]=[c[1][0]-c[0][0]*b.shear,c[1][1]-c[0][1]*b.shear],b.scaley=e.sqrt(g(c[1])),h(c[1]),b.shear/=b.scaley,this.determinant()<0&&(b.scalex=-b.scalex);var d=-c[0][1],f=c[1][1];return 0>f?(b.rotate=a.deg(e.acos(f)),0>d&&(b.rotate=360-b.rotate)):b.rotate=a.deg(e.asin(d)),b.isSimple=!(+b.shear.toFixed(9)||b.scalex.toFixed(9)!=b.scaley.toFixed(9)&&b.rotate),b.isSuperSimple=!+b.shear.toFixed(9)&&b.scalex.toFixed(9)==b.scaley.toFixed(9)&&!b.rotate,b.noRotation=!+b.shear.toFixed(9)&&!b.rotate,b},c.toTransformString=function(a){var b=a||this.split();return+b.shear.toFixed(9)?"m"+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)]:(b.scalex=+b.scalex.toFixed(4),b.scaley=+b.scaley.toFixed(4),b.rotate=+b.rotate.toFixed(4),(b.dx||b.dy?"t"+[+b.dx.toFixed(4),+b.dy.toFixed(4)]:f)+(1!=b.scalex||1!=b.scaley?"s"+[b.scalex,b.scaley,0,0]:f)+(b.rotate?"r"+[+b.rotate.toFixed(4),0,0]:f))}}(b.prototype),a.Matrix=b,a.matrix=function(a,c,d,e,f,g){return new b(a,c,d,e,f,g)}}),d.plugin(function(a,c,d,e,f){function g(d){return function(e){if(b.stop(),e instanceof f&&1==e.node.childNodes.length&&("radialGradient"==e.node.firstChild.tagName||"linearGradient"==e.node.firstChild.tagName||"pattern"==e.node.firstChild.tagName)&&(e=e.node.firstChild,n(this).appendChild(e),e=l(e)),e instanceof c)if("radialGradient"==e.type||"linearGradient"==e.type||"pattern"==e.type){e.node.id||p(e.node,{id:e.id});var g=q(e.node.id)}else g=e.attr(d);else if(g=a.color(e),g.error){var h=a(n(this).ownerSVGElement).gradient(e);h?(h.node.id||p(h.node,{id:h.id}),g=q(h.node.id)):g=e}else g=r(g);var i={};i[d]=g,p(this.node,i),this.node.style[d]=t}}function h(a){b.stop(),a==+a&&(a+="px"),this.node.style.fontSize=a}function i(a){for(var b=[],c=a.childNodes,d=0,e=c.length;e>d;d++){var f=c[d];3==f.nodeType&&b.push(f.nodeValue),"tspan"==f.tagName&&b.push(1==f.childNodes.length&&3==f.firstChild.nodeType?f.firstChild.nodeValue:i(f))}return b}function j(){return b.stop(),this.node.style.fontSize}var k=a._.make,l=a._.wrap,m=a.is,n=a._.getSomeDefs,o=/^url\(#?([^)]+)\)$/,p=a._.$,q=a.url,r=String,s=a._.separator,t="";b.on("snap.util.attr.mask",function(a){if(a instanceof c||a instanceof f){if(b.stop(),a instanceof f&&1==a.node.childNodes.length&&(a=a.node.firstChild,n(this).appendChild(a),a=l(a)),"mask"==a.type)var d=a;else d=k("mask",n(this)),d.node.appendChild(a.node);!d.node.id&&p(d.node,{id:d.id}),p(this.node,{mask:q(d.id)})}}),function(a){b.on("snap.util.attr.clip",a),b.on("snap.util.attr.clip-path",a),b.on("snap.util.attr.clipPath",a)}(function(a){if(a instanceof c||a instanceof f){if(b.stop(),"clipPath"==a.type)var d=a;else d=k("clipPath",n(this)),d.node.appendChild(a.node),!d.node.id&&p(d.node,{id:d.id});p(this.node,{"clip-path":q(d.node.id||d.id)})}}),b.on("snap.util.attr.fill",g("fill")),b.on("snap.util.attr.stroke",g("stroke"));var u=/^([lr])(?:\(([^)]*)\))?(.*)$/i;b.on("snap.util.grad.parse",function(a){a=r(a);var b=a.match(u);if(!b)return null;var c=b[1],d=b[2],e=b[3];return d=d.split(/\s*,\s*/).map(function(a){return+a==a?+a:a}),1==d.length&&0==d[0]&&(d=[]),e=e.split("-"),e=e.map(function(a){a=a.split(":");var b={color:a[0]};return a[1]&&(b.offset=parseFloat(a[1])),b}),{type:c,params:d,stops:e}}),b.on("snap.util.attr.d",function(c){b.stop(),m(c,"array")&&m(c[0],"array")&&(c=a.path.toString.call(c)),c=r(c),c.match(/[ruo]/i)&&(c=a.path.toAbsolute(c)),p(this.node,{d:c})})(-1),b.on("snap.util.attr.#text",function(a){b.stop(),a=r(a);for(var c=e.doc.createTextNode(a);this.node.firstChild;)this.node.removeChild(this.node.firstChild);this.node.appendChild(c)})(-1),b.on("snap.util.attr.path",function(a){b.stop(),this.attr({d:a})})(-1),b.on("snap.util.attr.class",function(a){b.stop(),this.node.className.baseVal=a})(-1),b.on("snap.util.attr.viewBox",function(a){var c;c=m(a,"object")&&"x"in a?[a.x,a.y,a.width,a.height].join(" "):m(a,"array")?a.join(" "):a,p(this.node,{viewBox:c}),b.stop()})(-1),b.on("snap.util.attr.transform",function(a){this.transform(a),b.stop()})(-1),b.on("snap.util.attr.r",function(a){"rect"==this.type&&(b.stop(),p(this.node,{rx:a,ry:a}))})(-1),b.on("snap.util.attr.textpath",function(a){if(b.stop(),"text"==this.type){var d,e,f;if(!a&&this.textPath){for(e=this.textPath;e.node.firstChild;)this.node.appendChild(e.node.firstChild);return e.remove(),void delete this.textPath}if(m(a,"string")){var g=n(this),h=l(g.parentNode).path(a);g.appendChild(h.node),d=h.id,h.attr({id:d})}else a=l(a),a instanceof c&&(d=a.attr("id"),d||(d=a.id,a.attr({id:d})));if(d)if(e=this.textPath,f=this.node,e)e.attr({"xlink:href":"#"+d});else{for(e=p("textPath",{"xlink:href":"#"+d});f.firstChild;)e.appendChild(f.firstChild);f.appendChild(e),this.textPath=l(e)}}})(-1),b.on("snap.util.attr.text",function(a){if("text"==this.type){for(var c=this.node,d=function(a){var b=p("tspan");if(m(a,"array"))for(var c=0;c<a.length;c++)b.appendChild(d(a[c]));else b.appendChild(e.doc.createTextNode(a));return b.normalize&&b.normalize(),b};c.firstChild;)c.removeChild(c.firstChild);for(var f=d(a);f.firstChild;)c.appendChild(f.firstChild)}b.stop()})(-1),b.on("snap.util.attr.fontSize",h)(-1),b.on("snap.util.attr.font-size",h)(-1),b.on("snap.util.getattr.transform",function(){return b.stop(),this.transform()})(-1),b.on("snap.util.getattr.textpath",function(){return b.stop(),this.textPath})(-1),function(){function c(c){return function(){b.stop();var d=e.doc.defaultView.getComputedStyle(this.node,null).getPropertyValue("marker-"+c);return"none"==d?d:a(e.doc.getElementById(d.match(o)[1]))}}function d(a){return function(c){b.stop();var d="marker"+a.charAt(0).toUpperCase()+a.substring(1);if(""==c||!c)return void(this.node.style[d]="none");if("marker"==c.type){var e=c.node.id;return e||p(c.node,{id:c.id}),void(this.node.style[d]=q(e))}}}b.on("snap.util.getattr.marker-end",c("end"))(-1),b.on("snap.util.getattr.markerEnd",c("end"))(-1),b.on("snap.util.getattr.marker-start",c("start"))(-1),b.on("snap.util.getattr.markerStart",c("start"))(-1),b.on("snap.util.getattr.marker-mid",c("mid"))(-1),b.on("snap.util.getattr.markerMid",c("mid"))(-1),b.on("snap.util.attr.marker-end",d("end"))(-1),b.on("snap.util.attr.markerEnd",d("end"))(-1),b.on("snap.util.attr.marker-start",d("start"))(-1),b.on("snap.util.attr.markerStart",d("start"))(-1),b.on("snap.util.attr.marker-mid",d("mid"))(-1),b.on("snap.util.attr.markerMid",d("mid"))(-1)}(),b.on("snap.util.getattr.r",function(){return"rect"==this.type&&p(this.node,"rx")==p(this.node,"ry")?(b.stop(),p(this.node,"rx")):void 0})(-1),b.on("snap.util.getattr.text",function(){if("text"==this.type||"tspan"==this.type){b.stop();var a=i(this.node);return 1==a.length?a[0]:a}})(-1),b.on("snap.util.getattr.#text",function(){return this.node.textContent})(-1),b.on("snap.util.getattr.viewBox",function(){b.stop();var c=p(this.node,"viewBox");return c?(c=c.split(s),a._.box(+c[0],+c[1],+c[2],+c[3])):void 0})(-1),b.on("snap.util.getattr.points",function(){var a=p(this.node,"points");return b.stop(),a?a.split(s):void 0})(-1),b.on("snap.util.getattr.path",function(){var a=p(this.node,"d");return b.stop(),a})(-1),b.on("snap.util.getattr.class",function(){return this.node.className.baseVal})(-1),b.on("snap.util.getattr.fontSize",j)(-1),b.on("snap.util.getattr.font-size",j)(-1)}),d.plugin(function(a,b){var c=/\S+/g,d=String,e=b.prototype;e.addClass=function(a){var b,e,f,g,h=d(a||"").match(c)||[],i=this.node,j=i.className.baseVal,k=j.match(c)||[];if(h.length){for(b=0;f=h[b++];)e=k.indexOf(f),~e||k.push(f);g=k.join(" "),j!=g&&(i.className.baseVal=g)}return this},e.removeClass=function(a){var b,e,f,g,h=d(a||"").match(c)||[],i=this.node,j=i.className.baseVal,k=j.match(c)||[];if(k.length){for(b=0;f=h[b++];)e=k.indexOf(f),~e&&k.splice(e,1);g=k.join(" "),j!=g&&(i.className.baseVal=g)}return this},e.hasClass=function(a){var b=this.node,d=b.className.baseVal,e=d.match(c)||[];return!!~e.indexOf(a)},e.toggleClass=function(a,b){if(null!=b)return b?this.addClass(a):this.removeClass(a);var d,e,f,g,h=(a||"").match(c)||[],i=this.node,j=i.className.baseVal,k=j.match(c)||[];for(d=0;f=h[d++];)e=k.indexOf(f),~e?k.splice(e,1):k.push(f);return g=k.join(" "),j!=g&&(i.className.baseVal=g),this}}),d.plugin(function(){function a(a){return a}function c(a){return function(b){return+b.toFixed(3)+a}}var d={"+":function(a,b){return a+b},"-":function(a,b){return a-b},"/":function(a,b){return a/b},"*":function(a,b){return a*b}},e=String,f=/[a-z]+$/i,g=/^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;b.on("snap.util.attr",function(a){var c=e(a).match(g);if(c){var h=b.nt(),i=h.substring(h.lastIndexOf(".")+1),j=this.attr(i),k={};b.stop();var l=c[3]||"",m=j.match(f),n=d[c[1]];if(m&&m==l?a=n(parseFloat(j),+c[2]):(j=this.asPX(i),a=n(this.asPX(i),this.asPX(i,c[2]+l))),isNaN(j)||isNaN(a))return;k[i]=a,this.attr(k)}})(-10),b.on("snap.util.equal",function(h,i){var j=e(this.attr(h)||""),k=e(i).match(g);if(k){b.stop();var l=k[3]||"",m=j.match(f),n=d[k[1]];return m&&m==l?{from:parseFloat(j),to:n(parseFloat(j),+k[2]),f:c(m)}:(j=this.asPX(h),{from:j,to:n(j,this.asPX(h,k[2]+l)),f:a})}})(-10)}),d.plugin(function(c,d,e,f){var g=e.prototype,h=c.is;g.rect=function(a,b,c,d,e,f){var g;return null==f&&(f=e),h(a,"object")&&"[object Object]"==a?g=a:null!=a&&(g={x:a,y:b,width:c,height:d},null!=e&&(g.rx=e,g.ry=f)),this.el("rect",g)},g.circle=function(a,b,c){var d;return h(a,"object")&&"[object Object]"==a?d=a:null!=a&&(d={cx:a,cy:b,r:c}),this.el("circle",d)};var i=function(){function a(){this.parentNode.removeChild(this)}return function(b,c){var d=f.doc.createElement("img"),e=f.doc.body;d.style.cssText="position:absolute;left:-9999em;top:-9999em",d.onload=function(){c.call(d),d.onload=d.onerror=null,e.removeChild(d)},d.onerror=a,e.appendChild(d),d.src=b}}();g.image=function(a,b,d,e,f){var g=this.el("image");if(h(a,"object")&&"src"in a)g.attr(a);else if(null!=a){var j={"xlink:href":a,preserveAspectRatio:"none"};null!=b&&null!=d&&(j.x=b,j.y=d),null!=e&&null!=f?(j.width=e,j.height=f):i(a,function(){c._.$(g.node,{width:this.offsetWidth,height:this.offsetHeight})}),c._.$(g.node,j)}return g},g.ellipse=function(a,b,c,d){var e;return h(a,"object")&&"[object Object]"==a?e=a:null!=a&&(e={cx:a,cy:b,rx:c,ry:d}),this.el("ellipse",e)},g.path=function(a){var b;return h(a,"object")&&!h(a,"array")?b=a:a&&(b={d:a}),this.el("path",b)},g.group=g.g=function(a){var b=this.el("g");return 1==arguments.length&&a&&!a.type?b.attr(a):arguments.length&&b.add(Array.prototype.slice.call(arguments,0)),b},g.svg=function(a,b,c,d,e,f,g,i){var j={};return h(a,"object")&&null==b?j=a:(null!=a&&(j.x=a),null!=b&&(j.y=b),null!=c&&(j.width=c),null!=d&&(j.height=d),null!=e&&null!=f&&null!=g&&null!=i&&(j.viewBox=[e,f,g,i])),this.el("svg",j)},g.mask=function(a){var b=this.el("mask");return 1==arguments.length&&a&&!a.type?b.attr(a):arguments.length&&b.add(Array.prototype.slice.call(arguments,0)),b},g.ptrn=function(a,b,c,d,e,f,g,i){if(h(a,"object"))var j=a;else j={patternUnits:"userSpaceOnUse"},a&&(j.x=a),b&&(j.y=b),null!=c&&(j.width=c),null!=d&&(j.height=d),j.viewBox=null!=e&&null!=f&&null!=g&&null!=i?[e,f,g,i]:[a||0,b||0,c||0,d||0];return this.el("pattern",j)},g.use=function(a){return null!=a?(a instanceof d&&(a.attr("id")||a.attr({id:c._.id(a)}),a=a.attr("id")),"#"==String(a).charAt()&&(a=a.substring(1)),this.el("use",{"xlink:href":"#"+a})):d.prototype.use.call(this)},g.symbol=function(a,b,c,d){var e={};return null!=a&&null!=b&&null!=c&&null!=d&&(e.viewBox=[a,b,c,d]),this.el("symbol",e)},g.text=function(a,b,c){var d={};return h(a,"object")?d=a:null!=a&&(d={x:a,y:b,text:c||""}),this.el("text",d)},g.line=function(a,b,c,d){var e={};return h(a,"object")?e=a:null!=a&&(e={x1:a,x2:c,y1:b,y2:d}),this.el("line",e)},g.polyline=function(a){arguments.length>1&&(a=Array.prototype.slice.call(arguments,0));var b={};return h(a,"object")&&!h(a,"array")?b=a:null!=a&&(b={points:a}),this.el("polyline",b)},g.polygon=function(a){arguments.length>1&&(a=Array.prototype.slice.call(arguments,0));var b={};return h(a,"object")&&!h(a,"array")?b=a:null!=a&&(b={points:a}),this.el("polygon",b)},function(){function d(){return this.selectAll("stop")}function e(a,b){var d=k("stop"),e={offset:+b+"%"};return a=c.color(a),e["stop-color"]=a.hex,a.opacity<1&&(e["stop-opacity"]=a.opacity),k(d,e),this.node.appendChild(d),this}function f(){if("linearGradient"==this.type){var a=k(this.node,"x1")||0,b=k(this.node,"x2")||1,d=k(this.node,"y1")||0,e=k(this.node,"y2")||0;return c._.box(a,d,math.abs(b-a),math.abs(e-d))}var f=this.node.cx||.5,g=this.node.cy||.5,h=this.node.r||0;return c._.box(f-h,g-h,2*h,2*h)}function h(a,c){function d(a,b){for(var c=(b-l)/(a-m),d=m;a>d;d++)g[d].offset=+(+l+c*(d-m)).toFixed(2);m=a,l=b}var e,f=b("snap.util.grad.parse",null,c).firstDefined();if(!f)return null;f.params.unshift(a),e="l"==f.type.toLowerCase()?i.apply(0,f.params):j.apply(0,f.params),f.type!=f.type.toLowerCase()&&k(e.node,{gradientUnits:"userSpaceOnUse"});var g=f.stops,h=g.length,l=0,m=0;h--;for(var n=0;h>n;n++)"offset"in g[n]&&d(n,g[n].offset);for(g[h].offset=g[h].offset||100,d(h,g[h].offset),n=0;h>=n;n++){var o=g[n];e.addStop(o.color,o.offset)}return e}function i(a,b,g,h,i){var j=c._.make("linearGradient",a);return j.stops=d,j.addStop=e,j.getBBox=f,null!=b&&k(j.node,{x1:b,y1:g,x2:h,y2:i}),j}function j(a,b,g,h,i,j){var l=c._.make("radialGradient",a);return l.stops=d,l.addStop=e,l.getBBox=f,null!=b&&k(l.node,{cx:b,cy:g,r:h}),null!=i&&null!=j&&k(l.node,{fx:i,fy:j}),l}var k=c._.$;g.gradient=function(a){return h(this.defs,a)},g.gradientLinear=function(a,b,c,d){return i(this.defs,a,b,c,d)},g.gradientRadial=function(a,b,c,d,e){return j(this.defs,a,b,c,d,e)},g.toString=function(){var a,b=this.node.ownerDocument,d=b.createDocumentFragment(),e=b.createElement("div"),f=this.node.cloneNode(!0);return d.appendChild(e),e.appendChild(f),c._.$(f,{xmlns:"http://www.w3.org/2000/svg"}),a=e.innerHTML,d.removeChild(d.firstChild),a},g.toDataURL=function(){return a&&a.btoa?"data:image/svg+xml;base64,"+btoa(unescape(encodeURIComponent(this))):void 0},g.clear=function(){for(var a,b=this.node.firstChild;b;)a=b.nextSibling,"defs"!=b.tagName?b.parentNode.removeChild(b):g.clear.call({node:b}),b=a}}()}),d.plugin(function(a,b){function c(a){var b=c.ps=c.ps||{};return b[a]?b[a].sleep=100:b[a]={sleep:100},setTimeout(function(){for(var c in b)b[K](c)&&c!=a&&(b[c].sleep--,!b[c].sleep&&delete b[c])}),b[a]}function d(a,b,c,d){return null==a&&(a=b=c=d=0),null==b&&(b=a.y,c=a.width,d=a.height,a=a.x),{x:a,y:b,width:c,w:c,height:d,h:d,x2:a+c,y2:b+d,cx:a+c/2,cy:b+d/2,r1:N.min(c,d)/2,r2:N.max(c,d)/2,r0:N.sqrt(c*c+d*d)/2,path:w(a,b,c,d),vb:[a,b,c,d].join(" ")}}function e(){return this.join(",").replace(L,"$1")}function f(a){var b=J(a);return b.toString=e,b}function g(a,b,c,d,e,f,g,h,j){return null==j?n(a,b,c,d,e,f,g,h):i(a,b,c,d,e,f,g,h,o(a,b,c,d,e,f,g,h,j))}function h(c,d){function e(a){return+(+a).toFixed(3)}return a._.cacher(function(a,f,h){a instanceof b&&(a=a.attr("d")),a=E(a);for(var j,k,l,m,n,o="",p={},q=0,r=0,s=a.length;s>r;r++){if(l=a[r],"M"==l[0])j=+l[1],k=+l[2];else{if(m=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6]),q+m>f){if(d&&!p.start){if(n=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6],f-q),o+=["C"+e(n.start.x),e(n.start.y),e(n.m.x),e(n.m.y),e(n.x),e(n.y)],h)return o;p.start=o,o=["M"+e(n.x),e(n.y)+"C"+e(n.n.x),e(n.n.y),e(n.end.x),e(n.end.y),e(l[5]),e(l[6])].join(),q+=m,j=+l[5],k=+l[6];continue}if(!c&&!d)return n=g(j,k,l[1],l[2],l[3],l[4],l[5],l[6],f-q)}q+=m,j=+l[5],k=+l[6]}o+=l.shift()+l}return p.end=o,n=c?q:d?p:i(j,k,l[0],l[1],l[2],l[3],l[4],l[5],1)},null,a._.clone)}function i(a,b,c,d,e,f,g,h,i){var j=1-i,k=R(j,3),l=R(j,2),m=i*i,n=m*i,o=k*a+3*l*i*c+3*j*i*i*e+n*g,p=k*b+3*l*i*d+3*j*i*i*f+n*h,q=a+2*i*(c-a)+m*(e-2*c+a),r=b+2*i*(d-b)+m*(f-2*d+b),s=c+2*i*(e-c)+m*(g-2*e+c),t=d+2*i*(f-d)+m*(h-2*f+d),u=j*a+i*c,v=j*b+i*d,w=j*e+i*g,x=j*f+i*h,y=90-180*N.atan2(q-s,r-t)/O;return{x:o,y:p,m:{x:q,y:r},n:{x:s,y:t},start:{x:u,y:v},end:{x:w,y:x},alpha:y}}function j(b,c,e,f,g,h,i,j){a.is(b,"array")||(b=[b,c,e,f,g,h,i,j]);var k=D.apply(null,b);return d(k.min.x,k.min.y,k.max.x-k.min.x,k.max.y-k.min.y)}function k(a,b,c){return b>=a.x&&b<=a.x+a.width&&c>=a.y&&c<=a.y+a.height}function l(a,b){return a=d(a),b=d(b),k(b,a.x,a.y)||k(b,a.x2,a.y)||k(b,a.x,a.y2)||k(b,a.x2,a.y2)||k(a,b.x,b.y)||k(a,b.x2,b.y)||k(a,b.x,b.y2)||k(a,b.x2,b.y2)||(a.x<b.x2&&a.x>b.x||b.x<a.x2&&b.x>a.x)&&(a.y<b.y2&&a.y>b.y||b.y<a.y2&&b.y>a.y)}function m(a,b,c,d,e){var f=-3*b+9*c-9*d+3*e,g=a*f+6*b-12*c+6*d;return a*g-3*b+3*c}function n(a,b,c,d,e,f,g,h,i){null==i&&(i=1),i=i>1?1:0>i?0:i;for(var j=i/2,k=12,l=[-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],n=[.2491,.2491,.2335,.2335,.2032,.2032,.1601,.1601,.1069,.1069,.0472,.0472],o=0,p=0;k>p;p++){var q=j*l[p]+j,r=m(q,a,c,e,g),s=m(q,b,d,f,h),t=r*r+s*s;o+=n[p]*N.sqrt(t)}return j*o}function o(a,b,c,d,e,f,g,h,i){if(!(0>i||n(a,b,c,d,e,f,g,h)<i)){var j,k=1,l=k/2,m=k-l,o=.01;for(j=n(a,b,c,d,e,f,g,h,m);S(j-i)>o;)l/=2,m+=(i>j?1:-1)*l,j=n(a,b,c,d,e,f,g,h,m);return m}}function p(a,b,c,d,e,f,g,h){if(!(Q(a,c)<P(e,g)||P(a,c)>Q(e,g)||Q(b,d)<P(f,h)||P(b,d)>Q(f,h))){var i=(a*d-b*c)*(e-g)-(a-c)*(e*h-f*g),j=(a*d-b*c)*(f-h)-(b-d)*(e*h-f*g),k=(a-c)*(f-h)-(b-d)*(e-g);if(k){var l=i/k,m=j/k,n=+l.toFixed(2),o=+m.toFixed(2);if(!(n<+P(a,c).toFixed(2)||n>+Q(a,c).toFixed(2)||n<+P(e,g).toFixed(2)||n>+Q(e,g).toFixed(2)||o<+P(b,d).toFixed(2)||o>+Q(b,d).toFixed(2)||o<+P(f,h).toFixed(2)||o>+Q(f,h).toFixed(2)))return{x:l,y:m}}}}function q(a,b,c){var d=j(a),e=j(b);if(!l(d,e))return c?0:[];for(var f=n.apply(0,a),g=n.apply(0,b),h=~~(f/8),k=~~(g/8),m=[],o=[],q={},r=c?0:[],s=0;h+1>s;s++){var t=i.apply(0,a.concat(s/h));m.push({x:t.x,y:t.y,t:s/h})}for(s=0;k+1>s;s++)t=i.apply(0,b.concat(s/k)),o.push({x:t.x,y:t.y,t:s/k});for(s=0;h>s;s++)for(var u=0;k>u;u++){var v=m[s],w=m[s+1],x=o[u],y=o[u+1],z=S(w.x-v.x)<.001?"y":"x",A=S(y.x-x.x)<.001?"y":"x",B=p(v.x,v.y,w.x,w.y,x.x,x.y,y.x,y.y);if(B){if(q[B.x.toFixed(4)]==B.y.toFixed(4))continue;q[B.x.toFixed(4)]=B.y.toFixed(4);var C=v.t+S((B[z]-v[z])/(w[z]-v[z]))*(w.t-v.t),D=x.t+S((B[A]-x[A])/(y[A]-x[A]))*(y.t-x.t);C>=0&&1>=C&&D>=0&&1>=D&&(c?r++:r.push({x:B.x,y:B.y,t1:C,t2:D}))}}return r}function r(a,b){return t(a,b)}function s(a,b){return t(a,b,1)}function t(a,b,c){a=E(a),b=E(b);for(var d,e,f,g,h,i,j,k,l,m,n=c?0:[],o=0,p=a.length;p>o;o++){var r=a[o];if("M"==r[0])d=h=r[1],e=i=r[2];else{"C"==r[0]?(l=[d,e].concat(r.slice(1)),d=l[6],e=l[7]):(l=[d,e,d,e,h,i,h,i],d=h,e=i);for(var s=0,t=b.length;t>s;s++){var u=b[s];if("M"==u[0])f=j=u[1],g=k=u[2];else{"C"==u[0]?(m=[f,g].concat(u.slice(1)),f=m[6],g=m[7]):(m=[f,g,f,g,j,k,j,k],f=j,g=k);var v=q(l,m,c);if(c)n+=v;else{for(var w=0,x=v.length;x>w;w++)v[w].segment1=o,v[w].segment2=s,v[w].bez1=l,v[w].bez2=m;n=n.concat(v)}}}}}return n}function u(a,b,c){var d=v(a);return k(d,b,c)&&t(a,[["M",b,c],["H",d.x2+10]],1)%2==1}function v(a){var b=c(a);if(b.bbox)return J(b.bbox);if(!a)return d();a=E(a);for(var e,f=0,g=0,h=[],i=[],j=0,k=a.length;k>j;j++)if(e=a[j],"M"==e[0])f=e[1],g=e[2],h.push(f),i.push(g);else{var l=D(f,g,e[1],e[2],e[3],e[4],e[5],e[6]);h=h.concat(l.min.x,l.max.x),i=i.concat(l.min.y,l.max.y),f=e[5],g=e[6]}var m=P.apply(0,h),n=P.apply(0,i),o=Q.apply(0,h),p=Q.apply(0,i),q=d(m,n,o-m,p-n);return b.bbox=J(q),q}function w(a,b,c,d,f){if(f)return[["M",+a+ +f,b],["l",c-2*f,0],["a",f,f,0,0,1,f,f],["l",0,d-2*f],["a",f,f,0,0,1,-f,f],["l",2*f-c,0],["a",f,f,0,0,1,-f,-f],["l",0,2*f-d],["a",f,f,0,0,1,f,-f],["z"]];var g=[["M",a,b],["l",c,0],["l",0,d],["l",-c,0],["z"]];return g.toString=e,g}function x(a,b,c,d,f){if(null==f&&null==d&&(d=c),a=+a,b=+b,c=+c,d=+d,null!=f)var g=Math.PI/180,h=a+c*Math.cos(-d*g),i=a+c*Math.cos(-f*g),j=b+c*Math.sin(-d*g),k=b+c*Math.sin(-f*g),l=[["M",h,j],["A",c,c,0,+(f-d>180),0,i,k]];else l=[["M",a,b],["m",0,-d],["a",c,d,0,1,1,0,2*d],["a",c,d,0,1,1,0,-2*d],["z"]];return l.toString=e,l}function y(b){var d=c(b),g=String.prototype.toLowerCase;if(d.rel)return f(d.rel);a.is(b,"array")&&a.is(b&&b[0],"array")||(b=a.parsePathString(b));var h=[],i=0,j=0,k=0,l=0,m=0;"M"==b[0][0]&&(i=b[0][1],j=b[0][2],k=i,l=j,m++,h.push(["M",i,j]));for(var n=m,o=b.length;o>n;n++){var p=h[n]=[],q=b[n];if(q[0]!=g.call(q[0]))switch(p[0]=g.call(q[0]),p[0]){case"a":p[1]=q[1],p[2]=q[2],p[3]=q[3],p[4]=q[4],p[5]=q[5],p[6]=+(q[6]-i).toFixed(3),p[7]=+(q[7]-j).toFixed(3);break;case"v":p[1]=+(q[1]-j).toFixed(3);break;case"m":k=q[1],l=q[2];default:for(var r=1,s=q.length;s>r;r++)p[r]=+(q[r]-(r%2?i:j)).toFixed(3)}else{p=h[n]=[],"m"==q[0]&&(k=q[1]+i,l=q[2]+j);for(var t=0,u=q.length;u>t;t++)h[n][t]=q[t]}var v=h[n].length;switch(h[n][0]){case"z":i=k,j=l;break;case"h":i+=+h[n][v-1];break;case"v":j+=+h[n][v-1];break;default:i+=+h[n][v-2],j+=+h[n][v-1]}}return h.toString=e,d.rel=f(h),h}function z(b){var d=c(b);if(d.abs)return f(d.abs);if(I(b,"array")&&I(b&&b[0],"array")||(b=a.parsePathString(b)),!b||!b.length)return[["M",0,0]];var g,h=[],i=0,j=0,k=0,l=0,m=0;"M"==b[0][0]&&(i=+b[0][1],j=+b[0][2],k=i,l=j,m++,h[0]=["M",i,j]);for(var n,o,p=3==b.length&&"M"==b[0][0]&&"R"==b[1][0].toUpperCase()&&"Z"==b[2][0].toUpperCase(),q=m,r=b.length;r>q;q++){if(h.push(n=[]),o=b[q],g=o[0],g!=g.toUpperCase())switch(n[0]=g.toUpperCase(),n[0]){case"A":n[1]=o[1],n[2]=o[2],n[3]=o[3],n[4]=o[4],n[5]=o[5],n[6]=+o[6]+i,n[7]=+o[7]+j;break;case"V":n[1]=+o[1]+j;break;case"H":n[1]=+o[1]+i;break;case"R":for(var s=[i,j].concat(o.slice(1)),t=2,u=s.length;u>t;t++)s[t]=+s[t]+i,s[++t]=+s[t]+j;h.pop(),h=h.concat(G(s,p));break;case"O":h.pop(),s=x(i,j,o[1],o[2]),s.push(s[0]),h=h.concat(s);break;case"U":h.pop(),h=h.concat(x(i,j,o[1],o[2],o[3])),n=["U"].concat(h[h.length-1].slice(-2));break;case"M":k=+o[1]+i,l=+o[2]+j;default:for(t=1,u=o.length;u>t;t++)n[t]=+o[t]+(t%2?i:j)}else if("R"==g)s=[i,j].concat(o.slice(1)),h.pop(),h=h.concat(G(s,p)),n=["R"].concat(o.slice(-2));else if("O"==g)h.pop(),s=x(i,j,o[1],o[2]),s.push(s[0]),h=h.concat(s);else if("U"==g)h.pop(),h=h.concat(x(i,j,o[1],o[2],o[3])),n=["U"].concat(h[h.length-1].slice(-2));else for(var v=0,w=o.length;w>v;v++)n[v]=o[v];if(g=g.toUpperCase(),"O"!=g)switch(n[0]){case"Z":i=+k,j=+l;break;case"H":i=n[1];break;case"V":j=n[1];break;case"M":k=n[n.length-2],l=n[n.length-1];default:i=n[n.length-2],j=n[n.length-1]}}return h.toString=e,d.abs=f(h),h}function A(a,b,c,d){return[a,b,c,d,c,d]}function B(a,b,c,d,e,f){var g=1/3,h=2/3;return[g*a+h*c,g*b+h*d,g*e+h*c,g*f+h*d,e,f]}function C(b,c,d,e,f,g,h,i,j,k){var l,m=120*O/180,n=O/180*(+f||0),o=[],p=a._.cacher(function(a,b,c){var d=a*N.cos(c)-b*N.sin(c),e=a*N.sin(c)+b*N.cos(c);return{x:d,y:e}});if(k)y=k[0],z=k[1],w=k[2],x=k[3];else{l=p(b,c,-n),b=l.x,c=l.y,l=p(i,j,-n),i=l.x,j=l.y;var q=(N.cos(O/180*f),N.sin(O/180*f),(b-i)/2),r=(c-j)/2,s=q*q/(d*d)+r*r/(e*e);s>1&&(s=N.sqrt(s),d=s*d,e=s*e);var t=d*d,u=e*e,v=(g==h?-1:1)*N.sqrt(S((t*u-t*r*r-u*q*q)/(t*r*r+u*q*q))),w=v*d*r/e+(b+i)/2,x=v*-e*q/d+(c+j)/2,y=N.asin(((c-x)/e).toFixed(9)),z=N.asin(((j-x)/e).toFixed(9));y=w>b?O-y:y,z=w>i?O-z:z,0>y&&(y=2*O+y),0>z&&(z=2*O+z),h&&y>z&&(y-=2*O),!h&&z>y&&(z-=2*O)}var A=z-y;if(S(A)>m){var B=z,D=i,E=j;z=y+m*(h&&z>y?1:-1),i=w+d*N.cos(z),j=x+e*N.sin(z),o=C(i,j,d,e,f,0,h,D,E,[z,B,w,x])}A=z-y;var F=N.cos(y),G=N.sin(y),H=N.cos(z),I=N.sin(z),J=N.tan(A/4),K=4/3*d*J,L=4/3*e*J,M=[b,c],P=[b+K*G,c-L*F],Q=[i+K*I,j-L*H],R=[i,j];if(P[0]=2*M[0]-P[0],P[1]=2*M[1]-P[1],k)return[P,Q,R].concat(o);o=[P,Q,R].concat(o).join().split(",");for(var T=[],U=0,V=o.length;V>U;U++)T[U]=U%2?p(o[U-1],o[U],n).y:p(o[U],o[U+1],n).x;return T}function D(a,b,c,d,e,f,g,h){for(var i,j,k,l,m,n,o,p,q=[],r=[[],[]],s=0;2>s;++s)if(0==s?(j=6*a-12*c+6*e,i=-3*a+9*c-9*e+3*g,k=3*c-3*a):(j=6*b-12*d+6*f,i=-3*b+9*d-9*f+3*h,k=3*d-3*b),S(i)<1e-12){if(S(j)<1e-12)continue;l=-k/j,l>0&&1>l&&q.push(l)}else o=j*j-4*k*i,p=N.sqrt(o),0>o||(m=(-j+p)/(2*i),m>0&&1>m&&q.push(m),n=(-j-p)/(2*i),n>0&&1>n&&q.push(n));for(var t,u=q.length,v=u;u--;)l=q[u],t=1-l,r[0][u]=t*t*t*a+3*t*t*l*c+3*t*l*l*e+l*l*l*g,r[1][u]=t*t*t*b+3*t*t*l*d+3*t*l*l*f+l*l*l*h;return r[0][v]=a,r[1][v]=b,r[0][v+1]=g,r[1][v+1]=h,r[0].length=r[1].length=v+2,{min:{x:P.apply(0,r[0]),y:P.apply(0,r[1])},max:{x:Q.apply(0,r[0]),y:Q.apply(0,r[1])}}}function E(a,b){var d=!b&&c(a);if(!b&&d.curve)return f(d.curve);for(var e=z(a),g=b&&z(b),h={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},i={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},j=(function(a,b,c){var d,e;if(!a)return["C",b.x,b.y,b.x,b.y,b.x,b.y];switch(!(a[0]in{T:1,Q:1})&&(b.qx=b.qy=null),a[0]){case"M":b.X=a[1],b.Y=a[2];break;case"A":a=["C"].concat(C.apply(0,[b.x,b.y].concat(a.slice(1))));break;case"S":"C"==c||"S"==c?(d=2*b.x-b.bx,e=2*b.y-b.by):(d=b.x,e=b.y),a=["C",d,e].concat(a.slice(1));break;case"T":"Q"==c||"T"==c?(b.qx=2*b.x-b.qx,b.qy=2*b.y-b.qy):(b.qx=b.x,b.qy=b.y),a=["C"].concat(B(b.x,b.y,b.qx,b.qy,a[1],a[2]));break;case"Q":b.qx=a[1],b.qy=a[2],a=["C"].concat(B(b.x,b.y,a[1],a[2],a[3],a[4]));break;case"L":a=["C"].concat(A(b.x,b.y,a[1],a[2]));break;case"H":a=["C"].concat(A(b.x,b.y,a[1],b.y));break;case"V":a=["C"].concat(A(b.x,b.y,b.x,a[1]));break;case"Z":a=["C"].concat(A(b.x,b.y,b.X,b.Y))}return a}),k=function(a,b){if(a[b].length>7){a[b].shift();for(var c=a[b];c.length;)m[b]="A",g&&(n[b]="A"),a.splice(b++,0,["C"].concat(c.splice(0,6)));a.splice(b,1),r=Q(e.length,g&&g.length||0)}},l=function(a,b,c,d,f){a&&b&&"M"==a[f][0]&&"M"!=b[f][0]&&(b.splice(f,0,["M",d.x,d.y]),c.bx=0,c.by=0,c.x=a[f][1],c.y=a[f][2],r=Q(e.length,g&&g.length||0))},m=[],n=[],o="",p="",q=0,r=Q(e.length,g&&g.length||0);r>q;q++){e[q]&&(o=e[q][0]),"C"!=o&&(m[q]=o,q&&(p=m[q-1])),e[q]=j(e[q],h,p),"A"!=m[q]&&"C"==o&&(m[q]="C"),k(e,q),g&&(g[q]&&(o=g[q][0]),"C"!=o&&(n[q]=o,q&&(p=n[q-1])),g[q]=j(g[q],i,p),"A"!=n[q]&&"C"==o&&(n[q]="C"),k(g,q)),l(e,g,h,i,q),l(g,e,i,h,q);var s=e[q],t=g&&g[q],u=s.length,v=g&&t.length;h.x=s[u-2],h.y=s[u-1],h.bx=M(s[u-4])||h.x,h.by=M(s[u-3])||h.y,i.bx=g&&(M(t[v-4])||i.x),i.by=g&&(M(t[v-3])||i.y),i.x=g&&t[v-2],i.y=g&&t[v-1]}return g||(d.curve=f(e)),g?[e,g]:e}function F(a,b){if(!b)return a;var c,d,e,f,g,h,i;for(a=E(a),e=0,g=a.length;g>e;e++)for(i=a[e],f=1,h=i.length;h>f;f+=2)c=b.x(i[f],i[f+1]),d=b.y(i[f],i[f+1]),i[f]=c,i[f+1]=d;return a}function G(a,b){for(var c=[],d=0,e=a.length;e-2*!b>d;d+=2){var f=[{x:+a[d-2],y:+a[d-1]},{x:+a[d],y:+a[d+1]},{x:+a[d+2],y:+a[d+3]},{x:+a[d+4],y:+a[d+5]}];b?d?e-4==d?f[3]={x:+a[0],y:+a[1]}:e-2==d&&(f[2]={x:+a[0],y:+a[1]},f[3]={x:+a[2],y:+a[3]}):f[0]={x:+a[e-2],y:+a[e-1]}:e-4==d?f[3]=f[2]:d||(f[0]={x:+a[d],y:+a[d+1]}),c.push(["C",(-f[0].x+6*f[1].x+f[2].x)/6,(-f[0].y+6*f[1].y+f[2].y)/6,(f[1].x+6*f[2].x-f[3].x)/6,(f[1].y+6*f[2].y-f[3].y)/6,f[2].x,f[2].y])}return c}var H=b.prototype,I=a.is,J=a._.clone,K="hasOwnProperty",L=/,?([a-z]),?/gi,M=parseFloat,N=Math,O=N.PI,P=N.min,Q=N.max,R=N.pow,S=N.abs,T=h(1),U=h(),V=h(0,1),W=a._unit2px,X={path:function(a){return a.attr("path")},circle:function(a){var b=W(a);return x(b.cx,b.cy,b.r)},ellipse:function(a){var b=W(a);return x(b.cx||0,b.cy||0,b.rx,b.ry)},rect:function(a){var b=W(a);return w(b.x||0,b.y||0,b.width,b.height,b.rx,b.ry)},image:function(a){var b=W(a);return w(b.x||0,b.y||0,b.width,b.height)},line:function(a){return"M"+[a.attr("x1")||0,a.attr("y1")||0,a.attr("x2"),a.attr("y2")]},polyline:function(a){return"M"+a.attr("points")},polygon:function(a){return"M"+a.attr("points")+"z"},deflt:function(a){var b=a.node.getBBox();return w(b.x,b.y,b.width,b.height)}};a.path=c,a.path.getTotalLength=T,a.path.getPointAtLength=U,a.path.getSubpath=function(a,b,c){if(this.getTotalLength(a)-c<1e-6)return V(a,b).end;var d=V(a,c,1);return b?V(d,b).end:d},H.getTotalLength=function(){return this.node.getTotalLength?this.node.getTotalLength():void 0},H.getPointAtLength=function(a){return U(this.attr("d"),a)},H.getSubpath=function(b,c){return a.path.getSubpath(this.attr("d"),b,c)},a._.box=d,a.path.findDotsAtSegment=i,a.path.bezierBBox=j,a.path.isPointInsideBBox=k,a.closest=function(b,c,e,f){for(var g=100,h=d(b-g/2,c-g/2,g,g),i=[],j=e[0].hasOwnProperty("x")?function(a){return{x:e[a].x,y:e[a].y}}:function(a){return{x:e[a],y:f[a]}},l=0;1e6>=g&&!l;){for(var m=0,n=e.length;n>m;m++){var o=j(m);if(k(h,o.x,o.y)){l++,i.push(o);break}}l||(g*=2,h=d(b-g/2,c-g/2,g,g))}if(1e6!=g){var p,q=1/0;for(m=0,n=i.length;n>m;m++){var r=a.len(b,c,i[m].x,i[m].y);q>r&&(q=r,i[m].len=r,p=i[m])}return p}},a.path.isBBoxIntersect=l,a.path.intersection=r,a.path.intersectionNumber=s,a.path.isPointInside=u,a.path.getBBox=v,a.path.get=X,a.path.toRelative=y,a.path.toAbsolute=z,a.path.toCubic=E,a.path.map=F,a.path.toString=e,a.path.clone=f}),d.plugin(function(a){var d=Math.max,e=Math.min,f=function(a){if(this.items=[],this.bindings={},this.length=0,this.type="set",a)for(var b=0,c=a.length;c>b;b++)a[b]&&(this[this.items.length]=this.items[this.items.length]=a[b],this.length++)},g=f.prototype;g.push=function(){for(var a,b,c=0,d=arguments.length;d>c;c++)a=arguments[c],a&&(b=this.items.length,this[b]=this.items[b]=a,this.length++);return this},g.pop=function(){return this.length&&delete this[this.length--],this.items.pop()},g.forEach=function(a,b){for(var c=0,d=this.items.length;d>c;c++)if(a.call(b,this.items[c],c)===!1)return this;return this},g.animate=function(d,e,f,g){"function"!=typeof f||f.length||(g=f,f=c.linear),d instanceof a._.Animation&&(g=d.callback,f=d.easing,e=f.dur,d=d.attr);var h=arguments;if(a.is(d,"array")&&a.is(h[h.length-1],"array"))var i=!0;var j,k=function(){j?this.b=j:j=this.b},l=0,m=this,n=g&&function(){++l==m.length&&g.call(this)
};return this.forEach(function(a,c){b.once("snap.animcreated."+a.id,k),i?h[c]&&a.animate.apply(a,h[c]):a.animate(d,e,f,n)})},g.remove=function(){for(;this.length;)this.pop().remove();return this},g.bind=function(a,b,c){var d={};if("function"==typeof b)this.bindings[a]=b;else{var e=c||a;this.bindings[a]=function(a){d[e]=a,b.attr(d)}}return this},g.attr=function(a){var b={};for(var c in a)this.bindings[c]?this.bindings[c](a[c]):b[c]=a[c];for(var d=0,e=this.items.length;e>d;d++)this.items[d].attr(b);return this},g.clear=function(){for(;this.length;)this.pop()},g.splice=function(a,b){a=0>a?d(this.length+a,0):a,b=d(0,e(this.length-a,b));var c,g=[],h=[],i=[];for(c=2;c<arguments.length;c++)i.push(arguments[c]);for(c=0;b>c;c++)h.push(this[a+c]);for(;c<this.length-a;c++)g.push(this[a+c]);var j=i.length;for(c=0;c<j+g.length;c++)this.items[a+c]=this[a+c]=j>c?i[c]:g[c-j];for(c=this.items.length=this.length-=b-j;this[c];)delete this[c++];return new f(h)},g.exclude=function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]==a)return this.splice(b,1),!0;return!1},g.insertAfter=function(a){for(var b=this.items.length;b--;)this.items[b].insertAfter(a);return this},g.getBBox=function(){for(var a=[],b=[],c=[],f=[],g=this.items.length;g--;)if(!this.items[g].removed){var h=this.items[g].getBBox();a.push(h.x),b.push(h.y),c.push(h.x+h.width),f.push(h.y+h.height)}return a=e.apply(0,a),b=e.apply(0,b),c=d.apply(0,c),f=d.apply(0,f),{x:a,y:b,x2:c,y2:f,width:c-a,height:f-b,cx:a+(c-a)/2,cy:b+(f-b)/2}},g.clone=function(a){a=new f;for(var b=0,c=this.items.length;c>b;b++)a.push(this.items[b].clone());return a},g.toString=function(){return"Snap‘s set"},g.type="set",a.Set=f,a.set=function(){var a=new f;return arguments.length&&a.push.apply(a,Array.prototype.slice.call(arguments,0)),a}}),d.plugin(function(a,c){function d(a){var b=a[0];switch(b.toLowerCase()){case"t":return[b,0,0];case"m":return[b,1,0,0,1,0,0];case"r":return 4==a.length?[b,0,a[2],a[3]]:[b,0];case"s":return 5==a.length?[b,1,1,a[3],a[4]]:3==a.length?[b,1,1]:[b,1]}}function e(b,c,e){c=p(c).replace(/\.{3}|\u2026/g,b),b=a.parseTransformString(b)||[],c=a.parseTransformString(c)||[];for(var f,g,h,i,l=Math.max(b.length,c.length),m=[],n=[],o=0;l>o;o++){if(h=b[o]||d(c[o]),i=c[o]||d(h),h[0]!=i[0]||"r"==h[0].toLowerCase()&&(h[2]!=i[2]||h[3]!=i[3])||"s"==h[0].toLowerCase()&&(h[3]!=i[3]||h[4]!=i[4])){b=a._.transform2matrix(b,e()),c=a._.transform2matrix(c,e()),m=[["m",b.a,b.b,b.c,b.d,b.e,b.f]],n=[["m",c.a,c.b,c.c,c.d,c.e,c.f]];break}for(m[o]=[],n[o]=[],f=0,g=Math.max(h.length,i.length);g>f;f++)f in h&&(m[o][f]=h[f]),f in i&&(n[o][f]=i[f])}return{from:k(m),to:k(n),f:j(m)}}function f(a){return a}function g(a){return function(b){return+b.toFixed(3)+a}}function h(a){return a.join(" ")}function i(b){return a.rgb(b[0],b[1],b[2])}function j(a){var b,c,d,e,f,g,h=0,i=[];for(b=0,c=a.length;c>b;b++){for(f="[",g=['"'+a[b][0]+'"'],d=1,e=a[b].length;e>d;d++)g[d]="val["+h++ +"]";f+=g+"]",i[b]=f}return Function("val","return Snap.path.toString.call(["+i+"])")}function k(a){for(var b=[],c=0,d=a.length;d>c;c++)for(var e=1,f=a[c].length;f>e;e++)b.push(a[c][e]);return b}function l(a){return isFinite(parseFloat(a))}function m(b,c){return a.is(b,"array")&&a.is(c,"array")?b.toString()==c.toString():!1}var n={},o=/[a-z]+$/i,p=String;n.stroke=n.fill="colour",c.prototype.equal=function(a,c){return b("snap.util.equal",this,a,c).firstDefined()},b.on("snap.util.equal",function(b,c){var d,q,r=p(this.attr(b)||""),s=this;if(l(r)&&l(c))return{from:parseFloat(r),to:parseFloat(c),f:f};if("colour"==n[b])return d=a.color(r),q=a.color(c),{from:[d.r,d.g,d.b,d.opacity],to:[q.r,q.g,q.b,q.opacity],f:i};if("viewBox"==b)return d=this.attr(b).vb.split(" ").map(Number),q=c.split(" ").map(Number),{from:d,to:q,f:h};if("transform"==b||"gradientTransform"==b||"patternTransform"==b)return c instanceof a.Matrix&&(c=c.toTransformString()),a._.rgTransform.test(c)||(c=a._.svgTransform2string(c)),e(r,c,function(){return s.getBBox(1)});if("d"==b||"path"==b)return d=a.path.toCubic(r,c),{from:k(d[0]),to:k(d[1]),f:j(d[0])};if("points"==b)return d=p(r).split(a._.separator),q=p(c).split(a._.separator),{from:d,to:q,f:function(a){return a}};var t=r.match(o),u=p(c).match(o);return t&&m(t,u)?{from:parseFloat(r),to:parseFloat(c),f:g(t)}:{from:this.asPX(b),to:this.asPX(b,c),f:f}})}),d.plugin(function(a,c,d,e){for(var f=c.prototype,g="hasOwnProperty",h=("createTouch"in e.doc),i=["click","dblclick","mousedown","mousemove","mouseout","mouseover","mouseup","touchstart","touchmove","touchend","touchcancel"],j={mousedown:"touchstart",mousemove:"touchmove",mouseup:"touchend"},k=(function(a,b){var c="y"==a?"scrollTop":"scrollLeft",d=b&&b.node?b.node.ownerDocument:e.doc;return d[c in d.documentElement?"documentElement":"body"][c]}),l=function(){return this.originalEvent.preventDefault()},m=function(){return this.originalEvent.stopPropagation()},n=function(a,b,c,d){var e=h&&j[b]?j[b]:b,f=function(e){var f=k("y",d),i=k("x",d);if(h&&j[g](b))for(var n=0,o=e.targetTouches&&e.targetTouches.length;o>n;n++)if(e.targetTouches[n].target==a||a.contains(e.targetTouches[n].target)){var p=e;e=e.targetTouches[n],e.originalEvent=p,e.preventDefault=l,e.stopPropagation=m;break}var q=e.clientX+i,r=e.clientY+f;return c.call(d,e,q,r)};return b!==e&&a.addEventListener(b,f,!1),a.addEventListener(e,f,!1),function(){return b!==e&&a.removeEventListener(b,f,!1),a.removeEventListener(e,f,!1),!0}},o=[],p=function(a){for(var c,d=a.clientX,e=a.clientY,f=k("y"),g=k("x"),i=o.length;i--;){if(c=o[i],h){for(var j,l=a.touches&&a.touches.length;l--;)if(j=a.touches[l],j.identifier==c.el._drag.id||c.el.node.contains(j.target)){d=j.clientX,e=j.clientY,(a.originalEvent?a.originalEvent:a).preventDefault();break}}else a.preventDefault();{var m=c.el.node;m.nextSibling,m.parentNode,m.style.display}d+=g,e+=f,b("snap.drag.move."+c.el.id,c.move_scope||c.el,d-c.el._drag.x,e-c.el._drag.y,d,e,a)}},q=function(c){a.unmousemove(p).unmouseup(q);for(var d,e=o.length;e--;)d=o[e],d.el._drag={},b("snap.drag.end."+d.el.id,d.end_scope||d.start_scope||d.move_scope||d.el,c),b.off("snap.drag.*."+d.el.id);o=[]},r=i.length;r--;)!function(b){a[b]=f[b]=function(c,d){if(a.is(c,"function"))this.events=this.events||[],this.events.push({name:b,f:c,unbind:n(this.node||document,b,c,d||this)});else for(var e=0,f=this.events.length;f>e;e++)if(this.events[e].name==b)try{this.events[e].f.call(this)}catch(g){}return this},a["un"+b]=f["un"+b]=function(a){for(var c=this.events||[],d=c.length;d--;)if(c[d].name==b&&(c[d].f==a||!a))return c[d].unbind(),c.splice(d,1),!c.length&&delete this.events,this;return this}}(i[r]);f.hover=function(a,b,c,d){return this.mouseover(a,c).mouseout(b,d||c)},f.unhover=function(a,b){return this.unmouseover(a).unmouseout(b)};var s=[];f.drag=function(c,d,e,f,g,h){function i(i,j,l){(i.originalEvent||i).preventDefault(),k._drag.x=j,k._drag.y=l,k._drag.id=i.identifier,!o.length&&a.mousemove(p).mouseup(q),o.push({el:k,move_scope:f,start_scope:g,end_scope:h}),d&&b.on("snap.drag.start."+k.id,d),c&&b.on("snap.drag.move."+k.id,c),e&&b.on("snap.drag.end."+k.id,e),b("snap.drag.start."+k.id,g||f||k,j,l,i)}function j(a,c,d){b("snap.draginit."+k.id,k,a,c,d)}var k=this;if(!arguments.length){var l;return k.drag(function(a,b){this.attr({transform:l+(l?"T":"t")+[a,b]})},function(){l=this.transform().local})}return b.on("snap.draginit."+k.id,i),k._drag={},s.push({el:k,start:i,init:j}),k.mousedown(j),k},f.undrag=function(){for(var c=s.length;c--;)s[c].el==this&&(this.unmousedown(s[c].init),s.splice(c,1),b.unbind("snap.drag.*."+this.id),b.unbind("snap.draginit."+this.id));return!s.length&&a.unmousemove(p).unmouseup(q),this}}),d.plugin(function(a,c,d){var e=(c.prototype,d.prototype),f=/^\s*url\((.+)\)/,g=String,h=a._.$;a.filter={},e.filter=function(b){var d=this;"svg"!=d.type&&(d=d.paper);var e=a.parse(g(b)),f=a._.id(),i=(d.node.offsetWidth,d.node.offsetHeight,h("filter"));return h(i,{id:f,filterUnits:"userSpaceOnUse"}),i.appendChild(e.node),d.defs.appendChild(i),new c(i)},b.on("snap.util.getattr.filter",function(){b.stop();var c=h(this.node,"filter");if(c){var d=g(c).match(f);return d&&a.select(d[1])}}),b.on("snap.util.attr.filter",function(d){if(d instanceof c&&"filter"==d.type){b.stop();var e=d.node.id;e||(h(d.node,{id:d.id}),e=d.id),h(this.node,{filter:a.url(e)})}d&&"none"!=d||(b.stop(),this.node.removeAttribute("filter"))}),a.filter.blur=function(b,c){null==b&&(b=2);var d=null==c?b:[b,c];return a.format('<feGaussianBlur stdDeviation="{def}"/>',{def:d})},a.filter.blur.toString=function(){return this()},a.filter.shadow=function(b,c,d,e,f){return"string"==typeof d&&(e=d,f=e,d=4),"string"!=typeof e&&(f=e,e="#000"),e=e||"#000",null==d&&(d=4),null==f&&(f=1),null==b&&(b=0,c=2),null==c&&(c=b),e=a.color(e),a.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>',{color:e,dx:b,dy:c,blur:d,opacity:f})},a.filter.shadow.toString=function(){return this()},a.filter.grayscale=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>',{a:.2126+.7874*(1-b),b:.7152-.7152*(1-b),c:.0722-.0722*(1-b),d:.2126-.2126*(1-b),e:.7152+.2848*(1-b),f:.0722-.0722*(1-b),g:.2126-.2126*(1-b),h:.0722+.9278*(1-b)})},a.filter.grayscale.toString=function(){return this()},a.filter.sepia=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>',{a:.393+.607*(1-b),b:.769-.769*(1-b),c:.189-.189*(1-b),d:.349-.349*(1-b),e:.686+.314*(1-b),f:.168-.168*(1-b),g:.272-.272*(1-b),h:.534-.534*(1-b),i:.131+.869*(1-b)})},a.filter.sepia.toString=function(){return this()},a.filter.saturate=function(b){return null==b&&(b=1),a.format('<feColorMatrix type="saturate" values="{amount}"/>',{amount:1-b})},a.filter.saturate.toString=function(){return this()},a.filter.hueRotate=function(b){return b=b||0,a.format('<feColorMatrix type="hueRotate" values="{angle}"/>',{angle:b})},a.filter.hueRotate.toString=function(){return this()},a.filter.invert=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>',{amount:b,amount2:1-b})},a.filter.invert.toString=function(){return this()},a.filter.brightness=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>',{amount:b})},a.filter.brightness.toString=function(){return this()},a.filter.contrast=function(b){return null==b&&(b=1),a.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>',{amount:b,amount2:.5-b/2})},a.filter.contrast.toString=function(){return this()}}),d.plugin(function(a,b){var c=a._.box,d=a.is,e=/^[^a-z]*([tbmlrc])/i,f=function(){return"T"+this.dx+","+this.dy};b.prototype.getAlign=function(a,b){null==b&&d(a,"string")&&(b=a,a=null),a=a||this.paper;var g=a.getBBox?a.getBBox():c(a),h=this.getBBox(),i={};switch(b=b&&b.match(e),b=b?b[1].toLowerCase():"c"){case"t":i.dx=0,i.dy=g.y-h.y;break;case"b":i.dx=0,i.dy=g.y2-h.y2;break;case"m":i.dx=0,i.dy=g.cy-h.cy;break;case"l":i.dx=g.x-h.x,i.dy=0;break;case"r":i.dx=g.x2-h.x2,i.dy=0;break;default:i.dx=g.cx-h.cx,i.dy=0}return i.toString=f,i},b.prototype.align=function(a,b){return this.transform("..."+this.getAlign(a,b))}}),d});

// above automatically copied from snap.svg-min.js
</script>
    <script>
// automatically copied from sjcl.js
/** @fileOverview Javascript cryptography implementation.
 *
 * Crush to remove comments, shorten variable names and
 * generally reduce transmission size.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

"use strict";
/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */
/*global document, window, escape, unescape, module, require, Uint32Array */

/**
 * The Stanford Javascript Crypto Library, top-level namespace.
 * @namespace
 */
var sjcl = {
  /**
   * Symmetric ciphers.
   * @namespace
   */
  cipher: {},

  /**
   * Hash functions.  Right now only SHA256 is implemented.
   * @namespace
   */
  hash: {},

  /**
   * Key exchange functions.  Right now only SRP is implemented.
   * @namespace
   */
  keyexchange: {},
  
  /**
   * Cipher modes of operation.
   * @namespace
   */
  mode: {},

  /**
   * Miscellaneous.  HMAC and PBKDF2.
   * @namespace
   */
  misc: {},
  
  /**
   * Bit array encoders and decoders.
   * @namespace
   *
   * @description
   * The members of this namespace are functions which translate between
   * SJCL's bitArrays and other objects (usually strings).  Because it
   * isn't always clear which direction is encoding and which is decoding,
   * the method names are "fromBits" and "toBits".
   */
  codec: {},
  
  /**
   * Exceptions.
   * @namespace
   */
  exception: {
    /**
     * Ciphertext is corrupt.
     * @constructor
     */
    corrupt: function(message) {
      this.toString = function() { return "CORRUPT: "+this.message; };
      this.message = message;
    },
    
    /**
     * Invalid parameter.
     * @constructor
     */
    invalid: function(message) {
      this.toString = function() { return "INVALID: "+this.message; };
      this.message = message;
    },
    
    /**
     * Bug or missing feature in SJCL.
     * @constructor
     */
    bug: function(message) {
      this.toString = function() { return "BUG: "+this.message; };
      this.message = message;
    },

    /**
     * Something isn't ready.
     * @constructor
     */
    notReady: function(message) {
      this.toString = function() { return "NOT READY: "+this.message; };
      this.message = message;
    }
  }
};
/** @fileOverview Low-level AES implementation.
 *
 * This file contains a low-level implementation of AES, optimized for
 * size and for efficiency on several browsers.  It is based on
 * OpenSSL's aes_core.c, a public-domain implementation by Vincent
 * Rijmen, Antoon Bosselaers and Paulo Barreto.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Schedule out an AES key for both encryption and decryption.  This
 * is a low-level class.  Use a cipher mode to do bulk encryption.
 *
 * @constructor
 * @param {Array} key The key as an array of 4, 6 or 8 words.
 */
sjcl.cipher.aes = function (key) {
  if (!this._tables[0][0][0]) {
    this._precompute();
  }
  
  var i, j, tmp,
    encKey, decKey,
    sbox = this._tables[0][4], decTable = this._tables[1],
    keyLen = key.length, rcon = 1;
  
  if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
    throw new sjcl.exception.invalid("invalid aes key size");
  }
  
  this._key = [encKey = key.slice(0), decKey = []];
  
  // schedule encryption keys
  for (i = keyLen; i < 4 * keyLen + 28; i++) {
    tmp = encKey[i-1];
    
    // apply sbox
    if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {
      tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];
      
      // shift rows and add rcon
      if (i%keyLen === 0) {
        tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;
        rcon = rcon<<1 ^ (rcon>>7)*283;
      }
    }
    
    encKey[i] = encKey[i-keyLen] ^ tmp;
  }
  
  // schedule decryption keys
  for (j = 0; i; j++, i--) {
    tmp = encKey[j&3 ? i : i - 4];
    if (i<=4 || j<4) {
      decKey[j] = tmp;
    } else {
      decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^
                  decTable[1][sbox[tmp>>16  & 255]] ^
                  decTable[2][sbox[tmp>>8   & 255]] ^
                  decTable[3][sbox[tmp      & 255]];
    }
  }
};

sjcl.cipher.aes.prototype = {
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt:function (data) { return this._crypt(data,0); },
  
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt:function (data) { return this._crypt(data,1); },
  
  /**
   * The expanded S-box and inverse S-box tables.  These will be computed
   * on the client so that we don't have to send them down the wire.
   *
   * There are two tables, _tables[0] is for encryption and
   * _tables[1] is for decryption.
   *
   * The first 4 sub-tables are the expanded S-box with MixColumns.  The
   * last (_tables[01][4]) is the S-box itself.
   *
   * @private
   */
  _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],

  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute: function () {
   var encTable = this._tables[0], decTable = this._tables[1],
       sbox = encTable[4], sboxInv = decTable[4],
       i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;

    // Compute double and third tables
   for (i = 0; i < 256; i++) {
     th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;
   }
   
   for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
     // Compute sbox
     s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;
     s = s>>8 ^ s&255 ^ 99;
     sbox[x] = s;
     sboxInv[s] = x;
     
     // Compute MixColumns
     x8 = d[x4 = d[x2 = d[x]]];
     tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;
     tEnc = d[s]*0x101 ^ s*0x1010100;
     
     for (i = 0; i < 4; i++) {
       encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;
       decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;
     }
   }
   
   // Compactify.  Considerable speedup on Firefox.
   for (i = 0; i < 5; i++) {
     encTable[i] = encTable[i].slice(0);
     decTable[i] = decTable[i].slice(0);
   }
  },
  
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt:function (input, dir) {
    if (input.length !== 4) {
      throw new sjcl.exception.invalid("invalid aes block size");
    }
    
    var key = this._key[dir],
        // state variables a,b,c,d are loaded with pre-whitened data
        a = input[0]           ^ key[0],
        b = input[dir ? 3 : 1] ^ key[1],
        c = input[2]           ^ key[2],
        d = input[dir ? 1 : 3] ^ key[3],
        a2, b2, c2,
        
        nInnerRounds = key.length/4 - 2,
        i,
        kIndex = 4,
        out = [0,0,0,0],
        table = this._tables[dir],
        
        // load up the tables
        t0    = table[0],
        t1    = table[1],
        t2    = table[2],
        t3    = table[3],
        sbox  = table[4];
 
    // Inner rounds.  Cribbed from OpenSSL.
    for (i = 0; i < nInnerRounds; i++) {
      a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];
      b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
      c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
      d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
      kIndex += 4;
      a=a2; b=b2; c=c2;
    }
        
    // Last round.
    for (i = 0; i < 4; i++) {
      out[dir ? 3&-i : i] =
        sbox[a>>>24      ]<<24 ^ 
        sbox[b>>16  & 255]<<16 ^
        sbox[c>>8   & 255]<<8  ^
        sbox[d      & 255]     ^
        key[kIndex++];
      a2=a; a=b; b=c; c=d; d=a2;
    }
    
    return out;
  }
};

/** @fileOverview Arrays of bits, encoded as arrays of Numbers.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Arrays of bits, encoded as arrays of Numbers.
 * @namespace
 * @description
 * <p>
 * These objects are the currency accepted by SJCL's crypto functions.
 * </p>
 *
 * <p>
 * Most of our crypto primitives operate on arrays of 4-byte words internally,
 * but many of them can take arguments that are not a multiple of 4 bytes.
 * This library encodes arrays of bits (whose size need not be a multiple of 8
 * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an
 * array of words, 32 bits at a time.  Since the words are double-precision
 * floating point numbers, they fit some extra data.  We use this (in a private,
 * possibly-changing manner) to encode the number of bits actually  present
 * in the last word of the array.
 * </p>
 *
 * <p>
 * Because bitwise ops clear this out-of-band data, these arrays can be passed
 * to ciphers like AES which want arrays of words.
 * </p>
 */
sjcl.bitArray = {
  /**
   * Array slices in units of bits.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,
   * slice until the end of the array.
   * @return {bitArray} The requested slice.
   */
  bitSlice: function (a, bstart, bend) {
    a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);
    return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);
  },

  /**
   * Extract a number packed into a bit array.
   * @param {bitArray} a The array to slice.
   * @param {Number} bstart The offset to the start of the slice, in bits.
   * @param {Number} blength The length of the number to extract.
   * @return {Number} The requested slice.
   */
  extract: function(a, bstart, blength) {
    // FIXME: this Math.floor is not necessary at all, but for some reason
    // seems to suppress a bug in the Chromium JIT.
    var x, sh = Math.floor((-bstart-blength) & 31);
    if ((bstart + blength - 1 ^ bstart) & -32) {
      // it crosses a boundary
      x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);
    } else {
      // within a single word
      x = a[bstart/32|0] >>> sh;
    }
    return x & ((1<<blength) - 1);
  },

  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat: function (a1, a2) {
    if (a1.length === 0 || a2.length === 0) {
      return a1.concat(a2);
    }
    
    var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);
    if (shift === 32) {
      return a1.concat(a2);
    } else {
      return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));
    }
  },

  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength: function (a) {
    var l = a.length, x;
    if (l === 0) { return 0; }
    x = a[l - 1];
    return (l-1) * 32 + sjcl.bitArray.getPartial(x);
  },

  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp: function (a, len) {
    if (a.length * 32 < len) { return a; }
    a = a.slice(0, Math.ceil(len / 32));
    var l = a.length;
    len = len & 31;
    if (l > 0 && len) {
      a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);
    }
    return a;
  },

  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial: function (len, x, _end) {
    if (len === 32) { return x; }
    return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;
  },

  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial: function (x) {
    return Math.round(x/0x10000000000) || 32;
  },

  /**
   * Compare two arrays for equality in a predictable amount of time.
   * @param {bitArray} a The first array.
   * @param {bitArray} b The second array.
   * @return {boolean} true if a == b; false otherwise.
   */
  equal: function (a, b) {
    if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {
      return false;
    }
    var x = 0, i;
    for (i=0; i<a.length; i++) {
      x |= a[i]^b[i];
    }
    return (x === 0);
  },

  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight: function (a, shift, carry, out) {
    var i, last2=0, shift2;
    if (out === undefined) { out = []; }
    
    for (; shift >= 32; shift -= 32) {
      out.push(carry);
      carry = 0;
    }
    if (shift === 0) {
      return out.concat(a);
    }
    
    for (i=0; i<a.length; i++) {
      out.push(carry | a[i]>>>shift);
      carry = a[i] << (32-shift);
    }
    last2 = a.length ? a[a.length-1] : 0;
    shift2 = sjcl.bitArray.getPartial(last2);
    out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));
    return out;
  },
  
  /** xor a block of 4 words together.
   * @private
   */
  _xor4: function(x,y) {
    return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];
  },

  /** byteswap a word array inplace.
   * (does not handle partial words)
   * @param {sjcl.bitArray} a word array
   * @return {sjcl.bitArray} byteswapped array
   */
  byteswapM: function(a) {
    var i, v, m = 0xff00;
    for (i = 0; i < a.length; ++i) {
      v = a[i];
      a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);
    }
    return a;
  }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
 
/**
 * UTF-8 strings
 * @namespace
 */
sjcl.codec.utf8String = {
  /** Convert from a bitArray to a UTF-8 string. */
  fromBits: function (arr) {
    var out = "", bl = sjcl.bitArray.bitLength(arr), i, tmp;
    for (i=0; i<bl/8; i++) {
      if ((i&3) === 0) {
        tmp = arr[i/4];
      }
      out += String.fromCharCode(tmp >>> 24);
      tmp <<= 8;
    }
    return decodeURIComponent(escape(out));
  },
  
  /** Convert from a UTF-8 string to a bitArray. */
  toBits: function (str) {
    str = unescape(encodeURIComponent(str));
    var out = [], i, tmp=0;
    for (i=0; i<str.length; i++) {
      tmp = tmp << 8 | str.charCodeAt(i);
      if ((i&3) === 3) {
        out.push(tmp);
        tmp = 0;
      }
    }
    if (i&3) {
      out.push(sjcl.bitArray.partial(8*(i&3), tmp));
    }
    return out;
  }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Hexadecimal
 * @namespace
 */
sjcl.codec.hex = {
  /** Convert from a bitArray to a hex string. */
  fromBits: function (arr) {
    var out = "", i;
    for (i=0; i<arr.length; i++) {
      out += ((arr[i]|0)+0xF00000000000).toString(16).substr(4);
    }
    return out.substr(0, sjcl.bitArray.bitLength(arr)/4);//.replace(/(.{8})/g, "$1 ");
  },
  /** Convert from a hex string to a bitArray. */
  toBits: function (str) {
    var i, out=[], len;
    str = str.replace(/\s|0x/g, "");
    len = str.length;
    str = str + "00000000";
    for (i=0; i<str.length; i+=8) {
      out.push(parseInt(str.substr(i,8),16)^0);
    }
    return sjcl.bitArray.clamp(out, len*4);
  }
};

/** @fileOverview Bit array codec implementations.
 *
 * @author Nils Kenneweg
 */

/**
 * Base32 encoding/decoding
 * @namespace
 */
sjcl.codec.base32 = {
  /** The base32 alphabet.
   * @private
   */
  _chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  _hexChars: "0123456789ABCDEFGHIJKLMNOPQRSTUV",

  /* bits in an array */
  BITS: 32,
  /* base to encode at (2^x) */
  BASE: 5,
  /* bits - base */
  REMAINING: 27,

  /** Convert from a bitArray to a base32 string. */
  fromBits: function (arr, _noEquals, _hex) {
    var BITS = sjcl.codec.base32.BITS, BASE = sjcl.codec.base32.BASE, REMAINING = sjcl.codec.base32.REMAINING;
    var out = "", i, bits=0, c = sjcl.codec.base32._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);

    if (_hex) {
      c = sjcl.codec.base32._hexChars;
    }

    for (i=0; out.length * BASE < bl; ) {
      out += c.charAt((ta ^ arr[i]>>>bits) >>> REMAINING);
      if (bits < BASE) {
        ta = arr[i] << (BASE-bits);
        bits += REMAINING;
        i++;
      } else {
        ta <<= BASE;
        bits -= BASE;
      }
    }
    while ((out.length & 7) && !_noEquals) { out += "="; }

    return out;
  },

  /** Convert from a base32 string to a bitArray */
  toBits: function(str, _hex) {
    str = str.replace(/\s|=/g,'').toUpperCase();
    var BITS = sjcl.codec.base32.BITS, BASE = sjcl.codec.base32.BASE, REMAINING = sjcl.codec.base32.REMAINING;
    var out = [], i, bits=0, c = sjcl.codec.base32._chars, ta=0, x, format="base32";

    if (_hex) {
      c = sjcl.codec.base32._hexChars;
      format = "base32hex";
    }

    for (i=0; i<str.length; i++) {
      x = c.indexOf(str.charAt(i));
      if (x < 0) {
        // Invalid character, try hex format
        if (!_hex) {
          try {
            return sjcl.codec.base32hex.toBits(str);
          }
          catch (e) {}
        }
        throw new sjcl.exception.invalid("this isn't " + format + "!");
      }
      if (bits > REMAINING) {
        bits -= REMAINING;
        out.push(ta ^ x>>>bits);
        ta  = x << (BITS-bits);
      } else {
        bits += BASE;
        ta ^= x << (BITS-bits);
      }
    }
    if (bits&56) {
      out.push(sjcl.bitArray.partial(bits&56, ta, 1));
    }
    return out;
  }
};

sjcl.codec.base32hex = {
  fromBits: function (arr, _noEquals) { return sjcl.codec.base32.fromBits(arr,_noEquals,1); },
  toBits: function (str) { return sjcl.codec.base32.toBits(str,1); }
};
/** @fileOverview Bit array codec implementations.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Base64 encoding/decoding 
 * @namespace
 */
sjcl.codec.base64 = {
  /** The base64 alphabet.
   * @private
   */
  _chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  
  /** Convert from a bitArray to a base64 string. */
  fromBits: function (arr, _noEquals, _url) {
    var out = "", i, bits=0, c = sjcl.codec.base64._chars, ta=0, bl = sjcl.bitArray.bitLength(arr);
    if (_url) {
      c = c.substr(0,62) + '-_';
    }
    for (i=0; out.length * 6 < bl; ) {
      out += c.charAt((ta ^ arr[i]>>>bits) >>> 26);
      if (bits < 6) {
        ta = arr[i] << (6-bits);
        bits += 26;
        i++;
      } else {
        ta <<= 6;
        bits -= 6;
      }
    }
    while ((out.length & 3) && !_noEquals) { out += "="; }
    return out;
  },
  
  /** Convert from a base64 string to a bitArray */
  toBits: function(str, _url) {
    str = str.replace(/\s|=/g,'');
    var out = [], i, bits=0, c = sjcl.codec.base64._chars, ta=0, x;
    if (_url) {
      c = c.substr(0,62) + '-_';
    }
    for (i=0; i<str.length; i++) {
      x = c.indexOf(str.charAt(i));
      if (x < 0) {
        throw new sjcl.exception.invalid("this isn't base64!");
      }
      if (bits > 26) {
        bits -= 26;
        out.push(ta ^ x>>>bits);
        ta  = x << (32-bits);
      } else {
        bits += 6;
        ta ^= x << (32-bits);
      }
    }
    if (bits&56) {
      out.push(sjcl.bitArray.partial(bits&56, ta, 1));
    }
    return out;
  }
};

sjcl.codec.base64url = {
  fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr,1,1); },
  toBits: function (str) { return sjcl.codec.base64.toBits(str,1); }
};
/** @fileOverview Javascript SHA-256 implementation.
 *
 * An older version of this implementation is available in the public
 * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,
 * Stanford University 2008-2010 and BSD-licensed for liability
 * reasons.
 *
 * Special thanks to Aldo Cortesi for pointing out several bugs in
 * this code.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * Context for a SHA-256 operation in progress.
 * @constructor
 */
sjcl.hash.sha256 = function (hash) {
  if (!this._key[0]) { this._precompute(); }
  if (hash) {
    this._h = hash._h.slice(0);
    this._buffer = hash._buffer.slice(0);
    this._length = hash._length;
  } else {
    this.reset();
  }
};

/**
 * Hash a string or an array of words.
 * @static
 * @param {bitArray|String} data the data to hash.
 * @return {bitArray} The hash value, an array of 16 big-endian words.
 */
sjcl.hash.sha256.hash = function (data) {
  return (new sjcl.hash.sha256()).update(data).finalize();
};

sjcl.hash.sha256.prototype = {
  /**
   * The hash's block size, in bits.
   * @constant
   */
  blockSize: 512,
   
  /**
   * Reset the hash state.
   * @return this
   */
  reset:function () {
    this._h = this._init.slice(0);
    this._buffer = [];
    this._length = 0;
    return this;
  },
  
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update: function (data) {
    if (typeof data === "string") {
      data = sjcl.codec.utf8String.toBits(data);
    }
    var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
        ol = this._length,
        nl = this._length = ol + sjcl.bitArray.bitLength(data);
    if (nl > 9007199254740991){
      throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");
    }

    if (typeof Uint32Array !== 'undefined') {
	var c = new Uint32Array(b);
    	var j = 0;
    	for (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {
      	    this._block(c.subarray(16 * j, 16 * (j+1)));
      	    j += 1;
    	}
    	b.splice(0, 16 * j);
    } else {
	for (i = 512+ol - ((512+ol) & 511); i <= nl; i+= 512) {
      	    this._block(b.splice(0,16));
      	}
    }
    return this;
  },
  
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 8 big-endian words.
   */
  finalize:function () {
    var i, b = this._buffer, h = this._h;

    // Round out and push the buffer
    b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);
    
    // Round out the buffer to a multiple of 16 words, less the 2 length words.
    for (i = b.length + 2; i & 15; i++) {
      b.push(0);
    }
    
    // append the length
    b.push(Math.floor(this._length / 0x100000000));
    b.push(this._length | 0);

    while (b.length) {
      this._block(b.splice(0,16));
    }

    this.reset();
    return h;
  },

  /**
   * The SHA-256 initialization vector, to be precomputed.
   * @private
   */
  _init:[],
  /*
  _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],
  */
  
  /**
   * The SHA-256 hash key, to be precomputed.
   * @private
   */
  _key:[],
  /*
  _key:
    [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
     0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
     0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
     0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
     0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
     0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
     0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],
  */


  /**
   * Function to precompute _init and _key.
   * @private
   */
  _precompute: function () {
    var i = 0, prime = 2, factor, isPrime;

    function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }

    for (; i<64; prime++) {
      isPrime = true;
      for (factor=2; factor*factor <= prime; factor++) {
        if (prime % factor === 0) {
          isPrime = false;
          break;
        }
      }
      if (isPrime) {
        if (i<8) {
          this._init[i] = frac(Math.pow(prime, 1/2));
        }
        this._key[i] = frac(Math.pow(prime, 1/3));
        i++;
      }
    }
  },
  
  /**
   * Perform one cycle of SHA-256.
   * @param {Uint32Array|bitArray} w one block of words.
   * @private
   */
  _block:function (w) {  
    var i, tmp, a, b,
      h = this._h,
      k = this._key,
      h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],
      h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];

    /* Rationale for placement of |0 :
     * If a value can overflow is original 32 bits by a factor of more than a few
     * million (2^23 ish), there is a possibility that it might overflow the
     * 53-bit mantissa and lose precision.
     *
     * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
     * propagates around the loop, and on the hash state h[].  I don't believe
     * that the clamps on h4 and on h0 are strictly necessary, but it's close
     * (for h4 anyway), and better safe than sorry.
     *
     * The clamps on h[] are necessary for the output to be correct even in the
     * common case and for short inputs.
     */
    for (i=0; i<64; i++) {
      // load up the input word for this round
      if (i<16) {
        tmp = w[i];
      } else {
        a   = w[(i+1 ) & 15];
        b   = w[(i+14) & 15];
        tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) + 
                         (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +
                         w[i&15] + w[(i+9) & 15]) | 0;
      }
      
      tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;
      
      // shift register
      h7 = h6; h6 = h5; h5 = h4;
      h4 = h3 + tmp | 0;
      h3 = h2; h2 = h1; h1 = h0;

      h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;
    }

    h[0] = h[0]+h0 | 0;
    h[1] = h[1]+h1 | 0;
    h[2] = h[2]+h2 | 0;
    h[3] = h[3]+h3 | 0;
    h[4] = h[4]+h4 | 0;
    h[5] = h[5]+h5 | 0;
    h[6] = h[6]+h6 | 0;
    h[7] = h[7]+h7 | 0;
  }
};


/** @fileOverview CCM mode implementation.
 *
 * Special thanks to Roy Nicholson for pointing out a bug in our
 * implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/**
 * CTR mode with CBC MAC.
 * @namespace
 */
sjcl.mode.ccm = {
  /** The name of the mode.
   * @constant
   */
  name: "ccm",
  
  _progressListeners: [],

  listenProgress: function (cb) {
    sjcl.mode.ccm._progressListeners.push(cb);
  },

  unListenProgress: function (cb) {
    var index = sjcl.mode.ccm._progressListeners.indexOf(cb);
    if (index > -1) {
      sjcl.mode.ccm._progressListeners.splice(index, 1);
    }
  },

  _callProgressListener: function (val) {
    var p = sjcl.mode.ccm._progressListeners.slice(), i;

    for (i = 0; i < p.length; i += 1) {
      p[i](val);
    }
  },

  /** Encrypt in CCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=64] the desired tag length, in bits.
   * @return {bitArray} The encrypted data, an array of bytes.
   */
  encrypt: function(prf, plaintext, iv, adata, tlen) {
    var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;
    tlen = tlen || 64;
    adata = adata || [];
    
    if (ivl < 7) {
      throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
    }
    
    // compute the length of the length
    for (L=2; L<4 && ol >>> 8*L; L++) {}
    if (L < 15 - ivl) { L = 15-ivl; }
    iv = w.clamp(iv,8*(15-L));
    
    // compute the tag
    tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);
    
    // encrypt
    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);
    
    return w.concat(out.data, out.tag);
  },
  
  /** Decrypt in CCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} ciphertext The ciphertext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] adata The authenticated data.
   * @param {Number} [tlen=64] tlen the desired tag length, in bits.
   * @return {bitArray} The decrypted data.
   */
  decrypt: function(prf, ciphertext, iv, adata, tlen) {
    tlen = tlen || 64;
    adata = adata || [];
    var L,
        w=sjcl.bitArray,
        ivl = w.bitLength(iv) / 8,
        ol = w.bitLength(ciphertext), 
        out = w.clamp(ciphertext, ol - tlen),
        tag = w.bitSlice(ciphertext, ol - tlen), tag2;
    

    ol = (ol - tlen) / 8;
        
    if (ivl < 7) {
      throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
    }
    
    // compute the length of the length
    for (L=2; L<4 && ol >>> 8*L; L++) {}
    if (L < 15 - ivl) { L = 15-ivl; }
    iv = w.clamp(iv,8*(15-L));
    
    // decrypt
    out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);
    
    // check the tag
    tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);
    if (!w.equal(out.tag, tag2)) {
      throw new sjcl.exception.corrupt("ccm: tag doesn't match");
    }
    
    return out.data;
  },

  _macAdditionalData: function (prf, adata, iv, tlen, ol, L) {
    var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;

    // mac the flags
    mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];

    // mac the iv and length
    mac = w.concat(mac, iv);
    mac[3] |= ol;
    mac = prf.encrypt(mac);
  
    if (adata.length) {
      // mac the associated data.  start with its length...
      tmp = w.bitLength(adata)/8;
      if (tmp <= 0xFEFF) {
        macData = [w.partial(16, tmp)];
      } else if (tmp <= 0xFFFFFFFF) {
        macData = w.concat([w.partial(16,0xFFFE)], [tmp]);
      } // else ...
    
      // mac the data itself
      macData = w.concat(macData, adata);
      for (i=0; i<macData.length; i += 4) {
        mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));
      }
    }

    return mac;
  },

  /* Compute the (unencrypted) authentication tag, according to the CCM specification
   * @param {Object} prf The pseudorandom function.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} adata The authenticated data.
   * @param {Number} tlen the desired tag length, in bits.
   * @return {bitArray} The tag, but not yet encrypted.
   * @private
   */
  _computeTag: function(prf, plaintext, iv, adata, tlen, L) {
    // compute B[0]
    var mac, i, w=sjcl.bitArray, xor = w._xor4;

    tlen /= 8;
  
    // check tag length and message length
    if (tlen % 2 || tlen < 4 || tlen > 16) {
      throw new sjcl.exception.invalid("ccm: invalid tag length");
    }
  
    if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {
      // I don't want to deal with extracting high words from doubles.
      throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
    }

    mac = sjcl.mode.ccm._macAdditionalData(prf, adata, iv, tlen, w.bitLength(plaintext)/8, L);

    // mac the plaintext
    for (i=0; i<plaintext.length; i+=4) {
      mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));
    }

    return w.clamp(mac, tlen * 8);
  },

  /** CCM CTR mode.
   * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.
   * May mutate its arguments.
   * @param {Object} prf The PRF.
   * @param {bitArray} data The data to be encrypted or decrypted.
   * @param {bitArray} iv The initialization vector.
   * @param {bitArray} tag The authentication tag.
   * @param {Number} tlen The length of th etag, in bits.
   * @param {Number} L The CCM L value.
   * @return {Object} An object with data and tag, the en/decryption of data and tag values.
   * @private
   */
  _ctrMode: function(prf, data, iv, tag, tlen, L) {
    var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data), n = l/50, p = n;

    // start the ctr
    ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);
    
    // en/decrypt the tag
    tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);
  
    // en/decrypt the data
    if (!l) { return {tag:tag, data:[]}; }
    
    for (i=0; i<l; i+=4) {
      if (i > n) {
        sjcl.mode.ccm._callProgressListener(i/l);
        n += p;
      }
      ctr[3]++;
      enc = prf.encrypt(ctr);
      data[i]   ^= enc[0];
      data[i+1] ^= enc[1];
      data[i+2] ^= enc[2];
      data[i+3] ^= enc[3];
    }
    return { tag:tag, data:w.clamp(data,bl) };
  }
};
/** @fileOverview OCB 2.0 implementation
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** 
 * Phil Rogaway's Offset CodeBook mode, version 2.0.
 * May be covered by US and international patents.
 *
 * @namespace
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */
sjcl.mode.ocb2 = {
  /** The name of the mode.
   * @constant
   */
  name: "ocb2",
  
  /** Encrypt in OCB mode, version 2.0.
   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=64] the desired tag length, in bits.
   * @param {boolean} [premac=false] true if the authentication data is pre-macced with PMAC.
   * @return The encrypted data, an array of bytes.
   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.
   */
  encrypt: function(prp, plaintext, iv, adata, tlen, premac) {
    if (sjcl.bitArray.bitLength(iv) !== 128) {
      throw new sjcl.exception.invalid("ocb iv must be 128 bits");
    }
    var i,
        times2 = sjcl.mode.ocb2._times2,
        w = sjcl.bitArray,
        xor = w._xor4,
        checksum = [0,0,0,0],
        delta = times2(prp.encrypt(iv)),
        bi, bl,
        output = [],
        pad;
        
    adata = adata || [];
    tlen  = tlen || 64;
  
    for (i=0; i+4 < plaintext.length; i+=4) {
      /* Encrypt a non-final block */
      bi = plaintext.slice(i,i+4);
      checksum = xor(checksum, bi);
      output = output.concat(xor(delta,prp.encrypt(xor(delta, bi))));
      delta = times2(delta);
    }
    
    /* Chop out the final block */
    bi = plaintext.slice(i);
    bl = w.bitLength(bi);
    pad = prp.encrypt(xor(delta,[0,0,0,bl]));
    bi = w.clamp(xor(bi.concat([0,0,0]),pad), bl);
    
    /* Checksum the final block, and finalize the checksum */
    checksum = xor(checksum,xor(bi.concat([0,0,0]),pad));
    checksum = prp.encrypt(xor(checksum,xor(delta,times2(delta))));
    
    /* MAC the header */
    if (adata.length) {
      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));
    }
    
    return output.concat(w.concat(bi, w.clamp(checksum, tlen)));
  },
  
  /** Decrypt in OCB mode.
   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.
   * @param {bitArray} ciphertext The ciphertext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=64] the desired tag length, in bits.
   * @param {boolean} [premac=false] true if the authentication data is pre-macced with PMAC.
   * @return The decrypted data, an array of bytes.
   * @throws {sjcl.exception.invalid} if the IV isn't exactly 128 bits.
   * @throws {sjcl.exception.corrupt} if if the message is corrupt.
   */
  decrypt: function(prp, ciphertext, iv, adata, tlen, premac) {
    if (sjcl.bitArray.bitLength(iv) !== 128) {
      throw new sjcl.exception.invalid("ocb iv must be 128 bits");
    }
    tlen  = tlen || 64;
    var i,
        times2 = sjcl.mode.ocb2._times2,
        w = sjcl.bitArray,
        xor = w._xor4,
        checksum = [0,0,0,0],
        delta = times2(prp.encrypt(iv)),
        bi, bl,
        len = sjcl.bitArray.bitLength(ciphertext) - tlen,
        output = [],
        pad;
        
    adata = adata || [];
  
    for (i=0; i+4 < len/32; i+=4) {
      /* Decrypt a non-final block */
      bi = xor(delta, prp.decrypt(xor(delta, ciphertext.slice(i,i+4))));
      checksum = xor(checksum, bi);
      output = output.concat(bi);
      delta = times2(delta);
    }
    
    /* Chop out and decrypt the final block */
    bl = len-i*32;
    pad = prp.encrypt(xor(delta,[0,0,0,bl]));
    bi = xor(pad, w.clamp(ciphertext.slice(i),bl).concat([0,0,0]));
    
    /* Checksum the final block, and finalize the checksum */
    checksum = xor(checksum, bi);
    checksum = prp.encrypt(xor(checksum, xor(delta, times2(delta))));
    
    /* MAC the header */
    if (adata.length) {
      checksum = xor(checksum, premac ? adata : sjcl.mode.ocb2.pmac(prp, adata));
    }
    
    if (!w.equal(w.clamp(checksum, tlen), w.bitSlice(ciphertext, len))) {
      throw new sjcl.exception.corrupt("ocb: tag doesn't match");
    }
    
    return output.concat(w.clamp(bi,bl));
  },
  
  /** PMAC authentication for OCB associated data.
   * @param {Object} prp The block cipher.  It must have a block size of 16 bytes.
   * @param {bitArray} adata The authenticated data.
   */
  pmac: function(prp, adata) {
    var i,
        times2 = sjcl.mode.ocb2._times2,
        w = sjcl.bitArray,
        xor = w._xor4,
        checksum = [0,0,0,0],
        delta = prp.encrypt([0,0,0,0]),
        bi;
        
    delta = xor(delta,times2(times2(delta)));
 
    for (i=0; i+4<adata.length; i+=4) {
      delta = times2(delta);
      checksum = xor(checksum, prp.encrypt(xor(delta, adata.slice(i,i+4))));
    }
    
    bi = adata.slice(i);
    if (w.bitLength(bi) < 128) {
      delta = xor(delta,times2(delta));
      bi = w.concat(bi,[0x80000000|0,0,0,0]);
    }
    checksum = xor(checksum, bi);
    return prp.encrypt(xor(times2(xor(delta,times2(delta))), checksum));
  },
  
  /** Double a block of words, OCB style.
   * @private
   */
  _times2: function(x) {
    return [x[0]<<1 ^ x[1]>>>31,
            x[1]<<1 ^ x[2]>>>31,
            x[2]<<1 ^ x[3]>>>31,
            x[3]<<1 ^ (x[0]>>>31)*0x87];
  }
};
/** @fileOverview GCM mode implementation.
 *
 * @author Juho Vähä-Herttua
 */

/**
 * Galois/Counter mode.
 * @namespace
 */ 
sjcl.mode.gcm = {
  /**
   * The name of the mode.
   * @constant
   */
  name: "gcm",
  
  /** Encrypt in GCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} plaintext The plaintext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=128] The desired tag length, in bits.
   * @return {bitArray} The encrypted data, an array of bytes.
   */
  encrypt: function (prf, plaintext, iv, adata, tlen) {
    var out, data = plaintext.slice(0), w=sjcl.bitArray;
    tlen = tlen || 128;
    adata = adata || [];

    // encrypt and tag
    out = sjcl.mode.gcm._ctrMode(true, prf, data, adata, iv, tlen);

    return w.concat(out.data, out.tag);
  },
  
  /** Decrypt in GCM mode.
   * @static
   * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
   * @param {bitArray} ciphertext The ciphertext data.
   * @param {bitArray} iv The initialization value.
   * @param {bitArray} [adata=[]] The authenticated data.
   * @param {Number} [tlen=128] The desired tag length, in bits.
   * @return {bitArray} The decrypted data.
   */
  decrypt: function (prf, ciphertext, iv, adata, tlen) {
    var out, data = ciphertext.slice(0), tag, w=sjcl.bitArray, l=w.bitLength(data);
    tlen = tlen || 128;
    adata = adata || [];

    // Slice tag out of data
    if (tlen <= l) {
      tag = w.bitSlice(data, l-tlen);
      data = w.bitSlice(data, 0, l-tlen);
    } else {
      tag = data;
      data = [];
    }

    // decrypt and tag
    out = sjcl.mode.gcm._ctrMode(false, prf, data, adata, iv, tlen);

    if (!w.equal(out.tag, tag)) {
      throw new sjcl.exception.corrupt("gcm: tag doesn't match");
    }
    return out.data;
  },

  /* Compute the galois multiplication of X and Y
   * @private
   */
  _galoisMultiply: function (x, y) {
    var i, j, xi, Zi, Vi, lsb_Vi, w=sjcl.bitArray, xor=w._xor4;

    Zi = [0,0,0,0];
    Vi = y.slice(0);

    // Block size is 128 bits, run 128 times to get Z_128
    for (i=0; i<128; i++) {
      xi = (x[Math.floor(i/32)] & (1 << (31-i%32))) !== 0;
      if (xi) {
        // Z_i+1 = Z_i ^ V_i
        Zi = xor(Zi, Vi);
      }

      // Store the value of LSB(V_i)
      lsb_Vi = (Vi[3] & 1) !== 0;

      // V_i+1 = V_i >> 1
      for (j=3; j>0; j--) {
        Vi[j] = (Vi[j] >>> 1) | ((Vi[j-1]&1) << 31);
      }
      Vi[0] = Vi[0] >>> 1;

      // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
      if (lsb_Vi) {
        Vi[0] = Vi[0] ^ (0xe1 << 24);
      }
    }
    return Zi;
  },

  _ghash: function(H, Y0, data) {
    var Yi, i, l = data.length;

    Yi = Y0.slice(0);
    for (i=0; i<l; i+=4) {
      Yi[0] ^= 0xffffffff&data[i];
      Yi[1] ^= 0xffffffff&data[i+1];
      Yi[2] ^= 0xffffffff&data[i+2];
      Yi[3] ^= 0xffffffff&data[i+3];
      Yi = sjcl.mode.gcm._galoisMultiply(Yi, H);
    }
    return Yi;
  },

  /** GCM CTR mode.
   * Encrypt or decrypt data and tag with the prf in GCM-style CTR mode.
   * @param {Boolean} encrypt True if encrypt, false if decrypt.
   * @param {Object} prf The PRF.
   * @param {bitArray} data The data to be encrypted or decrypted.
   * @param {bitArray} iv The initialization vector.
   * @param {bitArray} adata The associated data to be tagged.
   * @param {Number} tlen The length of the tag, in bits.
   */
  _ctrMode: function(encrypt, prf, data, adata, iv, tlen) {
    var H, J0, S0, enc, i, ctr, tag, last, l, bl, abl, ivbl, w=sjcl.bitArray;

    // Calculate data lengths
    l = data.length;
    bl = w.bitLength(data);
    abl = w.bitLength(adata);
    ivbl = w.bitLength(iv);

    // Calculate the parameters
    H = prf.encrypt([0,0,0,0]);
    if (ivbl === 96) {
      J0 = iv.slice(0);
      J0 = w.concat(J0, [1]);
    } else {
      J0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], iv);
      J0 = sjcl.mode.gcm._ghash(H, J0, [0,0,Math.floor(ivbl/0x100000000),ivbl&0xffffffff]);
    }
    S0 = sjcl.mode.gcm._ghash(H, [0,0,0,0], adata);

    // Initialize ctr and tag
    ctr = J0.slice(0);
    tag = S0.slice(0);

    // If decrypting, calculate hash
    if (!encrypt) {
      tag = sjcl.mode.gcm._ghash(H, S0, data);
    }

    // Encrypt all the data
    for (i=0; i<l; i+=4) {
       ctr[3]++;
       enc = prf.encrypt(ctr);
       data[i]   ^= enc[0];
       data[i+1] ^= enc[1];
       data[i+2] ^= enc[2];
       data[i+3] ^= enc[3];
    }
    data = w.clamp(data, bl);

    // If encrypting, calculate hash
    if (encrypt) {
      tag = sjcl.mode.gcm._ghash(H, S0, data);
    }

    // Calculate last block from bit lengths, ugly because bitwise operations are 32-bit
    last = [
      Math.floor(abl/0x100000000), abl&0xffffffff,
      Math.floor(bl/0x100000000), bl&0xffffffff
    ];

    // Calculate the final tag block
    tag = sjcl.mode.gcm._ghash(H, tag, last);
    enc = prf.encrypt(J0);
    tag[0] ^= enc[0];
    tag[1] ^= enc[1];
    tag[2] ^= enc[2];
    tag[3] ^= enc[3];

    return { tag:w.bitSlice(tag, 0, tlen), data:data };
  }
};
/** @fileOverview HMAC implementation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** HMAC with the specified hash function.
 * @constructor
 * @param {bitArray} key the key for HMAC.
 * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.
 */
sjcl.misc.hmac = function (key, Hash) {
  this._hash = Hash = Hash || sjcl.hash.sha256;
  var exKey = [[],[]], i,
      bs = Hash.prototype.blockSize / 32;
  this._baseHash = [new Hash(), new Hash()];

  if (key.length > bs) {
    key = Hash.hash(key);
  }
  
  for (i=0; i<bs; i++) {
    exKey[0][i] = key[i]^0x36363636;
    exKey[1][i] = key[i]^0x5C5C5C5C;
  }
  
  this._baseHash[0].update(exKey[0]);
  this._baseHash[1].update(exKey[1]);
  this._resultHash = new Hash(this._baseHash[0]);
};

/** HMAC with the specified hash function.  Also called encrypt since it's a prf.
 * @param {bitArray|String} data The data to mac.
 */
sjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {
  if (!this._updated) {
    this.update(data);
    return this.digest(data);
  } else {
    throw new sjcl.exception.invalid("encrypt on already updated hmac called!");
  }
};

sjcl.misc.hmac.prototype.reset = function () {
  this._resultHash = new this._hash(this._baseHash[0]);
  this._updated = false;
};

sjcl.misc.hmac.prototype.update = function (data) {
  this._updated = true;
  this._resultHash.update(data);
};

sjcl.misc.hmac.prototype.digest = function () {
  var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();

  this.reset();

  return result;
};
/** @fileOverview Password-based key-derivation function, version 2.0.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

/** Password-Based Key-Derivation Function, version 2.0.
 *
 * Generate keys from passwords using PBKDF2-HMAC-SHA256.
 *
 * This is the method specified by RSA's PKCS #5 standard.
 *
 * @param {bitArray|String} password  The password.
 * @param {bitArray|String} salt The salt.  Should have lots of entropy.
 * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.
 * @param {Number} [length] The length of the derived key.  Defaults to the
                            output size of the hash function.
 * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.
 * @return {bitArray} the derived key.
 */
sjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {
  count = count || 10000;
  
  if (length < 0 || count < 0) {
    throw new sjcl.exception.invalid("invalid params to pbkdf2");
  }
  
  if (typeof password === "string") {
    password = sjcl.codec.utf8String.toBits(password);
  }
  
  if (typeof salt === "string") {
    salt = sjcl.codec.utf8String.toBits(salt);
  }
  
  Prff = Prff || sjcl.misc.hmac;
  
  var prf = new Prff(password),
      u, ui, i, j, k, out = [], b = sjcl.bitArray;

  for (k = 1; 32 * out.length < (length || 1); k++) {
    u = ui = prf.encrypt(b.concat(salt,[k]));
    
    for (i=1; i<count; i++) {
      ui = prf.encrypt(ui);
      for (j=0; j<ui.length; j++) {
        u[j] ^= ui[j];
      }
    }
    
    out = out.concat(u);
  }

  if (length) { out = b.clamp(out, length); }

  return out;
};
/** @fileOverview Random number generator.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 * @author Michael Brooks
 * @author Steve Thomas
 */

/** 
 * @class Random number generator
 * @description
 * <b>Use sjcl.random as a singleton for this class!</b>
 * <p>
 * This random number generator is a derivative of Ferguson and Schneier's
 * generator Fortuna.  It collects entropy from various events into several
 * pools, implemented by streaming SHA-256 instances.  It differs from
 * ordinary Fortuna in a few ways, though.
 * </p>
 *
 * <p>
 * Most importantly, it has an entropy estimator.  This is present because
 * there is a strong conflict here between making the generator available
 * as soon as possible, and making sure that it doesn't "run on empty".
 * In Fortuna, there is a saved state file, and the system is likely to have
 * time to warm up.
 * </p>
 *
 * <p>
 * Second, because users are unlikely to stay on the page for very long,
 * and to speed startup time, the number of pools increases logarithmically:
 * a new pool is created when the previous one is actually used for a reseed.
 * This gives the same asymptotic guarantees as Fortuna, but gives more
 * entropy to early reseeds.
 * </p>
 *
 * <p>
 * The entire mechanism here feels pretty klunky.  Furthermore, there are
 * several improvements that should be made, including support for
 * dedicated cryptographic functions that may be present in some browsers;
 * state files in local storage; cookies containing randomness; etc.  So
 * look for improvements in future versions.
 * </p>
 * @constructor
 */
sjcl.prng = function(defaultParanoia) {
  
  /* private */
  this._pools                   = [new sjcl.hash.sha256()];
  this._poolEntropy             = [0];
  this._reseedCount             = 0;
  this._robins                  = {};
  this._eventId                 = 0;
  
  this._collectorIds            = {};
  this._collectorIdNext         = 0;
  
  this._strength                = 0;
  this._poolStrength            = 0;
  this._nextReseed              = 0;
  this._key                     = [0,0,0,0,0,0,0,0];
  this._counter                 = [0,0,0,0];
  this._cipher                  = undefined;
  this._defaultParanoia         = defaultParanoia;
  
  /* event listener stuff */
  this._collectorsStarted       = false;
  this._callbacks               = {progress: {}, seeded: {}};
  this._callbackI               = 0;
  
  /* constants */
  this._NOT_READY               = 0;
  this._READY                   = 1;
  this._REQUIRES_RESEED         = 2;

  this._MAX_WORDS_PER_BURST     = 65536;
  this._PARANOIA_LEVELS         = [0,48,64,96,128,192,256,384,512,768,1024];
  this._MILLISECONDS_PER_RESEED = 30000;
  this._BITS_PER_RESEED         = 80;
};
 
sjcl.prng.prototype = {
  /** Generate several random words, and return them in an array.
   * A word consists of 32 bits (4 bytes)
   * @param {Number} nwords The number of words to generate.
   */
  randomWords: function (nwords, paranoia) {
    var out = [], i, readiness = this.isReady(paranoia), g;
  
    if (readiness === this._NOT_READY) {
      throw new sjcl.exception.notReady("generator isn't seeded");
    } else if (readiness & this._REQUIRES_RESEED) {
      this._reseedFromPools(!(readiness & this._READY));
    }
  
    for (i=0; i<nwords; i+= 4) {
      if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {
        this._gate();
      }
   
      g = this._gen4words();
      out.push(g[0],g[1],g[2],g[3]);
    }
    this._gate();
  
    return out.slice(0,nwords);
  },
  
  setDefaultParanoia: function (paranoia, allowZeroParanoia) {
    if (paranoia === 0 && allowZeroParanoia !== "Setting paranoia=0 will ruin your security; use it only for testing") {
      throw new sjcl.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");
    }

    this._defaultParanoia = paranoia;
  },
  
  /**
   * Add entropy to the pools.
   * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string
   * @param {Number} estimatedEntropy The estimated entropy of data, in bits
   * @param {String} source The source of the entropy, eg "mouse"
   */
  addEntropy: function (data, estimatedEntropy, source) {
    source = source || "user";
  
    var id,
      i, tmp,
      t = (new Date()).valueOf(),
      robin = this._robins[source],
      oldReady = this.isReady(), err = 0, objName;
      
    id = this._collectorIds[source];
    if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }
      
    if (robin === undefined) { robin = this._robins[source] = 0; }
    this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;
  
    switch(typeof(data)) {
      
    case "number":
      if (estimatedEntropy === undefined) {
        estimatedEntropy = 1;
      }
      this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);
      break;
      
    case "object":
      objName = Object.prototype.toString.call(data);
      if (objName === "[object Uint32Array]") {
        tmp = [];
        for (i = 0; i < data.length; i++) {
          tmp.push(data[i]);
        }
        data = tmp;
      } else {
        if (objName !== "[object Array]") {
          err = 1;
        }
        for (i=0; i<data.length && !err; i++) {
          if (typeof(data[i]) !== "number") {
            err = 1;
          }
        }
      }
      if (!err) {
        if (estimatedEntropy === undefined) {
          /* horrible entropy estimator */
          estimatedEntropy = 0;
          for (i=0; i<data.length; i++) {
            tmp= data[i];
            while (tmp>0) {
              estimatedEntropy++;
              tmp = tmp >>> 1;
            }
          }
        }
        this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));
      }
      break;
      
    case "string":
      if (estimatedEntropy === undefined) {
       /* English text has just over 1 bit per character of entropy.
        * But this might be HTML or something, and have far less
        * entropy than English...  Oh well, let's just say one bit.
        */
       estimatedEntropy = data.length;
      }
      this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);
      this._pools[robin].update(data);
      break;
      
    default:
      err=1;
    }
    if (err) {
      throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
    }
  
    /* record the new strength */
    this._poolEntropy[robin] += estimatedEntropy;
    this._poolStrength += estimatedEntropy;
  
    /* fire off events */
    if (oldReady === this._NOT_READY) {
      if (this.isReady() !== this._NOT_READY) {
        this._fireEvent("seeded", Math.max(this._strength, this._poolStrength));
      }
      this._fireEvent("progress", this.getProgress());
    }
  },
  
  /** Is the generator ready? */
  isReady: function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];
  
    if (this._strength && this._strength >= entropyRequired) {
      return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?
        this._REQUIRES_RESEED | this._READY :
        this._READY;
    } else {
      return (this._poolStrength >= entropyRequired) ?
        this._REQUIRES_RESEED | this._NOT_READY :
        this._NOT_READY;
    }
  },
  
  /** Get the generator's progress toward readiness, as a fraction */
  getProgress: function (paranoia) {
    var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];
  
    if (this._strength >= entropyRequired) {
      return 1.0;
    } else {
      return (this._poolStrength > entropyRequired) ?
        1.0 :
        this._poolStrength / entropyRequired;
    }
  },
  
  /** start the built-in entropy collectors */
  startCollectors: function () {
    if (this._collectorsStarted) { return; }
  
    this._eventListener = {
      loadTimeCollector: this._bind(this._loadTimeCollector),
      mouseCollector: this._bind(this._mouseCollector),
      keyboardCollector: this._bind(this._keyboardCollector),
      accelerometerCollector: this._bind(this._accelerometerCollector),
      touchCollector: this._bind(this._touchCollector)
    };

    if (window.addEventListener) {
      window.addEventListener("load", this._eventListener.loadTimeCollector, false);
      window.addEventListener("mousemove", this._eventListener.mouseCollector, false);
      window.addEventListener("keypress", this._eventListener.keyboardCollector, false);
      window.addEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
      window.addEventListener("touchmove", this._eventListener.touchCollector, false);
    } else if (document.attachEvent) {
      document.attachEvent("onload", this._eventListener.loadTimeCollector);
      document.attachEvent("onmousemove", this._eventListener.mouseCollector);
      document.attachEvent("keypress", this._eventListener.keyboardCollector);
    } else {
      throw new sjcl.exception.bug("can't attach event");
    }
  
    this._collectorsStarted = true;
  },
  
  /** stop the built-in entropy collectors */
  stopCollectors: function () {
    if (!this._collectorsStarted) { return; }
  
    if (window.removeEventListener) {
      window.removeEventListener("load", this._eventListener.loadTimeCollector, false);
      window.removeEventListener("mousemove", this._eventListener.mouseCollector, false);
      window.removeEventListener("keypress", this._eventListener.keyboardCollector, false);
      window.removeEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
      window.removeEventListener("touchmove", this._eventListener.touchCollector, false);
    } else if (document.detachEvent) {
      document.detachEvent("onload", this._eventListener.loadTimeCollector);
      document.detachEvent("onmousemove", this._eventListener.mouseCollector);
      document.detachEvent("keypress", this._eventListener.keyboardCollector);
    }

    this._collectorsStarted = false;
  },
  
  /* use a cookie to store entropy.
  useCookie: function (all_cookies) {
      throw new sjcl.exception.bug("random: useCookie is unimplemented");
  },*/
  
  /** add an event listener for progress or seeded-ness. */
  addEventListener: function (name, callback) {
    this._callbacks[name][this._callbackI++] = callback;
  },
  
  /** remove an event listener for progress or seeded-ness */
  removeEventListener: function (name, cb) {
    var i, j, cbs=this._callbacks[name], jsTemp=[];

    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */

    for (j in cbs) {
      if (cbs.hasOwnProperty(j) && cbs[j] === cb) {
        jsTemp.push(j);
      }
    }

    for (i=0; i<jsTemp.length; i++) {
      j = jsTemp[i];
      delete cbs[j];
    }
  },
  
  _bind: function (func) {
    var that = this;
    return function () {
      func.apply(that, arguments);
    };
  },

  /** Generate 4 random words, no reseed, no gate.
   * @private
   */
  _gen4words: function () {
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
    return this._cipher.encrypt(this._counter);
  },
  
  /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.
   * @private
   */
  _gate: function () {
    this._key = this._gen4words().concat(this._gen4words());
    this._cipher = new sjcl.cipher.aes(this._key);
  },
  
  /** Reseed the generator with the given words
   * @private
   */
  _reseed: function (seedWords) {
    this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));
    this._cipher = new sjcl.cipher.aes(this._key);
    for (var i=0; i<4; i++) {
      this._counter[i] = this._counter[i]+1 | 0;
      if (this._counter[i]) { break; }
    }
  },
  
  /** reseed the data from the entropy pools
   * @param full If set, use all the entropy pools in the reseed.
   */
  _reseedFromPools: function (full) {
    var reseedData = [], strength = 0, i;
  
    this._nextReseed = reseedData[0] =
      (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;
    
    for (i=0; i<16; i++) {
      /* On some browsers, this is cryptographically random.  So we might
       * as well toss it in the pot and stir...
       */
      reseedData.push(Math.random()*0x100000000|0);
    }
    
    for (i=0; i<this._pools.length; i++) {
     reseedData = reseedData.concat(this._pools[i].finalize());
     strength += this._poolEntropy[i];
     this._poolEntropy[i] = 0;
   
     if (!full && (this._reseedCount & (1<<i))) { break; }
    }
  
    /* if we used the last pool, push a new one onto the stack */
    if (this._reseedCount >= 1 << this._pools.length) {
     this._pools.push(new sjcl.hash.sha256());
     this._poolEntropy.push(0);
    }
  
    /* how strong was this reseed? */
    this._poolStrength -= strength;
    if (strength > this._strength) {
      this._strength = strength;
    }
  
    this._reseedCount ++;
    this._reseed(reseedData);
  },
  
  _keyboardCollector: function () {
    this._addCurrentTimeToEntropy(1);
  },
  
  _mouseCollector: function (ev) {
    var x, y;

    try {
      x = ev.x || ev.clientX || ev.offsetX || 0;
      y = ev.y || ev.clientY || ev.offsetY || 0;
    } catch (err) {
      // Event originated from a secure element. No mouse position available.
      x = 0;
      y = 0;
    }

    if (x != 0 && y!= 0) {
      this.addEntropy([x,y], 2, "mouse");
    }

    this._addCurrentTimeToEntropy(0);
  },

  _touchCollector: function(ev) {
    var touch = ev.touches[0] || ev.changedTouches[0];
    var x = touch.pageX || touch.clientX,
        y = touch.pageY || touch.clientY;

    this.addEntropy([x,y],1,"touch");

    this._addCurrentTimeToEntropy(0);
  },
  
  _loadTimeCollector: function () {
    this._addCurrentTimeToEntropy(2);
  },

  _addCurrentTimeToEntropy: function (estimatedEntropy) {
    if (typeof window !== 'undefined' && window.performance && typeof window.performance.now === "function") {
      //how much entropy do we want to add here?
      this.addEntropy(window.performance.now(), estimatedEntropy, "loadtime");
    } else {
      this.addEntropy((new Date()).valueOf(), estimatedEntropy, "loadtime");
    }
  },
  _accelerometerCollector: function (ev) {
    var ac = ev.accelerationIncludingGravity.x||ev.accelerationIncludingGravity.y||ev.accelerationIncludingGravity.z;
    if(window.orientation){
      var or = window.orientation;
      if (typeof or === "number") {
        this.addEntropy(or, 1, "accelerometer");
      }
    }
    if (ac) {
      this.addEntropy(ac, 2, "accelerometer");
    }
    this._addCurrentTimeToEntropy(0);
  },

  _fireEvent: function (name, arg) {
    var j, cbs=sjcl.random._callbacks[name], cbsTemp=[];
    /* TODO: there is a race condition between removing collectors and firing them */

    /* I'm not sure if this is necessary; in C++, iterating over a
     * collection and modifying it at the same time is a no-no.
     */

    for (j in cbs) {
      if (cbs.hasOwnProperty(j)) {
        cbsTemp.push(cbs[j]);
      }
    }

    for (j=0; j<cbsTemp.length; j++) {
      cbsTemp[j](arg);
    }
  }
};

/** an instance for the prng.
* @see sjcl.prng
*/
sjcl.random = new sjcl.prng(6);

(function(){
  // function for getting nodejs crypto module. catches and ignores errors.
  function getCryptoModule() {
    try {
      return require('crypto');
    }
    catch (e) {
      return null;
    }
  }

  try {
    var buf, crypt, ab;

    // get cryptographically strong entropy depending on runtime environment
    if (typeof module !== 'undefined' && module.exports && (crypt = getCryptoModule()) && crypt.randomBytes) {
      buf = crypt.randomBytes(1024/8);
      buf = new Uint32Array(new Uint8Array(buf).buffer);
      sjcl.random.addEntropy(buf, 1024, "crypto.randomBytes");

    } else if (typeof window !== 'undefined' && typeof Uint32Array !== 'undefined') {
      ab = new Uint32Array(32);
      if (window.crypto && window.crypto.getRandomValues) {
        window.crypto.getRandomValues(ab);
      } else if (window.msCrypto && window.msCrypto.getRandomValues) {
        window.msCrypto.getRandomValues(ab);
      } else {
        return;
      }

      // get cryptographically strong entropy in Webkit
      sjcl.random.addEntropy(ab, 1024, "crypto.getRandomValues");

    } else {
      // no getRandomValues :-(
    }
  } catch (e) {
    if (typeof window !== 'undefined' && window.console) {
      console.log("There was an error collecting entropy from the browser:");
      console.log(e);
      //we do not want the library to fail due to randomness not being maintained.
    }
  }
}());
/** @fileOverview Convenince functions centered around JSON encapsulation.
 *
 * @author Emily Stark
 * @author Mike Hamburg
 * @author Dan Boneh
 */

 /**
  * JSON encapsulation
  * @namespace
  */
 sjcl.json = {
  /** Default values for encryption */
  defaults: { v:1, iter:10000, ks:128, ts:64, mode:"ccm", adata:"", cipher:"aes" },

  /** Simple encryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} plaintext The data to encrypt.
   * @param {Object} [params] The parameters including tag, iv and salt.
   * @param {Object} [rp] A returned version with filled-in parameters.
   * @return {Object} The cipher raw data.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   */
  _encrypt: function (password, plaintext, params, rp) {
    params = params || {};
    rp = rp || {};

    var j = sjcl.json, p = j._add({ iv: sjcl.random.randomWords(4,0) },
                                  j.defaults), tmp, prp, adata;
    j._add(p, params);
    adata = p.adata;
    if (typeof p.salt === "string") {
      p.salt = sjcl.codec.base64.toBits(p.salt);
    }
    if (typeof p.iv === "string") {
      p.iv = sjcl.codec.base64.toBits(p.iv);
    }

    if (!sjcl.mode[p.mode] ||
        !sjcl.cipher[p.cipher] ||
        (typeof password === "string" && p.iter <= 100) ||
        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||
        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||
        (p.iv.length < 2 || p.iv.length > 4)) {
      throw new sjcl.exception.invalid("json encrypt: invalid parameters");
    }

    if (typeof password === "string") {
      tmp = sjcl.misc.cachedPbkdf2(password, p);
      password = tmp.key.slice(0,p.ks/32);
      p.salt = tmp.salt;
    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.publicKey) {
      tmp = password.kem();
      p.kemtag = tmp.tag;
      password = tmp.key.slice(0,p.ks/32);
    }
    if (typeof plaintext === "string") {
      plaintext = sjcl.codec.utf8String.toBits(plaintext);
    }
    if (typeof adata === "string") {
      p.adata = adata = sjcl.codec.utf8String.toBits(adata);
    }
    prp = new sjcl.cipher[p.cipher](password);

    /* return the json data */
    j._add(rp, p);
    rp.key = password;

    /* do the encryption */
    if (p.mode === "ccm" && sjcl.arrayBuffer && sjcl.arrayBuffer.ccm && plaintext instanceof ArrayBuffer) {
      p.ct = sjcl.arrayBuffer.ccm.encrypt(prp, plaintext, p.iv, adata, p.ts);
    } else {
      p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);
    }

    //return j.encode(j._subtract(p, j.defaults));
    return p;
  },

  /** Simple encryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} plaintext The data to encrypt.
   * @param {Object} [params] The parameters including tag, iv and salt.
   * @param {Object} [rp] A returned version with filled-in parameters.
   * @return {String} The ciphertext serialized data.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   */
  encrypt: function (password, plaintext, params, rp) {
    var j = sjcl.json, p = j._encrypt.apply(j, arguments);
    return j.encode(p);
  },

  /** Simple decryption function.
   * @param {String|bitArray} password The password or key.
   * @param {Object} ciphertext The cipher raw data to decrypt.
   * @param {Object} [params] Additional non-default parameters.
   * @param {Object} [rp] A returned object with filled parameters.
   * @return {String} The plaintext.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.
   */
  _decrypt: function (password, ciphertext, params, rp) {
    params = params || {};
    rp = rp || {};

    var j = sjcl.json, p = j._add(j._add(j._add({},j.defaults),ciphertext), params, true), ct, tmp, prp, adata=p.adata;
    if (typeof p.salt === "string") {
      p.salt = sjcl.codec.base64.toBits(p.salt);
    }
    if (typeof p.iv === "string") {
      p.iv = sjcl.codec.base64.toBits(p.iv);
    }

    if (!sjcl.mode[p.mode] ||
        !sjcl.cipher[p.cipher] ||
        (typeof password === "string" && p.iter <= 100) ||
        (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||
        (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||
        (!p.iv) ||
        (p.iv.length < 2 || p.iv.length > 4)) {
      throw new sjcl.exception.invalid("json decrypt: invalid parameters");
    }

    if (typeof password === "string") {
      tmp = sjcl.misc.cachedPbkdf2(password, p);
      password = tmp.key.slice(0,p.ks/32);
      p.salt  = tmp.salt;
    } else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.secretKey) {
      password = password.unkem(sjcl.codec.base64.toBits(p.kemtag)).slice(0,p.ks/32);
    }
    if (typeof adata === "string") {
      adata = sjcl.codec.utf8String.toBits(adata);
    }
    prp = new sjcl.cipher[p.cipher](password);

    /* do the decryption */
    if (p.mode === "ccm" && sjcl.arrayBuffer && sjcl.arrayBuffer.ccm && p.ct instanceof ArrayBuffer) {
      ct = sjcl.arrayBuffer.ccm.decrypt(prp, p.ct, p.iv, p.tag, adata, p.ts);
    } else {
      ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);
    }

    /* return the json data */
    j._add(rp, p);
    rp.key = password;

    if (params.raw === 1) {
      return ct;
    } else {
      return sjcl.codec.utf8String.fromBits(ct);
    }
  },

  /** Simple decryption function.
   * @param {String|bitArray} password The password or key.
   * @param {String} ciphertext The ciphertext to decrypt.
   * @param {Object} [params] Additional non-default parameters.
   * @param {Object} [rp] A returned object with filled parameters.
   * @return {String} The plaintext.
   * @throws {sjcl.exception.invalid} if a parameter is invalid.
   * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.
   */
  decrypt: function (password, ciphertext, params, rp) {
    var j = sjcl.json;
    return j._decrypt(password, j.decode(ciphertext), params, rp);
  },

  /** Encode a flat structure into a JSON string.
   * @param {Object} obj The structure to encode.
   * @return {String} A JSON string.
   * @throws {sjcl.exception.invalid} if obj has a non-alphanumeric property.
   * @throws {sjcl.exception.bug} if a parameter has an unsupported type.
   */
  encode: function (obj) {
    var i, out='{', comma='';
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (!i.match(/^[a-z0-9]+$/i)) {
          throw new sjcl.exception.invalid("json encode: invalid property name");
        }
        out += comma + '"' + i + '":';
        comma = ',';

        switch (typeof obj[i]) {
          case 'number':
          case 'boolean':
            out += obj[i];
            break;

          case 'string':
            out += '"' + escape(obj[i]) + '"';
            break;

          case 'object':
            out += '"' + sjcl.codec.base64.fromBits(obj[i],0) + '"';
            break;

          default:
            throw new sjcl.exception.bug("json encode: unsupported type");
        }
      }
    }
    return out+'}';
  },

  /** Decode a simple (flat) JSON string into a structure.  The ciphertext,
   * adata, salt and iv will be base64-decoded.
   * @param {String} str The string.
   * @return {Object} The decoded structure.
   * @throws {sjcl.exception.invalid} if str isn't (simple) JSON.
   */
  decode: function (str) {
    str = str.replace(/\s/g,'');
    if (!str.match(/^\{.*\}$/)) {
      throw new sjcl.exception.invalid("json decode: this isn't json!");
    }
    var a = str.replace(/^\{|\}$/g, '').split(/,/), out={}, i, m;
    for (i=0; i<a.length; i++) {
      if (!(m=a[i].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i))) {
        throw new sjcl.exception.invalid("json decode: this isn't json!");
      }
      if (m[3] != null) {
        out[m[2]] = parseInt(m[3],10);
      } else if (m[4] != null) {
        out[m[2]] = m[2].match(/^(ct|adata|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);
      } else if (m[5] != null) {
        out[m[2]] = m[5] === 'true';
      }
    }
    return out;
  },

  /** Insert all elements of src into target, modifying and returning target.
   * @param {Object} target The object to be modified.
   * @param {Object} src The object to pull data from.
   * @param {boolean} [requireSame=false] If true, throw an exception if any field of target differs from corresponding field of src.
   * @return {Object} target.
   * @private
   */
  _add: function (target, src, requireSame) {
    if (target === undefined) { target = {}; }
    if (src === undefined) { return target; }
    var i;
    for (i in src) {
      if (src.hasOwnProperty(i)) {
        if (requireSame && target[i] !== undefined && target[i] !== src[i]) {
          throw new sjcl.exception.invalid("required parameter overridden");
        }
        target[i] = src[i];
      }
    }
    return target;
  },

  /** Remove all elements of minus from plus.  Does not modify plus.
   * @private
   */
  _subtract: function (plus, minus) {
    var out = {}, i;

    for (i in plus) {
      if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {
        out[i] = plus[i];
      }
    }

    return out;
  },

  /** Return only the specified elements of src.
   * @private
   */
  _filter: function (src, filter) {
    var out = {}, i;
    for (i=0; i<filter.length; i++) {
      if (src[filter[i]] !== undefined) {
        out[filter[i]] = src[filter[i]];
      }
    }
    return out;
  }
};

/** Simple encryption function; convenient shorthand for sjcl.json.encrypt.
 * @param {String|bitArray} password The password or key.
 * @param {String} plaintext The data to encrypt.
 * @param {Object} [params] The parameters including tag, iv and salt.
 * @param {Object} [rp] A returned version with filled-in parameters.
 * @return {String} The ciphertext.
 */
sjcl.encrypt = sjcl.json.encrypt;

/** Simple decryption function; convenient shorthand for sjcl.json.decrypt.
 * @param {String|bitArray} password The password or key.
 * @param {String} ciphertext The ciphertext to decrypt.
 * @param {Object} [params] Additional non-default parameters.
 * @param {Object} [rp] A returned object with filled parameters.
 * @return {String} The plaintext.
 */
sjcl.decrypt = sjcl.json.decrypt;

/** The cache for cachedPbkdf2.
 * @private
 */
sjcl.misc._pbkdf2Cache = {};

/** Cached PBKDF2 key derivation.
 * @param {String} password The password.
 * @param {Object} [obj] The derivation params (iteration count and optional salt).
 * @return {Object} The derived data in key, the salt in salt.
 */
sjcl.misc.cachedPbkdf2 = function (password, obj) {
  var cache = sjcl.misc._pbkdf2Cache, c, cp, str, salt, iter;

  obj = obj || {};
  iter = obj.iter || 1000;

  /* open the cache for this password and iteration count */
  cp = cache[password] = cache[password] || {};
  c = cp[iter] = cp[iter] || { firstSalt: (obj.salt && obj.salt.length) ?
                     obj.salt.slice(0) : sjcl.random.randomWords(2,0) };

  salt = (obj.salt === undefined) ? c.firstSalt : obj.salt;

  c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);
  return { key: c[salt].slice(0), salt:salt.slice(0) };
};
if(typeof module !== 'undefined' && module.exports){
  module.exports = sjcl;
}
if (typeof define === "function") {
    define([], function () {
        return sjcl;
    });
}

// above automatically copied from sjcl.js
</script>
    <script>
// automatically copied from 5x8.js

//each character 8 bytes
console_font_5x8 = [

    /*
     * code=0, hex=0x00, ascii="^@"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=1, hex=0x01, ascii="^A"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0xA8,  /* 10101 */
    0xF8,  /* 11111 */
    0xD8,  /* 11011 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=2, hex=0x02, ascii="^B"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0xA8,  /* 10101 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=3, hex=0x03, ascii="^C"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=4, hex=0x04, ascii="^D"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0xF8,  /* 11111 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=5, hex=0x05, ascii="^E"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0xA8,  /* 10101 */
    0xF8,  /* 11111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=6, hex=0x06, ascii="^F"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0xF8,  /* 11111 */
    0xA8,  /* 10101 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=7, hex=0x07, ascii="^G"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=8, hex=0x08, ascii="^H"
     */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xD8,  /* 11011 */
    0x88,  /* 10001 */
    0xD8,  /* 11011 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */

    /*
     * code=9, hex=0x09, ascii="^I"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=10, hex=0x0A, ascii="^J"
     */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xD8,  /* 11011 */
    0x88,  /* 10001 */
    0xD8,  /* 11011 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */

    /*
     * code=11, hex=0x0B, ascii="^K"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x38,  /* 00111 */
    0x18,  /* 00011 */
    0x68,  /* 01101 */
    0xA0,  /* 10100 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=12, hex=0x0C, ascii="^L"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=13, hex=0x0D, ascii="^M"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x40,  /* 01000 */
    0xC0,  /* 11000 */
    0x80,  /* 10000 */
    0x00,  /* 00000 */

    /*
     * code=14, hex=0x0E, ascii="^N"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x38,  /* 00111 */
    0x48,  /* 01001 */
    0x58,  /* 01011 */
    0xD0,  /* 11010 */
    0x80,  /* 10000 */
    0x00,  /* 00000 */

    /*
     * code=15, hex=0x0F, ascii="^O"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=16, hex=0x10, ascii="^P"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0x60,  /* 01100 */
    0x70,  /* 01110 */
    0x60,  /* 01100 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=17, hex=0x11, ascii="^Q"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x30,  /* 00110 */
    0x70,  /* 01110 */
    0x30,  /* 00110 */
    0x10,  /* 00010 */
    0x00,  /* 00000 */

    /*
     * code=18, hex=0x12, ascii="^R"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=19, hex=0x13, ascii="^S"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */

    /*
     * code=20, hex=0x14, ascii="^T"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x78,  /* 01111 */
    0xD0,  /* 11010 */
    0xD0,  /* 11010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=21, hex=0x15, ascii="^U"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x18,  /* 00011 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x48,  /* 01001 */
    0x30,  /* 00110 */
    0xC0,  /* 11000 */

    /*
     * code=22, hex=0x16, ascii="^V"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */

    /*
     * code=23, hex=0x17, ascii="^W"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */

    /*
     * code=24, hex=0x18, ascii="^X"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=25, hex=0x19, ascii="^Y"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=26, hex=0x1A, ascii="^Z"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0xF8,  /* 11111 */
    0x10,  /* 00010 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=27, hex=0x1B, ascii="^["
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0xF8,  /* 11111 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=28, hex=0x1C, ascii="^\"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x80,  /* 10000 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=29, hex=0x1D, ascii="^]"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0xF8,  /* 11111 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=30, hex=0x1E, ascii="^^"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */

    /*
     * code=31, hex=0x1F, ascii="^_"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=32, hex=0x20, ascii=" "
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=33, hex=0x21, ascii="!"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=34, hex=0x22, ascii="""
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=35, hex=0x23, ascii="#"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0xF8,  /* 11111 */
    0x50,  /* 01010 */
    0xF8,  /* 11111 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */

    /*
     * code=36, hex=0x24, ascii="$"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x30,  /* 00110 */
    0x40,  /* 01000 */
    0x30,  /* 00110 */
    0x60,  /* 01100 */
    0x20,  /* 00100 */

    /*
     * code=37, hex=0x25, ascii="%"
     */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0xA8,  /* 10101 */
    0x50,  /* 01010 */
    0x30,  /* 00110 */
    0x68,  /* 01101 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=38, hex=0x26, ascii="&"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x30,  /* 00110 */
    0x40,  /* 01000 */
    0x68,  /* 01101 */
    0x90,  /* 10010 */
    0x68,  /* 01101 */
    0x00,  /* 00000 */

    /*
     * code=39, hex=0x27, ascii="'"
     */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=40, hex=0x28, ascii="("
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=41, hex=0x29, ascii=")"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=42, hex=0x2A, ascii="*"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */

    /*
     * code=43, hex=0x2B, ascii="+"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=44, hex=0x2C, ascii=","
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */

    /*
     * code=45, hex=0x2D, ascii="-"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=46, hex=0x2E, ascii="."
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=47, hex=0x2F, ascii="/"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=48, hex=0x30, ascii="0"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0xb0,  /* 10110 */
    0x90,  /* 10010 */
    0xd0,  /* 11010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=49, hex=0x31, ascii="1"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x60,  /* 01100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=50, hex=0x32, ascii="2"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */

    /*
     * code=51, hex=0x33, ascii="3"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x10,  /* 00010 */
    0x60,  /* 01100 */
    0x10,  /* 00010 */
    0xE0,  /* 11100 */
    0x00,  /* 00000 */

    /*
     * code=52, hex=0x34, ascii="4"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x30,  /* 00110 */
    0x50,  /* 01010 */
    0xF0,  /* 11110 */
    0x10,  /* 00010 */
    0x00,  /* 00000 */

    /*
     * code=53, hex=0x35, ascii="5"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x80,  /* 10000 */
    0xE0,  /* 11100 */
    0x10,  /* 00010 */
    0xE0,  /* 11100 */
    0x00,  /* 00000 */

    /*
     * code=54, hex=0x36, ascii="6"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x80,  /* 10000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=55, hex=0x37, ascii="7"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=56, hex=0x38, ascii="8"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=57, hex=0x39, ascii="9"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x10,  /* 00010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=58, hex=0x3A, ascii=":"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=59, hex=0x3B, ascii=";"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */

    /*
     * code=60, hex=0x3C, ascii="<"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x10,  /* 00010 */
    0x00,  /* 00000 */

    /*
     * code=61, hex=0x3D, ascii="="
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=62, hex=0x3E, ascii=">"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=63, hex=0x3F, ascii="?"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x10,  /* 00010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=64, hex=0x40, ascii="@"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x88,  /* 10001 */
    0xB0,  /* 10110 */
    0x80,  /* 10000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=65, hex=0x41, ascii="A"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0xF0,  /* 11110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=66, hex=0x42, ascii="B"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0xE0,  /* 11100 */
    0x00,  /* 00000 */

    /*
     * code=67, hex=0x43, ascii="C"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=68, hex=0x44, ascii="D"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0xE0,  /* 11100 */
    0x00,  /* 00000 */

    /*
     * code=69, hex=0x45, ascii="E"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x80,  /* 10000 */
    0xE0,  /* 11100 */
    0x80,  /* 10000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */

    /*
     * code=70, hex=0x46, ascii="F"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x80,  /* 10000 */
    0xE0,  /* 11100 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0x00,  /* 00000 */

    /*
     * code=71, hex=0x47, ascii="G"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x80,  /* 10000 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=72, hex=0x48, ascii="H"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0xF0,  /* 11110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=73, hex=0x49, ascii="I"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=74, hex=0x4A, ascii="J"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x10,  /* 00010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=75, hex=0x4B, ascii="K"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0xA0,  /* 10100 */
    0xC0,  /* 11000 */
    0xA0,  /* 10100 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=76, hex=0x4C, ascii="L"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */

    /*
     * code=77, hex=0x4D, ascii="M"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0xF0,  /* 11110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=78, hex=0x4E, ascii="N"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0xD0,  /* 11010 */
    0xB0,  /* 10110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=79, hex=0x4F, ascii="O"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=80, hex=0x50, ascii="P"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0xE0,  /* 11100 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0x00,  /* 00000 */

    /*
     * code=81, hex=0x51, ascii="Q"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x10,  /* 00010 */

    /*
     * code=82, hex=0x52, ascii="R"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=83, hex=0x53, ascii="S"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x80,  /* 10000 */
    0x60,  /* 01100 */
    0x10,  /* 00010 */
    0xE0,  /* 11100 */
    0x00,  /* 00000 */

    /*
     * code=84, hex=0x54, ascii="T"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=85, hex=0x55, ascii="U"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=86, hex=0x56, ascii="V"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=87, hex=0x57, ascii="W"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x88,  /* 10001 */
    0xA8,  /* 10101 */
    0xA8,  /* 10101 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */

    /*
     * code=88, hex=0x58, ascii="X"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x50,  /* 01010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=89, hex=0x59, ascii="Y"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=90, hex=0x5A, ascii="Z"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x80,  /* 10000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */

    /*
     * code=91, hex=0x5B, ascii="["
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=92, hex=0x5C, ascii="\"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x10,  /* 00010 */
    0x00,  /* 00000 */

    /*
     * code=93, hex=0x5D, ascii="]"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=94, hex=0x5E, ascii="^"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=95, hex=0x5F, ascii="_"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */

    /*
     * code=96, hex=0x60, ascii="`"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=97, hex=0x61, ascii="a"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x10,  /* 00010 */
    0x70,  /* 01110 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */

    /*
     * code=98, hex=0x62, ascii="b"
     */
    0x00,  /* 00000 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0xE0,  /* 11100 */
    0x00,  /* 00000 */

    /*
     * code=99, hex=0x63, ascii="c"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x30,  /* 00110 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x30,  /* 00110 */
    0x00,  /* 00000 */

    /*
     * code=100, hex=0x64, ascii="d"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x70,  /* 01110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=101, hex=0x65, ascii="e"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0xF0,  /* 11110 */
    0x80,  /* 10000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=102, hex=0x66, ascii="f"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x30,  /* 00110 */
    0x40,  /* 01000 */
    0xE0,  /* 11100 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=103, hex=0x67, ascii="g"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x10,  /* 00010 */
    0x60,  /* 01100 */

    /*
     * code=104, hex=0x68, ascii="h"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x80,  /* 10000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=105, hex=0x69, ascii="i"
     */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=106, hex=0x6A, ascii="j"
     */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x10,  /* 00010 */
    0x10,  /* 00010 */
    0x10,  /* 00010 */
    0x60,  /* 01100 */

    /*
     * code=107, hex=0x6B, ascii="k"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x80,  /* 10000 */
    0xA0,  /* 10100 */
    0xC0,  /* 11000 */
    0xA0,  /* 10100 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=108, hex=0x6C, ascii="l"
     */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=109, hex=0x6D, ascii="m"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0xF0,  /* 11110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=110, hex=0x6E, ascii="n"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=111, hex=0x6F, ascii="o"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=112, hex=0x70, ascii="p"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0xE0,  /* 11100 */
    0x80,  /* 10000 */

    /*
     * code=113, hex=0x71, ascii="q"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x10,  /* 00010 */

    /*
     * code=114, hex=0x72, ascii="r"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x60,  /* 01100 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=115, hex=0x73, ascii="s"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0xC0,  /* 11000 */
    0x30,  /* 00110 */
    0xE0,  /* 11100 */
    0x00,  /* 00000 */

    /*
     * code=116, hex=0x74, ascii="t"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0xF0,  /* 11110 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x30,  /* 00110 */
    0x00,  /* 00000 */

    /*
     * code=117, hex=0x75, ascii="u"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=118, hex=0x76, ascii="v"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=119, hex=0x77, ascii="w"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0xF0,  /* 11110 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=120, hex=0x78, ascii="x"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=121, hex=0x79, ascii="y"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x10,  /* 00010 */
    0x60,  /* 01100 */

    /*
     * code=122, hex=0x7A, ascii="z"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */

    /*
     * code=123, hex=0x7B, ascii="{"
     */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x10,  /* 00010 */
    0x00,  /* 00000 */

    /*
     * code=124, hex=0x7C, ascii="|"
     */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=125, hex=0x7D, ascii="}"
     */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x10,  /* 00010 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=126, hex=0x7E, ascii="~"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0xA0,  /* 10100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=127, hex=0x7F, ascii="^?"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x88,  /* 10001 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */

    /*
     * code=128, hex=0x80, ascii="!^@"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */

    /*
     * code=129, hex=0x81, ascii="!^A"
     */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=130, hex=0x82, ascii="!^B"
     */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0xF0,  /* 11110 */
    0x80,  /* 10000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=131, hex=0x83, ascii="!^C"
     */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0xC0,  /* 11000 */
    0x20,  /* 00100 */
    0xA0,  /* 10100 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */

    /*
     * code=132, hex=0x84, ascii="!^D"
     */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0xC0,  /* 11000 */
    0x20,  /* 00100 */
    0x60,  /* 01100 */
    0xB0,  /* 10110 */
    0x00,  /* 00000 */

    /*
     * code=133, hex=0x85, ascii="!^E"
     */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0xC0,  /* 11000 */
    0x20,  /* 00100 */
    0x60,  /* 01100 */
    0xB0,  /* 10110 */
    0x00,  /* 00000 */

    /*
     * code=134, hex=0x86, ascii="!^F"
     */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0xC0,  /* 11000 */
    0x20,  /* 00100 */
    0x60,  /* 01100 */
    0xB0,  /* 10110 */
    0x00,  /* 00000 */

    /*
     * code=135, hex=0x87, ascii="!^G"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x30,  /* 00110 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x30,  /* 00110 */
    0x20,  /* 00100 */

    /*
     * code=136, hex=0x88, ascii="!^H"
     */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0xF0,  /* 11110 */
    0x80,  /* 10000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=137, hex=0x89, ascii="!^I"
     */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0xF0,  /* 11110 */
    0x80,  /* 10000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=138, hex=0x8A, ascii="!^J"
     */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0xF0,  /* 11110 */
    0x80,  /* 10000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=139, hex=0x8B, ascii="!^K"
     */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=140, hex=0x8C, ascii="!^L"
     */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=141, hex=0x8D, ascii="!^M"
     */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=142, hex=0x8E, ascii="!^N"
     */
    0xA0,  /* 10100 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0xF0,  /* 11110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=143, hex=0x8F, ascii="!^O"
     */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0xF0,  /* 11110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=144, hex=0x90, ascii="!^P"
     */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0xF0,  /* 11110 */
    0x80,  /* 10000 */
    0xE0,  /* 11100 */
    0x80,  /* 10000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */

    /*
     * code=145, hex=0x91, ascii="!^Q"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xD8,  /* 11011 */
    0x78,  /* 01111 */
    0xE0,  /* 11100 */
    0xB8,  /* 10111 */
    0x00,  /* 00000 */

    /*
     * code=146, hex=0x92, ascii="!^R"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0xA0,  /* 10100 */
    0xF0,  /* 11110 */
    0xA0,  /* 10100 */
    0xB0,  /* 10110 */
    0x00,  /* 00000 */

    /*
     * code=147, hex=0x93, ascii="!^S"
     */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=148, hex=0x94, ascii="!^T"
     */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=149, hex=0x95, ascii="!^U"
     */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=150, hex=0x96, ascii="!^V"
     */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=151, hex=0x97, ascii="!^W"
     */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=152, hex=0x98, ascii="!^X"
     */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x10,  /* 00010 */
    0x60,  /* 01100 */

    /*
     * code=153, hex=0x99, ascii="!^Y"
     */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=154, hex=0x9A, ascii="!^Z"
     */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=155, hex=0x9B, ascii="!^["
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x80,  /* 10000 */
    0x80,  /* 10000 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */

    /*
     * code=156, hex=0x9C, ascii="!^\"
     */
    0x00,  /* 00000 */
    0x30,  /* 00110 */
    0x50,  /* 01010 */
    0x40,  /* 01000 */
    0xE0,  /* 11100 */
    0x40,  /* 01000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */

    /*
     * code=157, hex=0x9D, ascii="!^]"
     */
    0x00,  /* 00000 */
    0xD8,  /* 11011 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=158, hex=0x9E, ascii="!^^"
     */
    0x00,  /* 00000 */
    0xC0,  /* 11000 */
    0xA0,  /* 10100 */
    0xB0,  /* 10110 */
    0xF8,  /* 11111 */
    0x90,  /* 10010 */
    0x88,  /* 10001 */
    0x00,  /* 00000 */

    /*
     * code=159, hex=0x9F, ascii="!^_"
     */
    0x00,  /* 00000 */
    0x30,  /* 00110 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0xF0,  /* 11110 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x80,  /* 10000 */

    /*
     * code=160, hex=0xA0, ascii="! "
     */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */
    0xC0,  /* 11000 */
    0x20,  /* 00100 */
    0x60,  /* 01100 */
    0xB0,  /* 10110 */
    0x00,  /* 00000 */

    /*
     * code=161, hex=0xA1, ascii="!!"
     */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=162, hex=0xA2, ascii="!""
     */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=163, hex=0xA3, ascii="!#"
     */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=164, hex=0xA4, ascii="!$"
     */
    0x50,  /* 01010 */
    0xA0,  /* 10100 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=165, hex=0xA5, ascii="!%"
     */
    0x50,  /* 01010 */
    0xA0,  /* 10100 */
    0x90,  /* 10010 */
    0xD0,  /* 11010 */
    0xD0,  /* 11010 */
    0xB0,  /* 10110 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=166, hex=0xA6, ascii="!&"
     */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x30,  /* 00110 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=167, hex=0xA7, ascii="!'"
     */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=168, hex=0xA8, ascii="!("
     */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=169, hex=0xA9, ascii="!)"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x80,  /* 10000 */
    0x00,  /* 00000 */

    /*
     * code=170, hex=0xAA, ascii="!*"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x08,  /* 00001 */
    0x00,  /* 00000 */

    /*
     * code=171, hex=0xAB, ascii="!+"
     */
    0x00,  /* 00000 */
    0x80,  /* 10000 */
    0x90,  /* 10010 */
    0xA0,  /* 10100 */
    0x58,  /* 01011 */
    0x88,  /* 10001 */
    0x38,  /* 00111 */
    0x00,  /* 00000 */

    /*
     * code=172, hex=0xAC, ascii="!,"
     */
    0x00,  /* 00000 */
    0x88,  /* 10001 */
    0x90,  /* 10010 */
    0xA0,  /* 10100 */
    0x48,  /* 01001 */
    0x98,  /* 10011 */
    0x38,  /* 00111 */
    0x08,  /* 00001 */

    /*
     * code=173, hex=0xAD, ascii="!-"
     */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=174, hex=0xAE, ascii="!."
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0xA0,  /* 10100 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */

    /*
     * code=175, hex=0xAF, ascii="!/"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xA0,  /* 10100 */
    0x50,  /* 01010 */
    0xA0,  /* 10100 */
    0x00,  /* 00000 */

    /*
     * code=176, hex=0xB0, ascii="!0"
     */
    0xA8,  /* 10101 */
    0x50,  /* 01010 */
    0xA8,  /* 10101 */
    0x50,  /* 01010 */
    0xA8,  /* 10101 */
    0x50,  /* 01010 */
    0xA8,  /* 10101 */
    0x50,  /* 01010 */

    /*
     * code=177, hex=0xB1, ascii="!1"
     */
    0xE8,  /* 11101 */
    0x50,  /* 01010 */
    0xB8,  /* 10111 */
    0x50,  /* 01010 */
    0xE8,  /* 11101 */
    0x50,  /* 01010 */
    0xB8,  /* 10111 */
    0x50,  /* 01010 */

    /*
     * code=178, hex=0xB2, ascii="!2"
     */
    0xD8,  /* 11011 */
    0x70,  /* 01110 */
    0xD8,  /* 11011 */
    0x70,  /* 01110 */
    0xD8,  /* 11011 */
    0x70,  /* 01110 */
    0xD8,  /* 11011 */
    0x70,  /* 01110 */

    /*
     * code=179, hex=0xB3, ascii="!3"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=180, hex=0xB4, ascii="!4"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0xE0,  /* 11100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=181, hex=0xB5, ascii="!5"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0xE0,  /* 11100 */
    0x20,  /* 00100 */
    0xE0,  /* 11100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=182, hex=0xB6, ascii="!6"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0xD0,  /* 11010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=183, hex=0xB7, ascii="!7"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=184, hex=0xB8, ascii="!8"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x20,  /* 00100 */
    0xE0,  /* 11100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=185, hex=0xB9, ascii="!9"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0xD0,  /* 11010 */
    0x10,  /* 00010 */
    0xD0,  /* 11010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=186, hex=0xBA, ascii="!:"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=187, hex=0xBB, ascii="!;"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x10,  /* 00010 */
    0xD0,  /* 11010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=188, hex=0xBC, ascii="!<"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0xD0,  /* 11010 */
    0x10,  /* 00010 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=189, hex=0xBD, ascii="!="
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=190, hex=0xBE, ascii="!>"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0xE0,  /* 11100 */
    0x20,  /* 00100 */
    0xE0,  /* 11100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=191, hex=0xBF, ascii="!?"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xE0,  /* 11100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=192, hex=0xC0, ascii="!@"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x38,  /* 00111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=193, hex=0xC1, ascii="!A"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=194, hex=0xC2, ascii="!B"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=195, hex=0xC3, ascii="!C"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x38,  /* 00111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=196, hex=0xC4, ascii="!D"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=197, hex=0xC5, ascii="!E"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0xF8,  /* 11111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=198, hex=0xC6, ascii="!F"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x38,  /* 00111 */
    0x20,  /* 00100 */
    0x38,  /* 00111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=199, hex=0xC7, ascii="!G"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x58,  /* 01011 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=200, hex=0xC8, ascii="!H"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x58,  /* 01011 */
    0x40,  /* 01000 */
    0x78,  /* 01111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=201, hex=0xC9, ascii="!I"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x78,  /* 01111 */
    0x40,  /* 01000 */
    0x58,  /* 01011 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=202, hex=0xCA, ascii="!J"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0xD8,  /* 11011 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=203, hex=0xCB, ascii="!K"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0xD8,  /* 11011 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=204, hex=0xCC, ascii="!L"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x58,  /* 01011 */
    0x40,  /* 01000 */
    0x58,  /* 01011 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=205, hex=0xCD, ascii="!M"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=206, hex=0xCE, ascii="!N"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0xD8,  /* 11011 */
    0x00,  /* 00000 */
    0xD8,  /* 11011 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=207, hex=0xCF, ascii="!O"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=208, hex=0xD0, ascii="!P"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=209, hex=0xD1, ascii="!Q"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=210, hex=0xD2, ascii="!R"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=211, hex=0xD3, ascii="!S"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x78,  /* 01111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=212, hex=0xD4, ascii="!T"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x38,  /* 00111 */
    0x20,  /* 00100 */
    0x38,  /* 00111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=213, hex=0xD5, ascii="!U"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x38,  /* 00111 */
    0x20,  /* 00100 */
    0x38,  /* 00111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=214, hex=0xD6, ascii="!V"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x78,  /* 01111 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=215, hex=0xD7, ascii="!W"
     */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0xF8,  /* 11111 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */

    /*
     * code=216, hex=0xD8, ascii="!X"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0xF8,  /* 11111 */
    0x20,  /* 00100 */
    0xF8,  /* 11111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=217, hex=0xD9, ascii="!Y"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0xE0,  /* 11100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=218, hex=0xDA, ascii="!Z"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x38,  /* 00111 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=219, hex=0xDB, ascii="!["
     */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */

    /*
     * code=220, hex=0xDC, ascii="!\"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */

    /*
     * code=221, hex=0xDD, ascii="!]"
     */
    0xE0,  /* 11100 */
    0xE0,  /* 11100 */
    0xE0,  /* 11100 */
    0xE0,  /* 11100 */
    0xE0,  /* 11100 */
    0xE0,  /* 11100 */
    0xE0,  /* 11100 */
    0xE0,  /* 11100 */

    /*
     * code=222, hex=0xDE, ascii="!^"
     */
    0x18,  /* 00011 */
    0x18,  /* 00011 */
    0x18,  /* 00011 */
    0x18,  /* 00011 */
    0x18,  /* 00011 */
    0x18,  /* 00011 */
    0x18,  /* 00011 */
    0x18,  /* 00011 */

    /*
     * code=223, hex=0xDF, ascii="!_"
     */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=224, hex=0xE0, ascii="!`"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x68,  /* 01101 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x68,  /* 01101 */
    0x00,  /* 00000 */

    /*
     * code=225, hex=0xE1, ascii="!a"
     */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0xF0,  /* 11110 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0xE0,  /* 11100 */
    0x80,  /* 10000 */

    /*
     * code=226, hex=0xE2, ascii="!b"
     */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=227, hex=0xE3, ascii="!c"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */

    /*
     * code=228, hex=0xE4, ascii="!d"
     */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x48,  /* 01001 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x88,  /* 10001 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */

    /*
     * code=229, hex=0xE5, ascii="!e"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x78,  /* 01111 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=230, hex=0xE6, ascii="!f"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0xE8,  /* 11101 */
    0x80,  /* 10000 */

    /*
     * code=231, hex=0xE7, ascii="!g"
     */
    0x00,  /* 00000 */
    0x98,  /* 10011 */
    0x50,  /* 01010 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */

    /*
     * code=232, hex=0xE8, ascii="!h"
     */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x88,  /* 10001 */
    0x70,  /* 01110 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=233, hex=0xE9, ascii="!i"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x88,  /* 10001 */
    0xF8,  /* 11111 */
    0x88,  /* 10001 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=234, hex=0xEA, ascii="!j"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x88,  /* 10001 */
    0x88,  /* 10001 */
    0x50,  /* 01010 */
    0xD8,  /* 11011 */
    0x00,  /* 00000 */

    /*
     * code=235, hex=0xEB, ascii="!k"
     */
    0x60,  /* 01100 */
    0x80,  /* 10000 */
    0x40,  /* 01000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=236, hex=0xEC, ascii="!l"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0xA8,  /* 10101 */
    0xA8,  /* 10101 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=237, hex=0xED, ascii="!m"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x08,  /* 00001 */
    0x70,  /* 01110 */
    0xA8,  /* 10101 */
    0x48,  /* 01001 */
    0xB0,  /* 10110 */
    0x00,  /* 00000 */

    /*
     * code=238, hex=0xEE, ascii="!n"
     */
    0x00,  /* 00000 */
    0x30,  /* 00110 */
    0x40,  /* 01000 */
    0x70,  /* 01110 */
    0x40,  /* 01000 */
    0x40,  /* 01000 */
    0x30,  /* 00110 */
    0x00,  /* 00000 */

    /*
     * code=239, hex=0xEF, ascii="!o"
     */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x90,  /* 10010 */
    0x00,  /* 00000 */

    /*
     * code=240, hex=0xF0, ascii="!p"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */

    /*
     * code=241, hex=0xF1, ascii="!q"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0xF8,  /* 11111 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0xF8,  /* 11111 */
    0x00,  /* 00000 */

    /*
     * code=242, hex=0xF2, ascii="!r"
     */
    0x00,  /* 00000 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */

    /*
     * code=243, hex=0xF3, ascii="!s"
     */
    0x00,  /* 00000 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x40,  /* 01000 */
    0x20,  /* 00100 */
    0x10,  /* 00010 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */

    /*
     * code=244, hex=0xF4, ascii="!t"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x18,  /* 00011 */
    0x28,  /* 00101 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */

    /*
     * code=245, hex=0xF5, ascii="!u"
     */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0x20,  /* 00100 */
    0xA0,  /* 10100 */
    0xC0,  /* 11000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=246, hex=0xF6, ascii="!v"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */
    0xF0,  /* 11110 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */

    /*
     * code=247, hex=0xF7, ascii="!w"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0xA0,  /* 10100 */
    0x00,  /* 00000 */
    0x50,  /* 01010 */
    0xA0,  /* 10100 */
    0x00,  /* 00000 */

    /*
     * code=248, hex=0xF8, ascii="!x"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x50,  /* 01010 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=249, hex=0xF9, ascii="!y"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x60,  /* 01100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=250, hex=0xFA, ascii="!z"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x20,  /* 00100 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=251, hex=0xFB, ascii="!{"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x18,  /* 00011 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0xA0,  /* 10100 */
    0x40,  /* 01000 */
    0x00,  /* 00000 */

    /*
     * code=252, hex=0xFC, ascii="!|"
     */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x50,  /* 01010 */
    0x50,  /* 01010 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=253, hex=0xFD, ascii="!}"
     */
    0x00,  /* 00000 */
    0x60,  /* 01100 */
    0x10,  /* 00010 */
    0x20,  /* 00100 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=254, hex=0xFE, ascii="!~"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x70,  /* 01110 */
    0x70,  /* 01110 */
    0x70,  /* 01110 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */

    /*
     * code=255, hex=0xFF, ascii="!^"
     */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
    0x00,  /* 00000 */
];

// above automatically copied from 5x8.js
</script>
    <script>
// automatically copied from sixteenSeg.js
﻿var segchar16 =
    { bit_count: 16,
      example_coord: [1, 9, 0, 8, 0, 2, 1, 1, 2, 2, 2, 8], //f coord
      example_coord_bb: { w: 2, h: 9 },
      
      coords: [
	  [5, 1, 6, 0, 8, 0, 9, 1, 8, 2, 6, 2],        //a2
	  [5, 9, 6, 10, 6, 16, 5, 17, 4, 16, 4, 10],   //i
	  [6, 10, 7, 10, 8, 15, 8, 16, 7, 16, 6, 11],  //l
	  [4, 10, 4, 11, 3, 16, 2, 16, 2, 15, 3, 10],  //m
	  [2, 2, 3, 2, 4, 7, 4, 8, 3, 8, 2, 3],        //j
	  [8, 2, 8, 3, 7, 8, 6, 8, 6, 7, 7, 2],        //k
	  [5, 1, 6, 2, 6, 8, 5, 9, 4, 8, 4, 2],        //h
	  [9, 17, 8, 18, 6, 18, 5, 17, 6, 16, 8, 16],  //d2
	  [1, 1, 2, 0, 4, 0, 5, 1, 4, 2, 2, 2],        //a1
	  [9, 1, 10, 2, 10, 8, 9, 9, 8, 8, 8, 2],      //b
	  [1, 9, 0, 8, 0, 2, 1, 1, 2, 2, 2, 8],        //f
	  [1, 9, 2, 8, 4, 8, 5, 9, 4, 10, 2, 10],      //g1
	  [5, 9, 6, 8, 8, 8, 9, 9, 8, 10, 6, 10],      //g2
	  [1, 17, 0, 16, 0, 10, 1, 9, 2, 10, 2, 16],   //e
	  [9, 9, 10, 10, 10, 16, 9, 17, 8, 16, 8, 10], //c
	  [5, 17, 4, 18, 2, 18, 1, 17, 2, 16, 4, 16],  //d1
	  []
      ],
      width: 10,
      height: 18,
      hgap: 2,
      vgap: 2,

      //ascii_map originally from https://ketturi.kapsi.fi/2013/08/vfd-schematics-code-witchcraft/
      ascii_map: [
	  0b0000000000000000 , //NUL Null \0 ^@      (null charter, but shows as empty block dunno)
	  0b1111111111111111 , //can be used like test charter lighting all segments
	  0b0000000000000000 , 
	  0b0000000000000000 , 
	  0b0000000000000000 ,
	  0b0000000000000000 , 
	  0b0000000000000000 , //ACK Acknowledge     (send for data successfully received)
	  0b0000000000000000 , //BEL  Bell \a ^G     (make audible notification for email etc)
	  0b0000000000000000 , //BS Backspace \b ^H  (remove last charter from textBuffer)
	  0b0000000000000000 , 
	  0b0000000000000000 , //LF Linefeed \n ~J   (clear textBuffer)
	  0b0000000000000000 , 
	  0b0000000000000000 , //FF Formfeed \f ^L   (clear textBuffer, for compatibly)
	  0b0000000000000000 , //CR Carriage return \r ^M (Return "cursor" to first digit)
	  0b0000000000000000 , 
	  0b0000000000000000 , 
	  0b0000000000000000 , 
	  0b0000000000000000 , //DC1 Device control (Turn leds on/off or sumthing)
	  0b0000000000000000 , //DC2
	  0b0000000000000000 , //DC3
	  0b0000000000000000 , //DC4
	  0b0000000000000000 , //NAK neg. acknowledge (Houston, we have problem)
	  0b0000000000000000 , 
	  0b0000000000000000 , 
	  0b0000000000000000 , 
	  0b0000000000000000 , 
	  0b0000000000000000 , 
	  0b0000000000000000 , //ESC Escape \e ^[     (dunno, not needed)
	  0b0000000000000000 ,  
	  0b0000000000000000 , 
	  0b0000000000000000 , 
	  0b0000000000000000 , 
	  0b0000000000000000 , //" " space or empty block
	  0b0100001010000000 , //"!"
	  0b0000010001000000 , //"
	  0b1101101011000010 , //#
	  0b1101110111000011 , //$
	  0b0100010000101000 , //%
	  0b1110100111010100 , //&
	  0b0000000000100000 , //'
	  0b0000000000100100 , //(
	  0b0000000000011000 , //)
	  0b0001100001111110 , //*
	  0b0001100001000010 , //+
	  0b0000000000001000 , //,
	  0b0001100000000000 , //-
	  0b0000000010000000 , // "." 
	  0b0000000000101000 , // "/"
	  0b1110011110101001 , //"0" 
	  0b0100001000000000 , //"1"
	  0b1011101110000001 , //2
	  0b1101101110000001 , //3
	  0b0101111000000000 , //4
	  0b1101110110000001 , //5
	  0b1111110110000001 , //6
	  0b0100001100000001 , //"7"
	  0b1111111110000001 , //8
	  0b1101111110000001 , //"9"
	  0b0000000010000001 , //:
	  0b0000000001001000 , //;
	  0b1000000010100100 , //<
	  0b1001100010000000 , //=
	  0b1000000010011000 , //>
	  0b0001001100000011 , //"?"
	  0b1110101110000011 , //@
	  0b0111111100000001 , //"A"
	  0b1101001111000011 , 
	  0b1010010110000001 ,//"C" 
	  0b1100001111000011 , 
	  0b1010110110000001 , 
	  0b0010110100000001 , //"F"
	  0b1111010110000001 , 
	  0b0111111000000000 , 
	  0b1000000111000011 , 
	  0b1110001010000000 , 
	  0b0010110000100100 , //"K"
	  0b1010010010000000 , 
	  0b0110011000110000 , 
	  0b0110011000010100 , 
	  0b1110011110000001 , 
	  0b0011111100000001 , 
	  0b1110011110000101 , 
	  0b0011111100000101 , 
	  0b1101000110010001 , 
	  0b0000000101000011 , 
	  0b1110011010000000 , 
	  0b0010010000101000 , 
	  0b0110011000001100 , 
	  0b0000000000111100 , 
	  0b0000000000110010 , 
	  0b1000000110101001 , //"Z"
	  0b1010010100000000 , //[
	  0b0000000000010100 , // \ '\\'
	  0b0100001010000001 , // ]
	  0b0000000000001100 , // ^
	  0b1000000010000000 , // _
	  0b0000000000010000 , // `
	  0b1010100010000010 , //"a"
	  0b1010110010000100 , 
	  0b1011100010000000 , 
	  0b1101001010001000 , 
	  0b1010100000001000 , //"e"
	  0b0010110100000000 , 
	  0b1101001010100000 , 
	  0b0010110000000010 , 
	  0b0000000000000010 ,//"i"
	  0b0100000010000000 , 
	  0b0000000001100110 , 
	  0b0010010000000000 , 
	  0b0111100000000010 ,//m
	  0b0010100000000010 , 
	  0b1111100010000000 , 
	  0b0010110000010000 , 
	  0b0101001000100000 , 
	  0b0010100000000000 , 
	  0b0001000010000100 ,//s
	  0b0001100011000010 , 
	  0b1110000010000000 , 
	  0b0100000000000100 , 
	  0b0110000000001100 , 
	  0b0001100000001100 , 
	  0b0100000010000100 , 
	  0b1000100000001000 , //"z"
	  0b1000100110011001 , // {
	  0b0000000001000010 , // |
	  0b1001000110100101 , // }
	  0b0000010000110000 , // ~
	  0b1111111101111110 ] //DEL    (also not needed, ignored charter"
    }

function print_non_unique()
{
    for(i = 0; i < segchar16.ascii_map.length; i++)
    {
	for(j = i+1; j < segchar16.ascii_map.length; j++)
	{
	    if(segchar16.ascii_map[i] == segchar16.ascii_map[j])
		console.log("equal %d %d",i,j)
	}
    }
}

//print_non_unique();


// above automatically copied from sixteenSeg.js
</script>
    <script>
// automatically copied from align.js
(function(window){

    'use strict';
    function define_align(){
        var Align = {};
        Align.create_box = function(g,p)
	{
	    var g = g;

	    var box = {};
	    
	    if(p.w == null && p.h == null)
	    {
		var bbox = p.o.getBBox();
		box.w = bbox.w;
		box.h = bbox.h;
	    }
	    else if (p.w == null)
	    {
		//console.log(p);
		var bbox = p.o.getBBox();
		box.w = bbox.w;
		box.h = p.h;
	    }
	    else if (p.h == null)
	    {
		var bbox = p.o.getBBox();
		box.h = bbox.h;
		box.w = p.w;
	    }
	    else
	    {
		box.w = p.w;
		box.h = p.h;
	    }

	    box.x = p.x || 0;
	    box.y = p.y || 0;

	    box.o = p.o;

	    box.transform_to_box = 
		function(p)
	    {
		var group;

		var nx,ny;
		var nw,nh;

		var scale=1;
		if(p.w != null && p.h != null)
		{
		    scale = Math.min(p.w/box.w,p.h/box.h);
		}
		else if(p.h != null)
		{
		    scale = p.h/box.h;
		}
		else if(p.w != null)
		{
		    scale = p.w/box.w;
		}
		
		nx = p.x || 0;	
		ny = p.y || 0;
		nw = box.w * scale;
		nh = box.h * scale;

		if(box.o )  //if not an empty box
		{
		    //since the element may have already been transformed, we need to use a group
		    //and add the element to it. Otherwise, the original transformation is reset
		    group = g.g(box.o);

		    //console.log("x %f y %f s %f",transX, transY, scale);
		    //console.log(box,p);
		    
		    group.transform(new Snap.matrix().translate(nx,ny).
				    scale(scale));
		}

		// console.log(box,p);
		// console.log("nx %f ny %f nw %f nh %f s %f",nx,ny,nw,nh,scale);
		
		return Align.create_box(g,{ o: group,
					    x: nx,
					    y: ny,
					    w: nw,
					    h: nh});
	    }
	    
	    return box;
        }

	Align.valign = function()
	{
	    var g = arguments[0];

	    var max_width = 0;
	    for(var i = 1; i < arguments.length; i++)
	    {
		if(arguments[i].w > max_width)
		    max_width = arguments[i].w;
	    }

	    var curr_y = 0;

	    var group = g.g();

	    for(var i = 1; i < arguments.length; i++)
	    {
		var box = arguments[i];
		//console.log(box);
		var box = box.transform_to_box({ x: max_width/2 - box.w/2, y: curr_y} );
		curr_y += box.h;
		if(box.o)
		    group.add(box.o);
	    }

	    return Align.create_box(g, { o: group, w: max_width, h: curr_y });
	}
	
	Align.halign = function()
	{
	    var g = arguments[0];

	    var max_height = 0;
//	    console.log(arguments);
	    for(var i = 1; i < arguments.length; i++)
	    {
		if(arguments[i].h > max_height)
		    max_height = arguments[i].h;
	    }

	    var curr_x = 0;

	    var group = g.g();
	    
	    for(var i = 1; i < arguments.length; i++)
	    {
		var box = arguments[i];
		var box = arguments[i].transform_to_box({ x: curr_x, y: max_height/2 - box.h/2 });
		curr_x += box.w;
		if(box.o)
		    group.add(box.o);
	    }

	    return Align.create_box(g, { o: group, w: curr_x, y: max_height });
	}
	

        return Align;
    }

    //define globally if it doesn't already exist
    if(typeof(Align) === 'undefined'){
        window.Align = define_align();
    }
    else{
        console.log("Align already defined.");
    }
})(window);

// above automatically copied from align.js
</script>
    <script>
// automatically copied from rng.js

var redfish64 = { };

//stolen from bitaddress.org TODO 2 give attrition


//the sjcl mouse collector is really weird. It will allow a non-moving static mouse to be considered
//as "random" movement
redfish64.seeder = {
    lastInputTime: new Date().getTime(),
    seedPoints: [],
    isStillSeeding: false,
 
    start: function() {
	if (window.addEventListener) {
	    window.addEventListener("mousemove", redfish64.seeder._seed, false);
	} else if (document.attachEvent) {
	    document.attachEvent("onmousemove", redfish64.seeder._seed);
	} else {
	    throw new sjcl.exception.bug("can't attach event");
	}
  //	console.log("stART!!");
    },

    onfinish: function(f) {
	redfish64.seeder.onfinish = f;
    },

    _seed: function (evt) {
	if(sjcl.random.isReady())
	{
	    redfish64.seeder.seedingOver();
	    return;
	}
	
	timeStamp = new Date().getTime();
	if (!evt) var evt = window.event;

	var x = evt.x || evt.clientX || evt.offsetX || 0;
	var y = evt.y || evt.clientY || evt.offsetY || 0;
	
	if (evt && (timeStamp - redfish64.seeder.lastInputTime) > 40)
	{
	    //console.log(x,y)
	    sjcl.random.addEntropy([x, y], 2, "mouse");
	    redfish64.seeder.showPoint(redfish64.seeder.lastX= x, redfish64.seeder.lastY=y);
	    redfish64.seeder.lastInputTime = timeStamp;
	}
    },

    showPoint: function (x, y) {
	var div = document.createElement("div");
	div.setAttribute("class", "seedpoint");
	div.style.top = y + "px";
	div.style.left = x + "px";
	document.body.appendChild(div);
	redfish64.seeder.seedPoints.push(div);
    },

    removePoints: function () {
	for (var i = 0; i < redfish64.seeder.seedPoints.length; i++) {
	    document.body.removeChild(redfish64.seeder.seedPoints[i]);
	}
	redfish64.seeder.seedPoints = [];
    },

    seedingOver: function () {
	if (window.removeEventListener) {
	    window.removeEventListener("mousemove", redfish64.seeder._seed, false);
	} else if (document.detachEvent) {
	    document.detachEvent("onmousemove", redfish64.seeder._seed);
	}
	redfish64.seeder.removePoints();
	redfish64.seeder.onfinish();
    }
};

// above automatically copied from rng.js
</script>
    <script>

var s1;
var s2;
var g1,g2;

var segchar = segchar16;

var rows = 10;
var cols = 30;
var charh = 8;
var charw = 5;

var otp_bits = [];

var font = console_font_5x8;

var min_force_wrap = 5;
var max_force_wrap = 100;

// WARNING: this is taken from the svg width and height below:
//	  <svg id="p" width="..." height="...">
// Keep them in sync.
var data_pane_ratio = 6.5568669528 / 7.41323;

// WARNING: this is taken from the svg width and height below:
//	  <svg id="pg" width="..." height="...">
// Keep them in sync.
var grid_data_pane_ratio=7/9.5;

//pattern color for code in first page
var g1_pat_color = "#404040";

//pattern color for code in second page
var g2_pat_color = "#000000";

var pat_scales = [
    1,
];

//draw_ascii_table_for_seg
var ascii =
    {
	char_height: 10,
	line_height: 12,
	col_gap: 8,
	inner_gap: 3,
	max_rows: 47,
	//94 chars
	char_start: 33, // "!";
	char_end: 126, // "~";
	left_margin: 10
    };


function path_rect(x,y,w,h)
{
    return "M "+x+" "+y+
	"L "+(x+w)+" "+y+
	"L "+(x+w)+" "+(y+h)+
	"L "+x+" "+(y+h)+
	"L "+x+" "+y;
}

function draw_grid(g,bits,width)
{
    if(bits.length == 0 || width == 0)
	return;
    
    //we use a dyanamically generated path to mark pixels. I was thinking about using a 
    //bitmap and scaling it in the SVG but this seems flaky cross browsers. At least one example of doing
    //so didn't work right in my browser (google chrome 49 on linux).

    var height = bits.length/width;

    //console.log("w %d h %d",width, height);
    //console.log(bits.length);

    g.attr({viewBox:[0,0,width,height].join(' '),
    	     });

    var path="";

    var filled_cells_in_line=0;
    var filled_lines=0;

    var create_rects_for_bits_fn =
	function(filled_lines, filled_cells_in_line) {
	    //draw last rectangle
	    if(filled_lines > 0)
	    {
		path += (path_rect(0,y-filled_lines,width,filled_lines));
	    }
	    //draw the current set of filled cells
	    if(filled_cells_in_line != 0)
	    {
		path += (path_rect(x-filled_cells_in_line,y,filled_cells_in_line,1));
	    }
	};

    for(y=0;y<height;y++)
    {
	for(x=0;x<width;x++)
	{
	    if(!bits[y*width+x])
	    {
		//console.log("true value %d %d",x,y)
		create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
		filled_lines = 0;
		filled_cells_in_line = 0;
	    }
	    else
	    {
		filled_cells_in_line ++;
	    }
	}

	//at the end of the line, check if all were filled
	if(filled_cells_in_line == width)
	{
	    filled_lines ++;
	    filled_cells_in_line = 0;
	}
	else
	{
	    //draw the bits for the previous filled lines
	    create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
	    filled_lines = 0;
	    filled_cells_in_line = 0;
	}
    }

    //create_rects_for_bits_fn(filled_lines,filled_cells_in_line);

    return g.path(path);
}

function create_seg_path(x,y,coords)
{
    var path = "M ";
    for(var i = 0; i < coords.length; i+=2)
    {
	path += (x+coords[i])+" "+(y+coords[i+1])+" ";
    }
    path += (x+coords[0])+" "+(y+coords[1])+" ";

    return path;
}

function create_seg_bit_char(x,y,seg,bitval)
{
    var path = "";
    for(var bit = 0; bit < seg.bit_count; bit++)
    {
	var on = (1&(bitval >> bit)) == 1;
	if(on) path += create_seg_path(x,y,seg.coords[bit]);
    }

    return path;
}

function create_seg_ascii_char(x,y,seg,ascii_index)
{
    return create_seg_bit_char(x,y,seg,seg.ascii_map[ascii_index]);
}

function draw_segchar(g,bits,chars_per_line,patterns, off_patterns, segchar)
{
    if(bits.length == 0 || chars_per_line == 0)
	return;

    var width = chars_per_line * segchar.width + (chars_per_line - 1) * segchar.hgap;
    var chars_per_col = bits.length / (chars_per_line*segchar.bit_count);
    var height = chars_per_col * segchar.height+ (chars_per_col - 1) * segchar.vgap;

    //console.log("w %d chars_per_col %f chars_per_line %d height %d",width,chars_per_col,chars_per_line, height);
    
    var group = g.g();
    
    for(var r=0;r<chars_per_col;r++)
    {
	var path="";
	var off_path=""; //the bits that aren't highlighted

    	for(var c=0;c<chars_per_line;c++)
    	{
    	    var x = c*(segchar.width+segchar.hgap);
    	    var y = r*(segchar.height+segchar.vgap);

    	    for(var i=0; i < segchar.bit_count; i++)
    	    {
		//console.log("bl: %d v: %d",bits.length,(r*chars_per_line+c)*segchar.bit_count + i);
    		if(bits[(r*chars_per_line+c)*segchar.bit_count + i])
    		{
    		    path += create_seg_path(x,y,segchar.coords[i]);
    		}
		else
		    off_path += create_seg_path(x,y,segchar.coords[i]);
    	    }
    	}
	
	var pi = r % patterns.length;
	var pattern = patterns[pi];

	var sc = g.path(path);
	sc.attr({ fill: pattern });

	g.add(sc);

	var off_pattern = off_patterns[pi];

	var off_sc = g.path(off_path);
	off_sc.attr({ fill: off_pattern });

	g.add(off_sc);
    }

    //console.log(path);

    //we return the width and height explicitly (rather than letting the user run getBBox() on
    //sc, because getBBox() is kind of slow.
    return { elem: g,
	     w: width,
	     h: height
	   };
    
}

function test5x8()
{
    console.log("Testing 5x8!");
    for(var i=0; i < console_font_5x8.length; i += 8)
    {
	for(var j=i+8; j < console_font_5x8.length; j += 8)
	{
	    var diff = 0;
	    for(var k=0;k<8; k++)
	    {
		if(console_font_5x8[i+k] != console_font_5x8[j+k])
		{
		    diff = 1;
		    break;
		}
	    }
	    if(diff == 0)
	    {
		console.log("Chars the same! "+(i/8)+","+(j/8));
	    }
	}
    }
}

			     
window.onload = function()
{
    sjcl.random.setDefaultParanoia(10);
    show_page("mainarea");
    
    g1 = Snap("#s1");

    g2 = Snap("#s2");

    input_changed();
    test5x8();
    //console.log("whatisready?",(new sjcl.prng(10)).getProgress(10));
}

function calc_rows(t, force_wrap)
{
    var rows = 1;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	var c = t.charAt(i);
	if(c == '\n')
	{
	    rows++;
	    col = 0;
	}
	else
	{
	    if(col >= force_wrap)
	    {
		rows++;
		col=0;
	    }
	    col++;
	}
    }

    return rows-(col == 0 ? 1 : 0);
}

function choose_force_wrap(t, font_width_over_height, page_ratio)
{
    var i;
    
    //We want to maximize the dpi considering a standard size page (8.5 x 11), the
    //font width and height, and assuming square pixels
    var last_rows = 0;
    for(i = max_force_wrap;i>=min_force_wrap; i--)
    {
	var rows = calc_rows(t,i);

	//if we haven't gained any more rows by reducing the force wrap, then
	//we keep going. Otherwise, if we go below the page_ratio, we stop
	if(rows != last_rows && i * font_width_over_height / rows < page_ratio)
	    break;

	last_rows = rows;
    }

    //console.log("force wrap %s %d %d %d", t, i+1, calc_rows(t,i), calc_rows(t,i+1));
    
    return i+1;
}

function create_message_for_grid(t)
{
    var message = { text: "",
		    bits: [],
		    force_wrap: null,
		    rows: null,
		    width: null
		  };
    
    message.force_wrap = choose_force_wrap(t, charw/charh, grid_data_pane_ratio);
    message.width = message.force_wrap * charw; //width always is force_wrap * charw
    //it's just for convenience
    
    //assumes 5x8 and writes t into bits
    message.text=t;
    message.bits = [];

    //console.log(message);

    var row = 0;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	//go through each line of character, horizontally
	
	// ex:
	// /* code=65, hex=0x41, ascii="A"
	//  */
	// 0x00,  /* 00000 */
	// 0x00,  /* 00000 */
	// 0x60,  /* 01100 */
	// 0x90,  /* 10010 */
	// 0xF0,  /* 11110 */
	// 0x90,  /* 10010 */
	// 0x90,  /* 10010 */
	// 0x00,  /* 00000 */

	var c = t.charCodeAt(i);
	if(c == 10) //newline
	{
	    col = 0;
	    row++;
	    continue;
	}

	if(col >= message.force_wrap)
	{
	    col = 0;
	    row++;
	}
	
	var cr = c*charh;

	var bitx = col * charw;
	var bity = row * charh;

	//we expand the buffer so it's always rectangular
	message.bits[(bity+charh)*message.width-1] = false;
	
	//console.log("bitx "+bitx+" bity "+bity)
	for(var bitline = 0; bitline < charh; bitline++)
	{
	    for(var bit = 0; bit < charw; bit++)
	    {
		var on = (1&(font[cr+bitline] >> (7 - bit))) == 1;
		//console.log("bitline "+bitline+" font "+font[cr+bitline]+" bit "+bit+" on "+on)
		var bit_index = bitx + bit + (bity + bitline) * message.width;
		message.bits[bit_index] = on;
	    }
	}

	col++;
    }

    message.rows = row+1-(col == 0 ? 1 : 0);

    //console.log("rows %d cr %d fw %d text %s ", message.rows,calc_rows(t,message.force_wrap),message.force_wrap,t);

    return message;
}

function create_message_for_seg(t,seg)
{
    var message = { text: "",
		    bits: [],
		    force_wrap: null,
		    rows: null
		  };
    
    message.force_wrap = choose_force_wrap(t,(seg.width+seg.hgap)/(seg.height+seg.vgap), data_pane_ratio);
    
    message.text=t;
    message.bits = [];

    var row = 0;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	var c = t.charCodeAt(i);
	if(c == 10) //newline
	{
	    if(col != 0)
	    {
		col = 0;
		row++;
	    }
	    continue;
	}
	if(col >= message.force_wrap)
	{
	    col = 0;
	    row++;
	}

	//console.log("col %d row %d", col, row);
	//we expand the buffer so it's always rectangular
	message.bits[(row+1)* seg.bit_count * message.force_wrap - 1] = false;
	
	var bitval = seg.ascii_map[c];
	var bitindex = (row * message.force_wrap + col) * seg.bit_count;
	
	for(var bit = 0; bit < seg.bit_count; bit++)
	{
	    var on = (1&(bitval >> bit)) == 1;
	    message.bits[bitindex+bit] = on;
	}

	col++;
    }

    message.rows = row+1-(col == 0 ? 1 : 0);

    return message;
}

function xor_bits(b1,b2)
{
    var o = [];
    o[(b1.length < b2.length ? b2.length : b1.length) - 1] = false;
    //console.log("b1 "+b1.length)
    //console.log("b2 "+b2[0])
    
    for(i = 0; i < o.length; i++)
    {
	o[i] = (b1[i] && !b2[i] || !b1[i] && b2[i]);
	// !(b1[i] == b2[i]); doesn't work???
    }

    return o;
}

function not_bits(b)
{
    var o = [];
    o[b.length - 1] = false;
    
    for(i = 0; i < o.length; i++)
    {
	o[i] = !b[i];
    }

    return o;
}

function decimalToHexString(number)
{
    if (number < 0)
    {
    	number = 0xFFFFFFFF + number + 1;
    }

    return number.toString(16).toUpperCase();
}

function hex2bin(hex,length)
{
    var bits = [], str;

    //HACK to make sure we got 8 random bits per byte
    // var bits1 = [], bits0 = [];

    for(var i=0; i<hex.length-1; i+=2)
    {
	var v = parseInt(hex.substr(i, 2), 16);

	for(var j=0;j<8;j++)
	{
	    bits[bits.length] = ((v&(1<<j)) != 0);
	    // if(bits[bits.length-1])
	    // {
	    // 	bits1[j] = true;
	    // }
	    // else
	    // 	bits0[j] = true;

	    if(bits.length >= length)
	    {
		i = hex.length;
		break;
	    }
	}
    }

    // for(var j = 0; j < 8; j++)
    // {
    // 	if(!bits1[j])
    // 	{
    // 	    console.log("%d NEVER 1!!!",j);
    // 	}
    // 	if(!bits0[j])
    // 	    console.log("%d NEVER 0!!!",j);
    // }

    return bits;
}

function finish_generate_seed()
{
    sjcl.random.stopCollectors();

    var input = document.getElementById('msg').value;

    //add extra OTP incase they increase the message size
    var bits = Math.max((input.length * segchar.bit_count) * 4, 40*segchar.bit_count);

    //get the random data into our wasteful but convienent boolean array format
    var random_data = sjcl.random.randomWords(Math.ceil(bits/32));
    
    var otp = "";
    for(var bytei = 0; bytei < random_data.length; bytei++)
    {
	otp += decimalToHexString(random_data[bytei]);
    }

    document.getElementById('otp').value = otp;
    

    show_page("mainarea");
    
    input_changed();
}

function update_paranoia_percent()
{
    //console.log("update_paranoia_percent",sjcl.random.getProgress(), sjcl.random.isReady());
    document.getElementById('paranoia_perc').innerHTML =
	"Move mouse around to generate random data... Paranoia "+
	(sjcl.random.getProgress()*100)+"%";

    //I know that a value of 2 corresponds to sjcl.random._NOT_READY, but according to:
    //https://github.com/bitwiseshiftleft/sjcl/wiki/Symmetric-Crypto
    //it still means it is ready.
    if(!sjcl.random.isReady()) 
	setTimeout(update_paranoia_percent,500);
}


function clear_fields()
{
    var input = document.getElementById('msg').value = "";
    var otp = document.getElementById('otp').value = "";
    
    input_changed();
}

function generate_seed()
{
    if(!sjcl.random.isReady())
    {
	show_page("generatearea")
	
	redfish64.seeder.onfinish(finish_generate_seed);
	redfish64.seeder.start();
	
	setTimeout(update_paranoia_percent,500);
    }
    else
	finish_generate_seed();
}

function create_otp_bits(length)
{
    var bits = hex2bin(document.getElementById('otp').value,length);

    return bits;
}

function get_mode()
{
    var radios = document.getElementsByName('mode');
    for (var i = 0, length = radios.length; i < length; i++) {
	if (radios[i].checked) {
            return radios[i].value;
	}
    }
}

function is_grid_mode()
{
    var mode = get_mode();
    return mode != "sixteenseg";
}

function update_print_buttons(message)
{
    var input = document.getElementById('msg').value;
    var otp = document.getElementById('otp').value;

    var otp_bits = otp.length * 4;

    var input_bits_needed = message ? message.force_wrap * message.rows *
	(is_grid_mode() ?  charw * charh : segchar.bit_count) : 0;

    var error = "";
    if(input.length == 0 && otp.length==0)
    {
	error = "Please enter a message and create otp (one time pad) random data";
    }
    else if(input.length == 0)
    {
	error = "Please enter a message.";
    }
    else if(otp.length == 0)
	error = "Please enter OTP (one time pad) data or click 'Generate OTP'.";
    else if (otp_bits < input_bits_needed)
    {
	//console.log(otp_bits, input_bits_needed);
	error = "Need at least "+Math.ceil((input_bits_needed-otp_bits)/8)+" more OTP bytes. Please enter more OTP (one time pad) data or click 'Generate OTP'.";
    }
    

    if(error != "")
    {
	document.getElementById('print_s1').disabled=true;
	document.getElementById('print_s2').disabled=true;
    }
    else
    {
	error = "Press \"Print!\" to print each page. For extra security, print each page to separate printer.";
	document.getElementById('print_s1').disabled=false;
	document.getElementById('print_s2').disabled=false;
    }

    document.getElementById('error').innerHTML = error;
}

var otp_regex=/[^0-9A-Fa-f]+/g;

function otp_changed()
{
    var otp = document.getElementById('otp');

    otp.value = otp.value.replace(otp_regex,'');

    input_changed();
}

function input_changed()
{
    var input = document.getElementById('msg').value;

    var is_grid = is_grid_mode();
    
    if(g1 && g2)
    {
	g1.clear();
	g2.clear();
	if(input.length == 0)
	{
	    update_print_buttons(null);
	    return;
	}
	
	var g1_patterns = get_patterns(g1, is_grid, g1_pat_color, 1);
	var g1_off_patterns = get_patterns(g1, is_grid, g1_pat_color, 2);
	var g2_patterns = get_patterns(g2, is_grid, g2_pat_color, 2);
	var g2_off_patterns = get_patterns(g2, is_grid, g2_pat_color, 1);

	var message;
	if(is_grid)
	{
	    message = create_message_for_grid(input);
	    var otp_bits = create_otp_bits(message.bits.length);
	    var g1_bits = xor_bits(message.bits, otp_bits);
	    var g2_bits = not_bits(otp_bits);
	    
	    draw_grid(g1,g1_bits, message.width).
		attr({ fill: g1_patterns[0] });
	    draw_grid(g1,not_bits(g1_bits), message.width).
	    	attr({ fill: g1_off_patterns[0] });

	    if(g2_bits.length != 0)
	    {
		draw_grid(g2,g2_bits, message.width).
		    attr({ fill: g2_patterns[0] });
		draw_grid(g2,not_bits(g2_bits), message.width).
		    attr({ fill: g2_off_patterns[0] });
	    }
	}
	else //if(mode == "sixteenseg")
	{
	    message = create_message_for_seg(input, segchar);
	    var otp_bits = create_otp_bits(message.bits.length);
	    var g1_bits = xor_bits(message.bits, otp_bits);
	    // message.bits;
	    var g2_bits = not_bits(otp_bits);
	    //console.log(message);
	    
	    var sc1 = draw_segchar(g1,g1_bits, message.force_wrap,
				   g1_patterns, g1_off_patterns, segchar
				  );

	    if(sc1)
		g1.attr({viewBox:[0,0,sc1.w,sc1.h].join(' '),
    		 	   //preserveAspectRatio: "none"
    			  });
		
		
	    var sc2 = draw_segchar(g2,g2_bits, message.force_wrap,
				   g2_patterns, g2_off_patterns, segchar);
	    if(sc2)
		g2.attr({viewBox:[0,0,sc2.w,sc2.h].join(' '),
    		 	   //preserveAspectRatio: "none"
    			  });
		
	}
	update_print_buttons(message);
    }
}


function draw_ascii_table_for_seg(g,seg,pattern)
{
    var max_char_width = 1;
    var group = g.g();
    var col = -1;

    var hgap_box = Align.create_box( g, { w: ascii.inner_gap, h: 0} );

    var col_width = 0;

    for(var i = ascii.char_start;
	i <= ascii.char_end;
	i++)
    {
	if((i-ascii.char_start) % ascii.max_rows == 0)
	    col++;
	    
	var char_path = create_seg_ascii_char(0,0, seg, i);

	var path = g.path(char_path);
	path.attr({ fill:
		 g1_pat_color})

	var path_box = Align.create_box(g, { o: path, w: seg.width, h: seg.height }).
	    transform_to_box( { h: ascii.char_height });
	
	var text = g.text(0, ascii.char_height,
			  String.fromCharCode(i));
	text.attr("font-size",ascii.char_height);

	var text_box = Align.create_box(g, { o: text
					     //h: ascii.char_h
					   });

	// var rect_box1 = Align.create_box(g, { o: g.rect(0,0,text_box.w,text_box.h).
	// 				      attr({fill: "#FF0000"}) });
	// var rect_box2 = Align.create_box(g, { o: g.rect(0,0,text_box.w,text_box.h).
	// 				     attr({fill: "#00FF00"})});

	//note for the zeroth column, first row, text_width is zero, but this
	//doesn't matter cause col is zero, too
	var x = ascii.left_margin + col * (col_width + ascii.col_gap);
	var y = ((i-ascii.char_start)%ascii.max_rows) * ascii.line_height;

	//console.log("pt");
	//console.log(path_box,text_box);

	var composite_box = Align.halign(g, path_box, hgap_box, text_box).
	    transform_to_box({ x: x, y: y });

	col_width = Math.max(col_width, composite_box.w);

	group.add(composite_box.o);
    }

    return Align.create_box(g,{ o: group,
				x: 0,
				y: 0,
				w: ascii.left_margin + (col+1)*(col_width+ascii.col_gap),
				h: ascii.max_rows * ascii.line_height
			      });
}

function reverse_pattern(g, p)
{
    var group = g.g(g.rect(0,0,1,1),p.clone().attr("fill","#FFFFFF"));

    return group;
}

function get_patterns(g,is_grid, color, pn)
{
    var pat1,pat2,pat_scales;

    if(is_grid)
    {
	pat1 = [
	    g.path("M 0 0 L 1 1 L 0 1 L 0 0"),
	];
	
	pat2 = [
	    null,
	];
	
	pat_scales = [
	    .5,
	];
    }
    else
    {
	pat1 = [
	    g.path("M 0 0 L 1 1 L 0 1 L 0 0"),
	];
	
	pat2 = [
	    null,
	];
	
	pat_scales = [
	    1,
	];
    }

    var patterns = [];

    for(var i = 0; i < pat1.length; i++)
    {	
	var p1 = pat1[i];
	var p2 = pat2[i];
	
	if(p1 == null)
	{
	    p1 = reverse_pattern(g,p2);
	}
	else if(p2 == null)
	{
	    p2 = reverse_pattern(g,p1);
	}
	
	p1.toDefs();
	p2.toDefs();

	var raw_pat = pn == 1 ? p1 : p2;
    
	var patbasis = raw_pat.attr({ fill: color }).transform("scale("+pat_scales[i]+")");
	patterns[i] = patbasis.toPattern(0,0,pat_scales[i],pat_scales[i]);
    }

    return patterns;
}


function show_page(name)
{
    var pages = ["mainarea","printarea","generatearea","printareagrid"];

    for(var i = 0; i < pages.length; i++)
    {
	document.getElementById(pages[i]).style.display = (pages[i] == name) ? "block" : "none";
    }
}

function print_page(pn)
{
    var input = document.getElementById('msg').value;
    var is_grid = is_grid_mode();
    
    var message = is_grid ?
	create_message_for_grid(input) :
	create_message_for_seg(input, segchar);

    var bits;
    if(pn == 1)
    {
	var otp_bits = create_otp_bits(message.bits.length);
	bits = xor_bits(message.bits, otp_bits);
    }
    else
	bits = not_bits(create_otp_bits(message.bits.length));

    if(is_grid)
    {
	show_page("printareagrid");
	var g = Snap("#pg");

	g.clear();
	
	var patterns,off_patterns;
	var patterns = get_patterns(g, is_grid, pn == 1 ? g1_pat_color : g2_pat_color, 1);
	var off_patterns = get_patterns(g, is_grid, pn == 1 ? g1_pat_color : g2_pat_color, 2);

	draw_grid(g, bits, message.width).
	    attr({ fill: patterns[0] });
	draw_grid(g, not_bits(bits), message.width).
	    attr({ fill: off_patterns[0] });

	window.print();
	show_page("mainarea");

    }
    else// if(mode == "sixteenseg")
    {
	show_page("printarea");
	var g = Snap("#p");

	g.clear();
	
	var patterns,off_patterns;
	patterns = get_patterns(g, false, pn == 1 ? g1_pat_color : g2_pat_color, 1);
	off_patterns = get_patterns(g, false, pn == 1 ? g1_pat_color : g2_pat_color, 2);
	
	if(pn == 2)
	{
	    var t = off_patterns;
	    off_patterns = patterns;
	    patterns = t;
	}

	var sc = draw_segchar(g,bits, message.force_wrap,
			      patterns, off_patterns, segchar
			     );
	g.attr({viewBox:[0,0,sc.w,sc.h].join(' '),
    		//preserveAspectRatio: "none"
    	       });

	
	if(pn == 1)
	{
	    var ag = Snap("#ascii_table");
	    
	    var at = draw_ascii_table_for_seg(ag,segchar, patterns[0]);
	    //console.log(at);

	    ag.attr({viewBox:[0,0,at.w,at.h].join(' '),
    		      preserveAspectRatio: "none"
    		   });
	}

	window.print();
	show_page("mainarea");

	//sc.elem.clear();
    }

}




</script>

    <style>
      textarea {
      width: 90%;
      }
      .print_button {
      float: right
      }
      .encoded_page {
      padding: 40px
      }
      .seedpoint { width: 6px; height: 6px; display: block; border-radius: 3px; background-color: #009900; position: absolute; z-index: 10; }
      .error { color: #FF0000; }

      .paranoia_perc {
      display: inline;
      white-space: nowrap;
      }
      .paranoia_label {
      display: inline;
      white-space: nowrap;
      }
      .copyright { font-size: 80%; clear: both; padding: 5px 0; }

      html *
      {
      font-family: sans-serif;
      }
    </style>

</head>

    <body>
    <div id="mainarea">
    <h1>Paper OTP</h1>
    <p>A paper based <a href="https://en.wikipedia.org/wiki/One-time_pad">one time pad</a> encoded message creator. Messages can decoded using only paper and a light source.</p>
    <p>This can be used as a way to reveal important passwords, etc. for friends/family, in case something happens to you, by giving each of the two pages to two people you trust. Both pages are needed to decode the message.</p>
    <p>Messages are created locally on your machine and not transmitted anywhere. MIT licensed. Source can be found <a href="https://github.com/redfish64/paper_otp">here</a>.</p>
    <br><br>
    <table>
    <!-- <tr><td colspan="4"> -->
    <!-- <input type="radio" name="mode" value="sixteenseg" checked="true" onclick="input_changed()">16 segment -->
    <!-- <input type="radio" name="mode" value="grid" onclick="input_changed()">Grid -->
    <!-- </td></tr> -->
    <tr>
    <td>Message
    <td width="50%"><textarea rows="5" placeholder="Enter message" autofocus="true" id="msg" onkeyup="input_changed()" onchange="input_changed()"></textarea>
    <td>OTP
    <td width="50%"><textarea rows="5" placeholder="Enter hexidecimal data or click 'Generate OTP'" id="otp"onkeyup="otp_changed()" onchange="otp_changed()"></textarea>
    </td>
    </tr>
    <tr>
      <td></td>
      <td>
      	<input type="button" value="Clear" onclick="clear_fields();">
      </td>
      <td></td>
      <td>    
	<input type="button" value="Generate OTP" onclick="generate_seed();">
      </td>
    </tr>
    </table>
    <p id="error" class="error">Have a nice day</p>
    <table>
    <tr>
    <td class="encoded_page">
    Encoded Page 1 <input class="print_button" type="button" disabled="true" onclick="print_page(1)" id="print_s2" value="Print!" />
    <br>
    <svg width="400" height="500" id="s1" />
    <br>
    </td>
    <td class="encoded_page">
    Encoded Page 2 <input class="print_button" type="button" disabled="true" onclick="print_page(2)" id="print_s1" value="Print!" />
    <br>
    <svg width="400" height="500" id="s2" />
    <br>
    </td></tr></table>
    <div class="copyright">
    <p>Written by Tim Engler with collaboration with Hib Engler.</p>
    <p>
      <span>Copyright rareventure.com.</span>
      <span>JavaScript copyrights are included in the source.</span>
      <span>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
	LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. </span></p>
    </div>
    </div>
    <div id="printarea">
    <table>
      <tr>
	<td>
	  <!-- WARNING, these values are copied above at
var data_pane_ratio = ....; 

Keep them in sync.
-->
	  <svg id="p" width="6.5568669528in" height="7.41323in">
	  </svg>
	</td>
	<td rowspan="2">
	  <svg id="ascii_table" width="0.6931330472in" height="9.5in">
	    <!-- <ellipse cx="0.3556866953in" cy="4.875in" rx="0.3556866953in" ry="4.875in" -->
	    <!-- 	     style="fill:green;stroke:red;stroke-width:2" /> -->
	    </svg>
	<td>
      </tr>
      <tr>
    <td>
    <!-- automatically copied from howto.svg -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:osb="http://www.openswatchbook.org/uri/2009/osb"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="6.8674755in"
   height="2.0867682in"
   viewBox="0 0 616.3537 187.28646"
   id="svg2"
   version="1.1"
   inkscape:version="0.91 r13725"
   sodipodi:docname="howto.svg"
   inkscape:export-filename="/home/user/howto.png"
   inkscape:export-xdpi="90"
   inkscape:export-ydpi="90">
  <defs
     id="defs4">
    <linearGradient
       id="linearGradient5962"
       osb:paint="solid">
      <stop
         style="stop-color:#000000;stop-opacity:1;"
         offset="0"
         id="stop5964" />
    </linearGradient>
    <linearGradient
       id="linearGradient5745"
       osb:paint="solid">
      <stop
         style="stop-color:#000000;stop-opacity:1;"
         offset="0"
         id="stop5747" />
    </linearGradient>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="1"
     inkscape:cx="269.73031"
     inkscape:cy="99.533698"
     inkscape:document-units="px"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1358"
     inkscape:window-height="712"
     inkscape:window-x="4"
     inkscape:window-y="25"
     inkscape:window-maximized="0"
     units="in"
     fit-margin-top="0.3"
     fit-margin-right="0.3"
     fit-margin-left="0.3"
     fit-margin-bottom="0.3" />
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(24.176872,8.4279584)">
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:51.83237839px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="324.88098"
       y="124.37766"
       id="text9341"
       sodipodi:linespacing="125%"
       transform="scale(1.0247149,0.97588119)"><tspan
         sodipodi:role="line"
         id="tspan9343"
         x="324.88098"
         y="124.37766">=</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:100.62888336px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="382.85492"
       y="147.0354"
       id="text9454"
       sodipodi:linespacing="125%"
       transform="scale(1.0247149,0.97588119)"><tspan
         sodipodi:role="line"
         id="tspan9456"
         x="382.85492"
         y="147.0354">W</tspan></text>
    <g
       id="segs-0"
       style="fill-rule:evenodd;stroke:#ffffff;stroke-width:0.25;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       transform="matrix(12.549287,0,0,12.549287,1.156166,299.28822)">
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="a1-2"
         points="2,2 1,1 2,0 4,0 5,1 4,2 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="a2-1"
         points="6,2 5,1 6,0 8,0 9,1 8,2 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#000000;fill-opacity:1"
         id="b-7"
         points="8,2 9,1 10,2 10,8 9,9 8,8 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#000000;fill-opacity:1"
         id="c-5"
         points="8,10 9,9 10,10 10,16 9,17 8,16 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="d1-1"
         points="8,16 9,17 8,18 6,18 5,17 6,16 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="d2-7"
         points="4,16 5,17 4,18 2,18 1,17 2,16 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#000000;fill-opacity:1"
         id="e-4"
         points="2,16 1,17 0,16 0,10 1,9 2,10 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#000000;fill-opacity:1"
         id="f-1"
         points="2,8 1,9 0,8 0,2 1,1 2,2 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="g1-7"
         points="2,10 1,9 2,8 4,8 5,9 4,10 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="g2-1"
         points="6,10 5,9 6,8 8,8 9,9 8,10 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="h-1"
         points="4,2 5,1 6,2 6,8 5,9 4,8 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="i-1"
         points="4,10 5,9 6,10 6,16 5,17 4,16 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="j-7"
         points="2,3 2,2 3,2 4,7 4,8 3,8 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#dddddd;fill-opacity:1"
         id="k-0"
         points="7,2 8,2 8,3 7,8 6,8 6,7 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#000000;fill-opacity:1"
         id="m-4"
         points="6,11 6,10 7,10 8,15 8,16 7,16 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <polygon
         style="fill:#000000;fill-opacity:1"
         id="l-0"
         points="3,10 4,10 4,11 3,16 2,16 2,15 "
         transform="matrix(0.44602691,0,0,0.42477107,21.191065,-19.441044)" />
      <text
         xml:space="preserve"
         style="font-style:normal;font-weight:normal;font-size:1.70512259px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
         x="-0.040499412"
         y="-21.079605"
         id="text4439"
         sodipodi:linespacing="125%"><tspan
           sodipodi:role="line"
           id="tspan4441"
           x="-0.040499412"
           y="-21.079605">Put second page under first and view in front of light</tspan></text>
    </g>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:39.88874435px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="46.835899"
       y="112.4603"
       id="text4449"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4451"
         x="46.835899"
         y="112.4603">Example:</tspan></text>
  </g>
</svg>

<!-- above automatically copied from howto.svg -->
    	</td>
      </tr>
    </table>
</div>

    <div id="printareagrid">
    <table>
    <tr><td>
	  <!-- WARNING, these values are copied above at
var grid_data_pane_ratio = ....; 

Keep them in sync.
-->
    <svg id="pg" width="7.00in" height="9.5in">
    </td>
    </tr>
    <tr><td>Please put second page underneath first page, and view in front of light</td></tr>
    </table>
      </svg>
    </div>
    
    <div id="generatearea">
    <h3><div id="paranoia_perc"></div></h3>
    </div>
    </body>
    
</html>
    



