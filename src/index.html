    <!doctype html>
    <html>
    <head>
    <meta charset="UTF-8">
    <title>Paper based OTP</title>
    <script src="snap.svg-min.js" />
    <script src="seedrandom.min.js"></script>
    <script src="rng.js"></script>
    <script src="5x8.js"></script>
    <script src="sixteenSeg.js"></script>
    <script>

var s1;
var s2;
var g1,g2;

var rows = 10;
var cols = 30;
var charh = 8;
var charw = 5;

var otp_bits = [];

var font = console_font_5x8;

var min_force_wrap = 5;
var page_ratio = 8.5/11;

var g1_pattern = "M 0 0 L 0 0.5 L 0.5 1 L 1 1 L 0 0 M 0.5 0 L 1 0.5 L 1 0 L 0.5 0";
var g1_color = "#808080";

var g2_pattern = "M 0 0 L 0.5 0 L 1 .5 L 1 1 L 0 0 M 0 0.5 L 0.5 1 L 0 1 L 0 0.5";
var g2_color = "#000000";
		  
		  


function create_grid(s)
{
    g = { s: s };

    return g;
}

function path_rect(x,y,w,h)
{
    return "M "+x+" "+y+
	"L "+(x+w)+" "+y+
	"L "+(x+w)+" "+(y+h)+
	"L "+x+" "+(y+h)+
	"L "+x+" "+y;
}

function redraw_grid(g,bits,width,pathtxt,color)
{
    g.s.clear();
    if(bits.length == 0 || width == 0)
	return;
    
    //we use a dyanamically generated path to mark pixels. I was thinking about using a 
    //bitmap and scaling it in the SVG but this seems flaky cross browsers. At least one example of doing
    //so didn't work right in my browser (google chrome 49 on linux).

    var height = bits.length/width;

    //console.log("w %d h %d",width, height);
    //console.log(bits);

    g.s.attr({viewBox:[0,0,width,height].join(' '),
    	      //preserveAspectRatio: "none"
    	     });
    // g.s.attr({viewBox:[0,0,100,100].join(' '),
    // 	      //preserveAspectRatio: "none"
    // 	     });

    var path="";

    var filled_cells_in_line=0;
    var filled_lines=0;

    var create_rects_for_bits_fn =
	function(filled_lines, filled_cells_in_line) {
	    //draw last rectangle
	    if(filled_lines > 0)
	    {
		path += (path_rect(0,y-filled_lines,width,filled_lines));
	    }
	    //draw the current set of filled cells
	    if(filled_cells_in_line != 0)
	    {
		path += (path_rect(x-filled_cells_in_line,y,filled_cells_in_line,1));
	    }
	};

    for(y=0;y<height;y++)
    {
	for(x=0;x<width;x++)
	{
	    if(!bits[y*width+x])
	    {
		//console.log("true value %d %d",x,y)
		create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
		filled_lines = 0;
		filled_cells_in_line = 0;
	    }
	    else
	    {
		filled_cells_in_line ++;
	    }
	}

	//at the end of the line, check if all were filled
	if(filled_cells_in_line == width)
	{
	    filled_lines ++;
	    filled_cells_in_line = 0;
	}
	else
	{
	    //draw the bits for the previous filled lines
	    create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
	    filled_lines = 0;
	    filled_cells_in_line = 0;
	}
    }

    create_rects_for_bits_fn(filled_lines,filled_cells_in_line);

    var patbasis = g.s.path(pathtxt).attr({ fill: color });
    var pattern = patbasis.toPattern(0,0,1,1);
    g.s.path(path).attr({ fill: pattern });
}

function create_seg_path(x,y,coords)
{
    var path = "M ";
    for(var i = 0; i < coords.length; i+=2)
    {
	path += (x+coords[i])+" "+(y+coords[i+1])+" ";
    }
    path += (x+coords[0])+" "+(y+coords[1])+" ";

    return path;
}

function draw_segchar(g,bits,chars_per_line,pathtxt,color, segchar)
{
    if(bits.length == 0 || chars_per_line == 0)
	return;

    var width = chars_per_line * segchar.width + (chars_per_line - 1) * segchar.hgap;
    var chars_per_col = bits.length / (chars_per_line*segchar.bit_count);
    var height = chars_per_col * segchar.height+ (chars_per_col - 1) * segchar.vgap;

    //console.log("w %d chars_per_col %f chars_per_line %d height %d",width,chars_per_col,chars_per_line, height);
    
    var path="";

    for(var r=0;r<chars_per_col;r++)
    {
    	for(var c=0;c<chars_per_line;c++)
    	{
    	    var x = c*(segchar.width+segchar.hgap);
    	    var y = r*(segchar.height+segchar.vgap);
    	    for(var i=0; i < segchar.bit_count; i++)
    	    {
		//console.log("bl: %d v: %d",bits.length,(r*chars_per_line+c)*segchar.bit_count + i);
    		if(bits[(r*chars_per_line+c)*segchar.bit_count + i])
    		{
    		    path += create_seg_path(x,y,segchar.coords[i]);
    		}
    	    }
    	}
    }

    //console.log(path);
    var patbasis = g.s.path(pathtxt).attr({ fill: color });
    var pattern = patbasis.toPattern(0,0,1,1);
    var sc = g.s.path(path);
    sc.attr({ fill: pattern });

    return { elem: sc,
	     w: width,
	     h: height
	   };
	     
}

window.onload = function()
{
    document.getElementById("mainarea").style.display = "block";
    document.getElementById("printarea").style.display = "none";
    
    s1 = Snap("#s1");
    g1 = create_grid(s1);

    s2 = Snap("#s2");
    g2 = create_grid(s2);
}

function calc_rows(t, force_wrap)
{
    var rows = 1;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	var c = t.charAt(i);
	if(c == '\n')
	{
	    rows++;
	    col = 0;
	}
	else
	{
	    col++;
	    if(col >= force_wrap)
	    {
		rows++;
		col=0;
	    }
	}
    }

    return rows;
}

function choose_force_wrap(t, font_width_over_height)
{
    var i;
    
    //We want to maximize the dpi considering a standard size page (8.5 x 11), the
    //font width and height, and assuming square pixels
    for(i = min_force_wrap;; i++)
    {
	var rows = calc_rows(t,i);
	if(i * font_width_over_height / rows > page_ratio)
	    break;
    }
    
    return i;
}

function create_message_for_grid(t)
{
    var message = { text: "",
		    bits: [],
		    force_wrap: null,
		    width: null
		  };
    
    message.force_wrap = choose_force_wrap(t, charw/charh);
    message.width = message.force_wrap * charw; //width always matches force_wrap * charw
    //it's just for convenience
    
    //assumes 5x8 and writes t into bits
    message.text=t;
    message.bits = [];

    //console.log(message);

    var row = 0;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	//go through each line of character, horizontally
	
	// ex:
	// /* code=65, hex=0x41, ascii="A"
	//  */
	// 0x00,  /* 00000 */
	// 0x00,  /* 00000 */
	// 0x60,  /* 01100 */
	// 0x90,  /* 10010 */
	// 0xF0,  /* 11110 */
	// 0x90,  /* 10010 */
	// 0x90,  /* 10010 */
	// 0x00,  /* 00000 */

	var c = t.charCodeAt(i);
	if(c == 10) //newline
	{
	    col = 0;
	    row++;
	    continue;
	}
	
	var cr = c*charh;

	var bitx = col * charw;
	var bity = row * charh;

	//we expand the buffer so it's always rectangular
	message.bits[(bity+charh)*message.width-1] = false;
	
	//console.log("bitx "+bitx+" bity "+bity)
	for(var bitline = 0; bitline < charh; bitline++)
	{
	    for(var bit = 0; bit < charw; bit++)
	    {
		var on = (1&(font[cr+bitline] >> (7 - bit))) == 1;
		//console.log("bitline "+bitline+" font "+font[cr+bitline]+" bit "+bit+" on "+on)
		var bit_index = bitx + bit + (bity + bitline) * message.width;
		message.bits[bit_index] = on;
	    }
	}

	col++;
	if(col >= message.force_wrap)
	{
	    col = 0;
	    row++;
	}
    }

    return message;
}

function create_message_for_seg(t,seg)
{
    var message = { text: "",
		    bits: [],
		    force_wrap: null,
		  };
    
    message.force_wrap = choose_force_wrap(t,(seg.width+seg.hgap)/(seg.height+seg.vgap));
    
    message.text=t;
    message.bits = [];

    var row = 0;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	var c = t.charCodeAt(i);
	if(c == 10) //newline
	{
	    col = 0;
	    row++;
	    continue;
	}

	//console.log("col %d row %d", col, row);
	//we expand the buffer so it's always rectangular
	message.bits[(row+1)* seg.bit_count * message.force_wrap - 1] = false;
	
	var bitval = seg.ascii_map[c];
	var bitindex = (row * message.force_wrap + col) * seg.bit_count;
	
	for(var bit = 0; bit < seg.bit_count; bit++)
	{
	    var on = (1&(bitval >> bit)) == 1;
	    message.bits[bitindex+bit] = on;
	}

	col++;
	if(col >= message.force_wrap)
	{
	    col = 0;
	    row++;
	}
    }

    return message;
}

function xor_bits(b1,b2)
{
    var o = [];
    o[(b1.length < b2.length ? b2.length : b1.length) - 1] = false;
    //console.log("b1 "+b1.length)
    // console.log("b2 "+b2[0])
    
    for(i = 0; i < o.length; i++)
    {
	o[i] = (b1[i] && !b2[i] || !b1[i] && b2[i]);
	// !(b1[i] == b2[i]); doesn't work???
    }

    return o;
}

function create_otp_bits(length)
{
    var bits = [];
    bits[length-1] = false; //prealloc
    for(i = 0; i < length; i++)
	bits[i] = (Math.random() >= .5);
    //0;

    return bits;
}

function get_mode()
{
    var radios = document.getElementsByName('mode');
    for (var i = 0, length = radios.length; i < length; i++) {
	if (radios[i].checked) {
            return radios[i].value;
	}
    }
}
    
function input_changed()
{
    var mode = get_mode();
    
    var input = document.getElementById('msg').value;
    if(input.length == 0)
    {
	document.getElementById('print_s1').disabled=true;
	document.getElementById('print_s2').disabled=true;
    }
    else
    {
	document.getElementById('print_s1').disabled=false;
	document.getElementById('print_s2').disabled=false;
    }
    
    if(g1 && g2)
    {
	if(mode == "grid")
	{
	    //console.log('hi');
	    var message = create_message_for_grid(input);
	    var otp_bits = create_otp_bits(message.bits.length);
	    var g1_bits = xor_bits(message.bits, otp_bits);
	    //
	    message.bits;
	    var g2_bits = otp_bits;
	    //console.log(g1.bits);
	    
	    redraw_grid(g1,g1_bits, message.width,
			g1_pattern,
			g1_color
		       );
	    redraw_grid(g2,g2_bits, message.width,
			g2_pattern,
			g2_color);
	}
	else if(mode == "sixteenseg")
	{
	    var message = create_message_for_seg(input, segchar16);
	    var otp_bits = create_otp_bits(message.bits.length);
	    var g1_bits = xor_bits(message.bits, otp_bits);
	    // message.bits;
	    var g2_bits = otp_bits;
	    //console.log(message);
	    
	    g1.s.clear();
	    var sc1 = draw_segchar(g1,g1_bits, message.force_wrap,
			   g1_pattern,
			   g1_color, segchar16
				  );

	    if(sc1)
		g1.s.attr({viewBox:[0,0,sc1.w,sc1.h].join(' '),
    		 	   //preserveAspectRatio: "none"
    			  });
		
		
	    g2.s.clear();
	    var sc2 = draw_segchar(g2,g2_bits, message.force_wrap,
				   g2_pattern, g2_color,segchar16);
	    if(sc2)
		g2.s.attr({viewBox:[0,0,sc2.w,sc2.h].join(' '),
    		 	   //preserveAspectRatio: "none"
    			  });
		
	}
    }
}

function print_s1()
{
    document.getElementById("mainarea").style.display = "none";
    document.getElementById("printarea").style.display = "block";

    var sp = Snap("#p");
    var gp = create_grid(sp);

    var input = document.getElementById('msg').value;
    var mode = get_mode();

    if(mode == "grid")
    {
	//console.log('hi');
	var message = create_message_for_grid(input);
	var otp_bits = create_otp_bits(message.bits.length);
	var g1_bits = xor_bits(message.bits, otp_bits);
	//
	
	redraw_grid(gp,g1_bits, message.width,
		    g1_pattern,
		    g1_color);
    }
    else if(mode == "sixteenseg")
    {
	var message = create_message_for_seg(input, segchar16);
	var otp_bits = create_otp_bits(message.bits.length);
	var g1_bits = xor_bits(message.bits, otp_bits);
	
	var m = redraw_segchar(gp,g1_bits, message.force_wrap,
			       g1_pattern, g1_color, segchar16
			      );
	//m.
    }
    
    
}


</script>


</head>

    <body>
    <div id="mainarea">
    <p>Introduction: bla bla bla</p>
    <table>
    <tr>
    <td>Message
    <td><textarea autofocus="true" id="msg" onkeyup="input_changed()" onchange="input_changed()"></textarea>
    <td>OTP
    <td><textarea></textarea>
    <td><input type="button" value="Generate OTP">
    </tr>
    <tr><td colspan="4">
    <input type="radio" name="mode" value="sixteenseg" checked="true" onclick="input_changed()">16 segment
    <input type="radio" name="mode" value="grid" onclick="input_changed()">Grid
    </table>
    <table>
    <tr>
    <td>
    Encoded Page 1
    <br>
    <svg width="100%" height="500" id="s1" />
    <br><input type="button" disabled="true" onclick="print_s1()" id="print_s2" value="Print First Page" />
    </td>
    <td>&nbsp;</td>
    <td>
    Encoded Page 2
    <br>
    <svg width="100%" height="500" id="s2" />
    <br><input type="button" disabled="true" onclick="print_s2()" id="print_s1" value="Print Second Page" />
    </td></tr></table>
    </div>
    <div id="printarea">
    <svg width="100%" height="100%" id="p" />
    </div>
</body>
    
</html>
    



