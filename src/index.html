    <!doctype html>
    <html>
    <head>
    <meta charset="UTF-8">
    <title>Paper based OTP</title>
    <script src="snap.svg-min.js" />
    <script src="seedrandom.min.js"></script>
    <script src="rng.js"></script>
    <script src="5x8.js"></script>
    <script src="sixteenSeg.js"></script>
    <script>

var s1;
var s2;
var g1,g2;

var rows = 10;
var cols = 30;
var charh = 8;
var charw = 5;

var otp_bits = [];

var font = console_font_5x8;

var min_force_wrap = 5;
var page_ratio = 7.5/10; //8.5x11 with half inch margins

//pattern and color for code in first page
var g1_pat_path = "M 0 0 L 0 0.5 L 0.5 1 L 1 1 L 0 0 M 0.5 0 L 1 0.5 L 1 0 L 0.5 0";
var g1_pat_color = "#808080";

//pattern and color for code in second page
var g2_pat_path = "M 0 0 L 0.5 0 L 1 .5 L 1 1 L 0 0 M 0 0.5 L 0.5 1 L 0 1 L 0 0.5";
var g2_pat_color = "#000000";

//for printing, the right margin is used for an ascii to value table
var right_margin_perc = .15;
//for printing, the bottom margin is used to help the user understand the results
var bottom_margin_perc = .1;

//draw_ascii_table_for_seg
var ascii =
    {
	char_height: 10,
	line_height: 12,
	col_gap: 8,
	max_rows: 47,
	//94 chars
	char_start: 33, // "!";
	char_end: 126, // "~";
	left_margin: 10
    };


var legend =
    {
	char_height: 10,
	coord_ex_height: 14,
	item_hgap: 5,
	group_hgap: 20,
	seg_ex_height: 14,

	//"K"
	example_bitmap1: 0b0110000110110111,
	example_bitmap2: 0b0100110110010011
    };

function path_rect(x,y,w,h)
{
    return "M "+x+" "+y+
	"L "+(x+w)+" "+y+
	"L "+(x+w)+" "+(y+h)+
	"L "+x+" "+(y+h)+
	"L "+x+" "+y;
}

function redraw_grid(g,bits,width,pathtxt,color)
{
    g.clear();
    if(bits.length == 0 || width == 0)
	return;
    
    //we use a dyanamically generated path to mark pixels. I was thinking about using a 
    //bitmap and scaling it in the SVG but this seems flaky cross browsers. At least one example of doing
    //so didn't work right in my browser (google chrome 49 on linux).

    var height = bits.length/width;

    //console.log("w %d h %d",width, height);
    //console.log(bits);

    g.attr({viewBox:[0,0,width,height].join(' '),
    	      //preserveAspectRatio: "none"
    	     });
    // g.attr({viewBox:[0,0,100,100].join(' '),
    // 	      //preserveAspectRatio: "none"
    // 	     });

    var path="";

    var filled_cells_in_line=0;
    var filled_lines=0;

    var create_rects_for_bits_fn =
	function(filled_lines, filled_cells_in_line) {
	    //draw last rectangle
	    if(filled_lines > 0)
	    {
		path += (path_rect(0,y-filled_lines,width,filled_lines));
	    }
	    //draw the current set of filled cells
	    if(filled_cells_in_line != 0)
	    {
		path += (path_rect(x-filled_cells_in_line,y,filled_cells_in_line,1));
	    }
	};

    for(y=0;y<height;y++)
    {
	for(x=0;x<width;x++)
	{
	    if(!bits[y*width+x])
	    {
		//console.log("true value %d %d",x,y)
		create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
		filled_lines = 0;
		filled_cells_in_line = 0;
	    }
	    else
	    {
		filled_cells_in_line ++;
	    }
	}

	//at the end of the line, check if all were filled
	if(filled_cells_in_line == width)
	{
	    filled_lines ++;
	    filled_cells_in_line = 0;
	}
	else
	{
	    //draw the bits for the previous filled lines
	    create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
	    filled_lines = 0;
	    filled_cells_in_line = 0;
	}
    }

    create_rects_for_bits_fn(filled_lines,filled_cells_in_line);

    var patbasis = g.path(pathtxt).attr({ fill: color });
    var pattern = patbasis.toPattern(0,0,1,1);
    g.path(path).attr({ fill: pattern });
}

function create_seg_path(x,y,coords)
{
    var path = "M ";
    for(var i = 0; i < coords.length; i+=2)
    {
	path += (x+coords[i])+" "+(y+coords[i+1])+" ";
    }
    path += (x+coords[0])+" "+(y+coords[1])+" ";

    return path;
}

function create_seg_ascii_char(x,y,seg,ascii_index)
{
    var bitval = seg.ascii_map[ascii_index];
    var path = "";
    for(var bit = 0; bit < seg.bit_count; bit++)
    {
	var on = (1&(bitval >> bit)) == 1;
	if(on) path += create_seg_path(x,y,seg.coords[bit]);
    }

    return path;
}

function draw_segchar(g,bits,chars_per_line,pattern, segchar)
{
    if(bits.length == 0 || chars_per_line == 0)
	return;

    var width = chars_per_line * segchar.width + (chars_per_line - 1) * segchar.hgap;
    var chars_per_col = bits.length / (chars_per_line*segchar.bit_count);
    var height = chars_per_col * segchar.height+ (chars_per_col - 1) * segchar.vgap;

    //console.log("w %d chars_per_col %f chars_per_line %d height %d",width,chars_per_col,chars_per_line, height);
    
    var path="";

    for(var r=0;r<chars_per_col;r++)
    {
    	for(var c=0;c<chars_per_line;c++)
    	{
    	    var x = c*(segchar.width+segchar.hgap);
    	    var y = r*(segchar.height+segchar.vgap);

    	    for(var i=0; i < segchar.bit_count; i++)
    	    {
		//console.log("bl: %d v: %d",bits.length,(r*chars_per_line+c)*segchar.bit_count + i);
    		if(bits[(r*chars_per_line+c)*segchar.bit_count + i])
    		{
    		    path += create_seg_path(x,y,segchar.coords[i]);
    		}
    	    }
    	}
    }

    //console.log(path);
    var sc = g.path(path);
    sc.attr({ fill: pattern });

    //we return the width and height explicitely (rather than letting the user run getBBox() on
    //sc, because getBBox() is kind of slow.
    return { elem: sc,
	     w: width,
	     h: height
	   };
	     
}

window.onload = function()
{
    document.getElementById("mainarea").style.display = "block";
    document.getElementById("printarea").style.display = "none";
    
    g1 = Snap("#s1");

    g2 = Snap("#s2");
}

function calc_rows(t, force_wrap)
{
    var rows = 1;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	var c = t.charAt(i);
	if(c == '\n')
	{
	    rows++;
	    col = 0;
	}
	else
	{
	    col++;
	    if(col >= force_wrap)
	    {
		rows++;
		col=0;
	    }
	}
    }

    return rows;
}

function choose_force_wrap(t, font_width_over_height)
{
    var i;
    
    //We want to maximize the dpi considering a standard size page (8.5 x 11), the
    //font width and height, and assuming square pixels
    for(i = min_force_wrap;; i++)
    {
	var rows = calc_rows(t,i);
	if(i * font_width_over_height / rows > page_ratio)
	    break;
    }
    
    return i;
}

function create_message_for_grid(t)
{
    var message = { text: "",
		    bits: [],
		    force_wrap: null,
		    width: null
		  };
    
    message.force_wrap = choose_force_wrap(t, charw/charh);
    message.width = message.force_wrap * charw; //width always matches force_wrap * charw
    //it's just for convenience
    
    //assumes 5x8 and writes t into bits
    message.text=t;
    message.bits = [];

    //console.log(message);

    var row = 0;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	//go through each line of character, horizontally
	
	// ex:
	// /* code=65, hex=0x41, ascii="A"
	//  */
	// 0x00,  /* 00000 */
	// 0x00,  /* 00000 */
	// 0x60,  /* 01100 */
	// 0x90,  /* 10010 */
	// 0xF0,  /* 11110 */
	// 0x90,  /* 10010 */
	// 0x90,  /* 10010 */
	// 0x00,  /* 00000 */

	var c = t.charCodeAt(i);
	if(c == 10) //newline
	{
	    col = 0;
	    row++;
	    continue;
	}
	
	var cr = c*charh;

	var bitx = col * charw;
	var bity = row * charh;

	//we expand the buffer so it's always rectangular
	message.bits[(bity+charh)*message.width-1] = false;
	
	//console.log("bitx "+bitx+" bity "+bity)
	for(var bitline = 0; bitline < charh; bitline++)
	{
	    for(var bit = 0; bit < charw; bit++)
	    {
		var on = (1&(font[cr+bitline] >> (7 - bit))) == 1;
		//console.log("bitline "+bitline+" font "+font[cr+bitline]+" bit "+bit+" on "+on)
		var bit_index = bitx + bit + (bity + bitline) * message.width;
		message.bits[bit_index] = on;
	    }
	}

	col++;
	if(col >= message.force_wrap)
	{
	    col = 0;
	    row++;
	}
    }

    return message;
}

function create_message_for_seg(t,seg)
{
    var message = { text: "",
		    bits: [],
		    force_wrap: null,
		  };
    
    message.force_wrap = choose_force_wrap(t,(seg.width+seg.hgap)/(seg.height+seg.vgap));
    
    message.text=t;
    message.bits = [];

    var row = 0;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	var c = t.charCodeAt(i);
	if(c == 10) //newline
	{
	    col = 0;
	    row++;
	    continue;
	}

	//console.log("col %d row %d", col, row);
	//we expand the buffer so it's always rectangular
	message.bits[(row+1)* seg.bit_count * message.force_wrap - 1] = false;
	
	var bitval = seg.ascii_map[c];
	var bitindex = (row * message.force_wrap + col) * seg.bit_count;
	
	for(var bit = 0; bit < seg.bit_count; bit++)
	{
	    var on = (1&(bitval >> bit)) == 1;
	    message.bits[bitindex+bit] = on;
	}

	col++;
	if(col >= message.force_wrap)
	{
	    col = 0;
	    row++;
	}
    }

    return message;
}

function xor_bits(b1,b2)
{
    var o = [];
    o[(b1.length < b2.length ? b2.length : b1.length) - 1] = false;
    //console.log("b1 "+b1.length)
    // console.log("b2 "+b2[0])
    
    for(i = 0; i < o.length; i++)
    {
	o[i] = (b1[i] && !b2[i] || !b1[i] && b2[i]);
	// !(b1[i] == b2[i]); doesn't work???
    }

    return o;
}

function create_otp_bits(length)
{
    var bits = [];
    bits[length-1] = false; //prealloc
    for(i = 0; i < length; i++)
	bits[i] = (Math.random() >= .5);
    //0;

    return bits;
}

function get_mode()
{
    var radios = document.getElementsByName('mode');
    for (var i = 0, length = radios.length; i < length; i++) {
	if (radios[i].checked) {
            return radios[i].value;
	}
    }
}
    
function input_changed()
{
    var mode = get_mode();
    
    var input = document.getElementById('msg').value;
    if(input.length == 0)
    {
	document.getElementById('print_s1').disabled=true;
	document.getElementById('print_s2').disabled=true;
    }
    else
    {
	document.getElementById('print_s1').disabled=false;
	document.getElementById('print_s2').disabled=false;
    }
    
    if(g1 && g2)
    {
	if(mode == "grid")
	{
	    //console.log('hi');
	    var message = create_message_for_grid(input);
	    var otp_bits = create_otp_bits(message.bits.length);
	    var g1_bits = xor_bits(message.bits, otp_bits);
	    //
	    message.bits;
	    var g2_bits = otp_bits;
	    //console.log(g1.bits);
	    
	    redraw_grid(g1,g1_bits, message.width,
			g1_pattern,
			g1_color
		       );
	    redraw_grid(g2,g2_bits, message.width,
			g2_pattern,
			g2_color);
	}
	else if(mode == "sixteenseg")
	{
	    var message = create_message_for_seg(input, segchar16);
	    var otp_bits = create_otp_bits(message.bits.length);
	    var g1_bits = xor_bits(message.bits, otp_bits);
	    // message.bits;
	    var g2_bits = otp_bits;
	    //console.log(message);
	    
	    g1.clear();
	    var g1_pattern = get_pattern(g1, g1_pat_path, g1_pat_color);
	    var sc1 = draw_segchar(g1,g1_bits, message.force_wrap,
			   g1_pattern, segchar16
				  );

	    if(sc1)
		g1.attr({viewBox:[0,0,sc1.w,sc1.h].join(' '),
    		 	   //preserveAspectRatio: "none"
    			  });
		
		
	    g2.clear();
	    var g2_pattern = get_pattern(g2, g2_pat_path, g2_pat_color);
	    var sc2 = draw_segchar(g2,g2_bits, message.force_wrap,
				   g2_pattern,segchar16);
	    if(sc2)
		g2.attr({viewBox:[0,0,sc2.w,sc2.h].join(' '),
    		 	   //preserveAspectRatio: "none"
    			  });
		
	}
    }
}


function draw_ascii_table_for_seg(g,seg,pattern)
{
    var max_char_width = 1;
    var group = g.g();
    var text_width = 0;
    var col = -1;

    var scaleSeg = ascii.char_height/seg.height;
    var seg_width = seg.width * scaleSeg;
    
    for(var i = ascii.char_start;
	i <= ascii.char_end;
	i++)
    {
	if((i-ascii.char_start) % ascii.max_rows == 0)
	    col++;
	    
	//note for the zeroth column, first row, text_width is zero, but this
	//doesn't matter cause col is zero, too
	var x = ascii.left_margin + col * (text_width + seg_width + ascii.col_gap);
	var y = ((i-ascii.char_start)%ascii.max_rows) * ascii.line_height;
	var text = g.text(x, y + ascii.char_height, String.fromCharCode(i)+ ":");
	text.attr("font-size",ascii.char_height)
	    .attr("font-family", "monospace");

	//since were monospace, the text width is always the same
	if(text_width == 0)
	{
	    text_width = text.getBBox().width;
	}
	//console.log("x %d tw %d", x,text_width);
	// console.log("%d %s",i,seg.ascii_map[i]);
	var char_path = create_seg_ascii_char(0,0, seg, i);
	//console.log(char_path);	
	var path = g.path(char_path);
	path.attr({ fill:
		 g1_pat_color})
	//pattern});
	
	var m = (new Snap.Matrix())
	    .translate(x+text_width,y)
	    .scale(scaleSeg);
	path.transform(m);
	group.add(text,path);

    }

    return group;
}

//TODO 2 make a list of identical chars and warn about them if the user uses them, or fix them to not be
//identical

function transform_to_box(e,x1,y1,x2,y2)
{
    var bbox = e.getBBox();

    var matrix = new Snap.Matrix();
    matrix.translate(x1,y1);

    var scale = Math.min((x2-x1)/bbox.w,(y2-y1)/bbox.h);
    matrix.scale(scale);

    e.transform(matrix);
}

function get_pattern(g,pathtxt,color)
{
    var patbasis = g.path(pathtxt).attr({ fill: color });
    return patbasis.toPattern(0,0,1,1);
}

function draw_legend_text(g,text)
{
    var o = g.text(text).attr("font-size",legend.char_height);

    return { o: o,
	     h: legend.char_height
	   };
}

function draw_example_coord(g, seg,is_draw_seg, text, is_draw_text)



function draw_legend_seg_bit_char(g, seg,is_draw_seg, text, is_draw_text)
{ o:
	  create_seg_bit_char(0,0,seg, page_number == 1 ?
			      legend.example_bitmap1 :
			      legend.example_bitmap2),
	  h: seg.height,
	  sh: legend.seg_ex_height
	},


function draw_legend(page_number, //1 or 2
		     g,seg,pattern)
{
    draw_legend_objects
    (
	draw_legend_text(g,"Legend:", page_number == 1),
	draw_example_coord(g,seg, page_number==1,"on", page_number == 1),
	draw_example_coord(g,seg, page_number==2,"on", page_number == 1),
	draw_example_coord(g,seg, false,"off", page_number == 1),
	draw_example_coord(g,seg, true,"off", page_number == 1),
	draw_legend_text(g,"Example:"),
	draw_legend_seg_bit_char(seg,
				 page_number == 1 ?
				 legend.example_bitmap1 :
				 legend.example_bitmap2
				),
	draw_legend_text(g,"="),
	draw_legend_seg_bit_char(seg,
				 legend.example_bitmap1 ^
				 legend.example_bitmap2
				),
	draw_legend_text(g,"="),
	draw_legend_text(g,"K"));

    var group = g.g();

    var lt = g.text("Legend:");
    group.add(lt);
    
    
}

function print_s1()
{
    document.getElementById("mainarea").style.display = "none";
    document.getElementById("printarea").style.display = "block";

    var g = Snap("#p");

    var input = document.getElementById('msg').value;
    var mode = get_mode();

    if(mode == "grid")
    {
	//console.log('hi');
	var message = create_message_for_grid(input);
	var otp_bits = create_otp_bits(message.bits.length);
	var g1_bits = xor_bits(message.bits, otp_bits);
	//
	
	redraw_grid(g,g1_bits, message.width,
		    g1_pattern,
		    g1_color);
    }
    else if(mode == "sixteenseg")
    {
	var message = create_message_for_seg(input, segchar16);
	var otp_bits = create_otp_bits(message.bits.length);
	var g1_bits = xor_bits(message.bits, otp_bits);

	g.clear();

	var pattern = get_pattern(g, g1_pat_path, g1_pat_color);

	var sc = draw_segchar(g,g1_bits, message.force_wrap,
			      pattern, segchar16
			     );
	var scw = sc.w;
	var sch = sc.h;

	if(scw / page_ratio > sch)
	    sch = scw / page_ratio;
	else
	    scw = sch * page_ratio;
	
	var rm = Math.round(scw * right_margin_perc);
	var bm = Math.round(sch * bottom_margin_perc);

	//sc.elem.attr({fill: "#000000"});
	//console.log("rm %d bm %d",rm, bm);
	//console.log(sc);
	g.attr({viewBox:[0,0,scw+rm,sch+bm].join(' '),
    		//preserveAspectRatio: "none"
    	       });

	//all tables and charts are written directly in the svg.
	//It seems easier than breaking out into html
	//since I need the data to *exactly* overlap
	//in the legend (although I may be wrong on this)
	var at = draw_ascii_table_for_seg(g,segchar16, pattern);

	transform_to_box(at,scw,0,scw+rm,sch+bm);

	var legend = draw_legend_p1(g,segchar16, pattern);

	transform_to_box(at,0,sch,scw,sch+bm);
    }
    
}




</script>

    <style>
    .large {
	font-size: 200%;
    }
</style>

</head>

    <body>
    <div id="mainarea">
    <p>Introduction: bla bla bla</p>
    <table>
    <tr>
    <td>Message
    <td><textarea autofocus="true" id="msg" onkeyup="input_changed()" onchange="input_changed()"></textarea>
    <td>OTP
    <td><textarea></textarea>
    <td><input type="button" value="Generate OTP">
    </tr>
    <tr><td colspan="4">
    <input type="radio" name="mode" value="sixteenseg" checked="true" onclick="input_changed()">16 segment
    <input type="radio" name="mode" value="grid" onclick="input_changed()">Grid
    </table>
    <table>
    <tr>
    <td>
    Encoded Page 1
    <br>
    <table style="width:100%;">
    <tr><td><svg width="100%" height="500" id="s1" /></td>
    <br><input type="button" disabled="true" onclick="print_s1()" id="print_s2" value="Print First Page" />
    </td>
    <td>&nbsp;</td>
    <td>
    Encoded Page 2
    <br>
    <svg width="100%" height="500" id="s2" />
    <br><input type="button" disabled="true" onclick="print_s2()" id="print_s1" value="Print Second Page" />
    </td></tr></table>
    </div>
    <div id="printarea">
    <table>
      <tr><td>
	  <svg width="100%" height="100%" id="p" /></td>
	<td rowspan=2><svg width="100%" height="100%" id="ascii_table" /></td>
      </tr>
      <tr>
	<td>
	  <table>
	    <tr>
	      <td><div class="p1_text">Legend:</div> <svg width="100%" height="100%" id="legend" /></td>
	      <td><div class="p1_text">Example:</div>
		<svg width="100%" height="100%" id="ex1" />
		<div class="p1_text"> = </div>
		<svg width="100%" height="100%" id="ex2" />
		<div class="p1_text"> = </div>
		<div class="p1_text large">K</div>
	      </td>
	    </tr>
	  </table>
	</td>
      </tr>
    </table>
    </div>
</body>
    
</html>
    



