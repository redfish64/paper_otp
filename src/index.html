    <!doctype html>
    <html>
    <head>
    <meta charset="UTF-8">
    <title>Paper based OTP</title>
    <script src="snap.svg-min.js" />
    <script src="seedrandom.min.js"></script>
    <script src="rng.js"></script>
    <script src="5x8.js"></script>
    <script>

var s1;
var s2;
var g1,g2;

var rows = 10;
var cols = 30;
var charh = 8;
var charw = 5;

var otp_bits = [];

var font = console_font_5x8;

var min_force_wrap = 5;
var page_ratio = 8.5/11;

function create_grid(s)
{
    g = { s: s };

    return g;
}

function path_rect(x,y,w,h)
{
    return "M "+x+" "+y+
	"L "+(x+w)+" "+y+
	"L "+(x+w)+" "+(y+h)+
	"L "+x+" "+(y+h)+
	"L "+x+" "+y;
}

function redraw_grid(g,bits,width,pathtxt,color)
{
    g.s.clear();
    if(bits.length == 0 || width == 0)
	return;
    
    //we use a dyanamically generated path to mark pixels. I was thinking about using a 
    //bitmap and scaling it in the SVG but this seems flaky cross browsers. At least one example of doing
    //so didn't work right in my browser (google chrome 49 on linux).

    var height = bits.length/width;

    //console.log("w %d h %d",width, height);
    //console.log(bits);

    g.s.attr({viewBox:[0,0,width,height].join(' '),
    	      //preserveAspectRatio: "none"
    	     });
    // g.s.attr({viewBox:[0,0,100,100].join(' '),
    // 	      //preserveAspectRatio: "none"
    // 	     });

    var path="";

    var filled_cells_in_line=0;
    var filled_lines=0;

    var create_rects_for_bits_fn =
	function(filled_lines, filled_cells_in_line) {
	    //draw last rectangle
	    if(filled_lines > 0)
	    {
		path += (path_rect(0,y-filled_lines,width,filled_lines));
	    }
	    //draw the current set of filled cells
	    if(filled_cells_in_line != 0)
	    {
		path += (path_rect(x-filled_cells_in_line,y,filled_cells_in_line,1));
	    }
	};

    for(y=0;y<height;y++)
    {
	for(x=0;x<width;x++)
	{
	    if(!bits[y*width+x])
	    {
		//console.log("true value %d %d",x,y)
		create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
		filled_lines = 0;
		filled_cells_in_line = 0;
	    }
	    else
	    {
		filled_cells_in_line ++;
	    }
	}

	//at the end of the line, check if all were filled
	if(filled_cells_in_line == width)
	{
	    filled_lines ++;
	    filled_cells_in_line = 0;
	}
	else
	{
	    //draw the bits for the previous filled lines
	    create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
	    filled_lines = 0;
	    filled_cells_in_line = 0;
	}
    }

    create_rects_for_bits_fn(filled_lines,filled_cells_in_line);

    var patbasis = g.s.path(pathtxt).attr({ fill: color });
    var pattern = patbasis.toPattern(0,0,1,1);
    g.s.path(path).attr({ fill: pattern });
}

window.onload = function()
{
    s1 = Snap("#s1");
    g1 = create_grid(s1);

    s2 = Snap("#s2");
    g2 = create_grid(s2);
}

function calc_rows(t, force_wrap)
{
    var rows = 1;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	var c = t.charAt(i);
	if(c == '\n')
	{
	    rows++;
	    col = 0;
	}
	else
	{
	    col++;
	    if(col >= force_wrap)
	    {
		rows++;
		col=0;
	    }
	}
    }

    return rows;
}

function choose_force_wrap(t)
{
    var i;
    
    //We want to maximize the dpi considering a standard size page (8.5 x 11), the
    //font width and height, and assuming square pixels
    for(i = min_force_wrap;; i++)
    {
	var rows = calc_rows(t,i);
	if(i/rows > page_ratio)
	    break;
    }
    
    return i;
}

function create_message_for_txt(t)
{
    var message = { text: "",
		    bits: [],
		    force_wrap: null,
		    width: null
		  };
    
    message.force_wrap = choose_force_wrap(t);
    message.width = message.force_wrap * charw; //width always matches force_wrap * charw
    //it's just for convenience
    
    //assumes 5x8 and writes t into bits
    message.text=t;
    message.bits = [];

    //console.log(message);

    var row = 0;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	//go through each line of character, horizontally
	
	// ex:
	// /* code=65, hex=0x41, ascii="A"
	//  */
	// 0x00,  /* 00000 */
	// 0x00,  /* 00000 */
	// 0x60,  /* 01100 */
	// 0x90,  /* 10010 */
	// 0xF0,  /* 11110 */
	// 0x90,  /* 10010 */
	// 0x90,  /* 10010 */
	// 0x00,  /* 00000 */

	var c = t.charCodeAt(i);
	if(c == 10) //newline
	{
	    col = 0;
	    row++;
	    continue;
	}
	
	var cr = c*charh;

	var bitx = col * charw;
	var bity = row * charh;

	//we expand the buffer so it's always rectangular
	message.bits[(bity+charh)*message.width-1] = false;
	
	//console.log("bitx "+bitx+" bity "+bity)
	for(var bitline = 0; bitline < charh; bitline++)
	{
	    for(var bit = 0; bit < charw; bit++)
	    {
		var on = (1&(font[cr+bitline] >> (7 - bit))) == 1;
		//console.log("bitline "+bitline+" font "+font[cr+bitline]+" bit "+bit+" on "+on)
		var bit_index = bitx + bit + (bity + bitline) * message.width;
		message.bits[bit_index] = on;
	    }
	}

	col++;
	if(col >= message.force_wrap)
	{
	    col = 0;
	    row++;
	}
    }

    return message;
}

function xor_bits(b1,b2)
{
    var o = [];
    o[(b1.length < b2.length ? b2.length : b1.length) - 1] = false;
    //console.log("b1 "+b1.length)
    // console.log("b2 "+b2[0])
    
    for(i = 0; i < o.length; i++)
    {
	o[i] = (b1[i] && !b2[i] || !b1[i] && b2[i]);
	// !(b1[i] == b2[i]); doesn't work???
    }

    return o;
}

function create_otp_bits(length)
{
    var bits = [];
    bits[length-1] = false; //prealloc
    for(i = 0; i < length; i++)
	bits[i] = (Math.random() >= .5); //(i %2 == 0); //TODO FIXME

    return bits;
}

function input_changed()
{
    if(g1 && g2)
    {
	//console.log('hi');
	var input = document.getElementById('msg');
	var message = create_message_for_txt(input.value);
	var otp_bits = create_otp_bits(message.bits.length);
	var g1_bits = xor_bits(message.bits, otp_bits);
	//
	message.bits;
	var g2_bits = otp_bits;
	//console.log(g1.bits);

	redraw_grid(g1,g1_bits, message.width,
		    "M 0 0 L 0 0.5 L 0.5 1 L 1 1 L 0 0 M 0.5 0 L 1 0.5 L 1 0 L 0.5 0",
		    "#808080"
		    
		   );
	redraw_grid(g2,g2_bits, message.width,
		    "M 0 0 L 0.5 0 L 1 .5 L 1 1 L 0 0 M 0 0.5 L 0.5 1 L 0 1 L 0 0.5",
		   "#000000");
    }
}


</script>
    
</head>

    <body>
    <p>Introduction: bla bla bla</p>
    <table>
    <tr>
    <td>Message
    <td><textarea autofocus="true" id="msg" onkeyup="input_changed()" onchange="input_changed()"></textarea>
    <td>OTP
    <td><textarea></textarea>
    <td><input type="button" value="Generate OTP">
    </tr>
    </table>
    <table>
    <tr>
    <td>
    Encoded Page 1
    <br>
    <svg width="100%" height="500" id="s1" />
    </td>
    <td>&nbsp;</td>
    <td>
    Encoded Page 2
    <br>
    <svg width="100%" height="500" id="s2" />
    </td></tr></table>
</body>
    
</html>
    



