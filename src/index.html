    <!doctype html>
    <html>
    <head>
    <meta charset="UTF-8">
    <title>Paper based OTP</title>
    <script src="snap.svg-min.js"></script>
    <script src="sjcl.js"></script>
    <script src="5x8.js"></script>
    <script src="sixteenSeg.js"></script>
    <script src="align.js"></script>
    <script src="rng.js"></script>
    <script>

//we are paranoid as possible
sjcl.random.setDefaultParanoia(10);

var s1;
var s2;
var g1,g2;

var segchar = segchar16;

var rows = 10;
var cols = 30;
var charh = 8;
var charw = 5;

var otp_bits = [];

var font = console_font_5x8;

var min_force_wrap = 5;
var max_force_wrap = 100;
var page_ratio = 7.5/10; //8.5x11 with half inch margins

//pattern color for code in first page
var g1_pat_color = "#404040";

//pattern color for code in second page
var g2_pat_color = "#000000";

var pat_scales = [
    1,
];

//for printing, the right margin is used for an ascii to value table
var right_margin_perc = .15;
//for printing, the bottom margin is used to help the user understand the results
var bottom_margin_perc = .1;

//draw_ascii_table_for_seg
var ascii =
    {
	char_height: 10,
	line_height: 12,
	col_gap: 8,
	inner_gap: 3,
	max_rows: 47,
	//94 chars
	char_start: 33, // "!";
	char_end: 126, // "~";
	left_margin: 10
    };


var legend =
    {
	char_height: 10,
	ex_total_height: 14,
	ex_ind_coord_height: 10,
	ex_vgap: 1,
	ex_on_off_text_height: 3,
	item_hgap: 5,
	group_hgap: 20,
	seg_height: 14,

	example_bitmap1: 0b0110000110110111,
	example_bitmap2: 0b0100110110010011,
	example_char: "K"
    };

var instructions =
{
    height_perc: .30, 
    text: [ "Place second page underneath and shine a light from behind to decipher code.",
	    "Place first page on top and shine a light from behind to decipher code." ]
}

function path_rect(x,y,w,h)
{
    return "M "+x+" "+y+
	"L "+(x+w)+" "+y+
	"L "+(x+w)+" "+(y+h)+
	"L "+x+" "+(y+h)+
	"L "+x+" "+y;
}

function redraw_grid(g,bits,width,pathtxt,color)
{
    g.clear();
    if(bits.length == 0 || width == 0)
	return;
    
    //we use a dyanamically generated path to mark pixels. I was thinking about using a 
    //bitmap and scaling it in the SVG but this seems flaky cross browsers. At least one example of doing
    //so didn't work right in my browser (google chrome 49 on linux).

    var height = bits.length/width;

    //console.log("w %d h %d",width, height);
    //console.log(bits);

    g.attr({viewBox:[0,0,width,height].join(' '),
    	      //preserveAspectRatio: "none"
    	     });
    // g.attr({viewBox:[0,0,100,100].join(' '),
    // 	      //preserveAspectRatio: "none"
    // 	     });

    var path="";

    var filled_cells_in_line=0;
    var filled_lines=0;

    var create_rects_for_bits_fn =
	function(filled_lines, filled_cells_in_line) {
	    //draw last rectangle
	    if(filled_lines > 0)
	    {
		path += (path_rect(0,y-filled_lines,width,filled_lines));
	    }
	    //draw the current set of filled cells
	    if(filled_cells_in_line != 0)
	    {
		path += (path_rect(x-filled_cells_in_line,y,filled_cells_in_line,1));
	    }
	};

    for(y=0;y<height;y++)
    {
	for(x=0;x<width;x++)
	{
	    if(!bits[y*width+x])
	    {
		//console.log("true value %d %d",x,y)
		create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
		filled_lines = 0;
		filled_cells_in_line = 0;
	    }
	    else
	    {
		filled_cells_in_line ++;
	    }
	}

	//at the end of the line, check if all were filled
	if(filled_cells_in_line == width)
	{
	    filled_lines ++;
	    filled_cells_in_line = 0;
	}
	else
	{
	    //draw the bits for the previous filled lines
	    create_rects_for_bits_fn(filled_lines, filled_cells_in_line);
	    filled_lines = 0;
	    filled_cells_in_line = 0;
	}
    }

    create_rects_for_bits_fn(filled_lines,filled_cells_in_line);

    var patbasis = g.path(pathtxt).attr({ fill: color });
    var pattern = patbasis.toPattern(0,0,1,1);
    g.path(path).attr({ fill: pattern });
}

function create_seg_path(x,y,coords)
{
    var path = "M ";
    for(var i = 0; i < coords.length; i+=2)
    {
	path += (x+coords[i])+" "+(y+coords[i+1])+" ";
    }
    path += (x+coords[0])+" "+(y+coords[1])+" ";

    return path;
}

function create_seg_bit_char(x,y,seg,bitval)
{
    var path = "";
    for(var bit = 0; bit < seg.bit_count; bit++)
    {
	var on = (1&(bitval >> bit)) == 1;
	if(on) path += create_seg_path(x,y,seg.coords[bit]);
    }

    return path;
}

function create_seg_ascii_char(x,y,seg,ascii_index)
{
    return create_seg_bit_char(x,y,seg,seg.ascii_map[ascii_index]);
}

function draw_segchar(g,bits,chars_per_line,patterns, segchar)
{
    if(bits.length == 0 || chars_per_line == 0)
	return;

    var width = chars_per_line * segchar.width + (chars_per_line - 1) * segchar.hgap;
    var chars_per_col = bits.length / (chars_per_line*segchar.bit_count);
    var height = chars_per_col * segchar.height+ (chars_per_col - 1) * segchar.vgap;

    //console.log("w %d chars_per_col %f chars_per_line %d height %d",width,chars_per_col,chars_per_line, height);
    
    var group = g.g();
    
    for(var r=0;r<chars_per_col;r++)
    {
	var path="";
	var off_path=""; //the bits that aren't highlighted

    	for(var c=0;c<chars_per_line;c++)
    	{
    	    var x = c*(segchar.width+segchar.hgap);
    	    var y = r*(segchar.height+segchar.vgap);

    	    for(var i=0; i < segchar.bit_count; i++)
    	    {
		//console.log("bl: %d v: %d",bits.length,(r*chars_per_line+c)*segchar.bit_count + i);
    		if(bits[(r*chars_per_line+c)*segchar.bit_count + i])
    		{
    		    path += create_seg_path(x,y,segchar.coords[i]);
    		}
		else
		    off_path += create_seg_path(x,y,segchar.coords[i]);
    	    }
    	}
	
	var pi = r % patterns.length;
	var pattern = patterns[pi];

	var sc = g.path(path);
	sc.attr({ fill: pattern });

	g.add(sc);

	// var off_sc = g.path(off_path);
	// off_sc.attr({ fill: "#FFFFFF", stroke: "#000000", strokeWidth: "1px"}).
	//     attr("vector-effect", "non-scaling-stroke");

	// g.add(off_sc);
    }

    //console.log(path);

    //we return the width and height explicitly (rather than letting the user run getBBox() on
    //sc, because getBBox() is kind of slow.
    return { elem: g,
	     w: width,
	     h: height
	   };
	     
}


window.onload = function()
{
    sjcl.random = new sjcl.prng(1); //TODO set to 10 or at least 6 (default)
    show_page("mainarea");
    
    g1 = Snap("#s1");

    g2 = Snap("#s2");

//    console.log("whatisready?",(new sjcl.prng(10)).getProgress(10));
}

function calc_rows(t, force_wrap)
{
    var rows = 1;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	var c = t.charAt(i);
	if(c == '\n')
	{
	    if(col != 0)
		rows++;
	    col = 0;
	}
	else
	{
	    col++;
	    if(col > force_wrap)
	    {
		rows++;
		col=0;
	    }
	}
    }

    return rows;
}

function choose_force_wrap(t, font_width_over_height)
{
    var i;
    
    //We want to maximize the dpi considering a standard size page (8.5 x 11), the
    //font width and height, and assuming square pixels
    var last_rows = 0;
    for(i = max_force_wrap;i>=min_force_wrap; i--)
    {
	var rows = calc_rows(t,i);

	//if we haven't gained anymore rows by reducing the force wrap, then
	//we keep going. Otherwise, if we go below the page_ratio, we stop
	if(rows != last_rows && i * font_width_over_height / rows < page_ratio)
	    break;

	last_rows = rows;
    }

    console.log("force wrap %s %d %d %d", t, i+1, calc_rows(t,i), calc_rows(t,i+1));
    
    return i+1;
}

function create_message_for_grid(t)
{
    var message = { text: "",
		    bits: [],
		    force_wrap: null,
		    width: null
		  };
    
    message.force_wrap = choose_force_wrap(t, charw/charh);
    message.width = message.force_wrap * charw; //width always matches force_wrap * charw
    //it's just for convenience
    
    //assumes 5x8 and writes t into bits
    message.text=t;
    message.bits = [];

    //console.log(message);

    var row = 0;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	//go through each line of character, horizontally
	
	// ex:
	// /* code=65, hex=0x41, ascii="A"
	//  */
	// 0x00,  /* 00000 */
	// 0x00,  /* 00000 */
	// 0x60,  /* 01100 */
	// 0x90,  /* 10010 */
	// 0xF0,  /* 11110 */
	// 0x90,  /* 10010 */
	// 0x90,  /* 10010 */
	// 0x00,  /* 00000 */

	var c = t.charCodeAt(i);
	if(c == 10) //newline
	{
	    col = 0;
	    row++;
	    continue;
	}
	
	var cr = c*charh;

	var bitx = col * charw;
	var bity = row * charh;

	//we expand the buffer so it's always rectangular
	message.bits[(bity+charh)*message.width-1] = false;
	
	//console.log("bitx "+bitx+" bity "+bity)
	for(var bitline = 0; bitline < charh; bitline++)
	{
	    for(var bit = 0; bit < charw; bit++)
	    {
		var on = (1&(font[cr+bitline] >> (7 - bit))) == 1;
		//console.log("bitline "+bitline+" font "+font[cr+bitline]+" bit "+bit+" on "+on)
		var bit_index = bitx + bit + (bity + bitline) * message.width;
		message.bits[bit_index] = on;
	    }
	}

	col++;
	if(col > message.force_wrap)
	{
	    col = 0;
	    row++;
	}
    }

    return message;
}

function create_message_for_seg(t,seg)
{
    var message = { text: "",
		    bits: [],
		    force_wrap: null,
		  };
    
    message.force_wrap = choose_force_wrap(t,(seg.width+seg.hgap)/(seg.height+seg.vgap));
    
    message.text=t;
    message.bits = [];

    var row = 0;
    var col = 0;
    for(var i = 0; i < t.length; i++)
    {
	var c = t.charCodeAt(i);
	if(c == 10) //newline
	{
	    if(col != 0)
	    {
		col = 0;
		row++;
	    }
	    continue;
	}

	//console.log("col %d row %d", col, row);
	//we expand the buffer so it's always rectangular
	message.bits[(row+1)* seg.bit_count * message.force_wrap - 1] = false;
	
	var bitval = seg.ascii_map[c];
	var bitindex = (row * message.force_wrap + col) * seg.bit_count;
	
	for(var bit = 0; bit < seg.bit_count; bit++)
	{
	    var on = (1&(bitval >> bit)) == 1;
	    message.bits[bitindex+bit] = on;
	}

	col++;
	if(col >= message.force_wrap)
	{
	    col = 0;
	    row++;
	}
    }

    return message;
}
//TODO fix example for not bits

function xor_bits(b1,b2)
{
    var o = [];
    o[(b1.length < b2.length ? b2.length : b1.length) - 1] = false;
    //console.log("b1 "+b1.length)
    // console.log("b2 "+b2[0])
    
    for(i = 0; i < o.length; i++)
    {
	o[i] = (b1[i] && !b2[i] || !b1[i] && b2[i]);
	// !(b1[i] == b2[i]); doesn't work???
    }

    return o;
}

function not_bits(b)
{
    var o = [];
    o[b.length - 1] = false;
    
    for(i = 0; i < o.length; i++)
    {
	o[i] = !b[i];
    }

    return o;
}

function decimalToHexString(number)
{
    if (number < 0)
    {
    	number = 0xFFFFFFFF + number + 1;
    }

    return number.toString(16).toUpperCase();
}

function hex2bin(hex,length)
{
    var bits = [], str;

    //HACK to make sure we got 8 random bits per byte
    // var bits1 = [], bits0 = [];

    for(var i=0; i<hex.length-1; i+=2)
    {
	var v = parseInt(hex.substr(i, 2), 16);

	for(var j=0;j<8;j++)
	{
	    bits[bits.length] = ((v&(1<<j)) != 0);
	    // if(bits[bits.length-1])
	    // {
	    // 	bits1[j] = true;
	    // }
	    // else
	    // 	bits0[j] = true;

	    if(bits.length >= length)
	    {
		i = hex.length;
		break;
	    }
	}
    }

    // for(var j = 0; j < 8; j++)
    // {
    // 	if(!bits1[j])
    // 	{
    // 	    console.log("%d NEVER 1!!!",j);
    // 	}
    // 	if(!bits0[j])
    // 	    console.log("%d NEVER 0!!!",j);
    // }

    return bits;
}

function finish_generate_seed()
{
    sjcl.random.stopCollectors();

    var input = document.getElementById('msg').value;

    //add extra OTP incase they increase the message size
    var bits = Math.max((input.length * segchar.bit_count) * 4, 40*segchar.bit_count);

    //get the random data into our wasteful but convienent boolean array format
    var random_data = sjcl.random.randomWords(Math.ceil(bits/32));
    
    var otp = "";
    for(var bytei = 0; bytei < random_data.length; bytei++)
    {
	otp += decimalToHexString(random_data[bytei]);
    }

    document.getElementById('otp').value = otp;
    

    show_page("mainarea");
    
    input_changed();
}

function update_paranoia_percent()
{
    console.log("update_paranoia_percent",sjcl.random.getProgress(), sjcl.random.isReady());
    document.getElementById('paranoia_perc').innerHTML =
			       "Move mouse around to generate random data... Paranoia "+
			       (sjcl.random.getProgress()*100)+"%";

    //I know that a value of 2 corresponds to sjcl.random._NOT_READY, but according to:
    //https://github.com/bitwiseshiftleft/sjcl/wiki/Symmetric-Crypto
    //it still means it is ready.
    if(!sjcl.random.isReady()) 
	setTimeout(update_paranoia_percent,500);
}


function generate_seed()
{
    if(!sjcl.random.isReady())
    {
	show_page("generatearea")
	// finish_generate_seed();
	//    sjcl.random.startCollectors();
	// console.log("isready?",sjcl.random.isReady(), sjcl.random.getProgress(),sjcl.random);
	
	redfish64.seeder.onfinish(finish_generate_seed);
	redfish64.seeder.start();
	
	setTimeout(update_paranoia_percent,500);
    }
    else
	finish_generate_seed();
}
    
function create_otp_bits(length)
{
    var bits = hex2bin(document.getElementById('otp').value,length);

    return bits;
}

function get_mode()
{
    var radios = document.getElementsByName('mode');
    for (var i = 0, length = radios.length; i < length; i++) {
	if (radios[i].checked) {
            return radios[i].value;
	}
    }
}

function update_print_buttons()
{
    var input = document.getElementById('msg').value;
    var otp = document.getElementById('otp').value;

    var otp_bits = otp.length * 4;
    var input_bits_needed = input.length * segchar.bit_count;

    var error = "";
    if(input.length == 0 && otp.length==0)
    {
	error = "Please enter a message and create otp (one time pad) random data";
    }
    else if(input.length == 0)
    {
	error = "Please enter a message.";
    }
    else if(otp.length == 0)
	error = "Please enter OTP (one time pad) data or click 'Generate OTP'.";
    else if (otp_bits < input_bits_needed)
    {
	console.log(otp_bits, input_bits_needed);
	error = "Need at least "+Math.ceil((input_bits_needed-otp_bits)/8)+" more OTP bytes. Please enter more OTP (one time pad) data or click 'Generate OTP'.";
    }
    

    if(error != "")
    {
	document.getElementById('print_s1').disabled=true;
	document.getElementById('print_s2').disabled=true;
    }
    else
    {
	error = "Press \"Print!\" to print each page. For extra security, print each copy to separate printers.";
	document.getElementById('print_s1').disabled=false;
	document.getElementById('print_s2').disabled=false;
    }

    document.getElementById('error').innerHTML = error;
}

var otp_regex=/[^0-9A-Fa-f]+/g;

function otp_changed()
{
    var otp = document.getElementById('otp');

    otp.value = otp.value.replace(otp_regex,'');

    input_changed();
}

function input_changed()
{
    update_print_buttons();
    
    var mode = get_mode();
    
    var input = document.getElementById('msg').value;
    
    if(g1 && g2)
    {
	if(mode == "grid")
	{
	    //console.log('hi');
	    var message = create_message_for_grid(input);
	    var otp_bits = create_otp_bits(message.bits.length);
	    var g1_bits = xor_bits(message.bits, otp_bits);
	    //
	    message.bits;
	    var g2_bits = otp_bits;
	    //console.log(g1.bits);
	    
	    redraw_grid(g1,g1_bits, message.width,
			g1_pat_path,
			g1_pat_color
		       );
	    redraw_grid(g2,g2_bits, message.width,
			g2_pat_path,
			g2_pat_color);
	}
	else //if(mode == "sixteenseg")
	{
	    var message = create_message_for_seg(input, segchar);
	    var otp_bits = create_otp_bits(message.bits.length);
	    var g1_bits = xor_bits(message.bits, otp_bits);
	    // message.bits;
	    var g2_bits = otp_bits;//not_bits(otp_bits);
	    //console.log(message);
	    
	    g1.clear();
	    var g1_patterns = get_patterns(g1, g1_pat_color, 1);
	    var sc1 = draw_segchar(g1,g1_bits, message.force_wrap,
			   g1_patterns, segchar
				  );

	    if(sc1)
		g1.attr({viewBox:[0,0,sc1.w,sc1.h].join(' '),
    		 	   //preserveAspectRatio: "none"
    			  });
		
		
	    g2.clear();
	    var g2_patterns = get_patterns(g2, g2_pat_color, 2);
	    var sc2 = draw_segchar(g2,g2_bits, message.force_wrap,
				   g2_patterns,segchar);
	    if(sc2)
		g2.attr({viewBox:[0,0,sc2.w,sc2.h].join(' '),
    		 	   //preserveAspectRatio: "none"
    			  });
		
	}
    }
}


function draw_ascii_table_for_seg(g,seg,pattern)
{
    var max_char_width = 1;
    var group = g.g();
    var col = -1;

    var hgap_box = Align.create_box( g, { w: ascii.inner_gap, h: 0} );

    var col_width = 0;

    for(var i = ascii.char_start;
	i <= ascii.char_end;
	i++)
    {
	if((i-ascii.char_start) % ascii.max_rows == 0)
	    col++;
	    
	var char_path = create_seg_ascii_char(0,0, seg, i);

	var path = g.path(char_path);
	path.attr({ fill:
		 g1_pat_color})

	var path_box = Align.create_box(g, { o: path, w: seg.width, h: seg.height }).
	    transform_to_box( { h: ascii.char_height });
	
	var text = g.text(0, ascii.char_height,
			  String.fromCharCode(i));
	text.attr("font-size",ascii.char_height);

	var text_box = Align.create_box(g, { o: text
					     //h: ascii.char_h
					   });

	// var rect_box1 = Align.create_box(g, { o: g.rect(0,0,text_box.w,text_box.h).
	// 				      attr({fill: "#FF0000"}) });
	// var rect_box2 = Align.create_box(g, { o: g.rect(0,0,text_box.w,text_box.h).
	// 				     attr({fill: "#00FF00"})});

	//note for the zeroth column, first row, text_width is zero, but this
	//doesn't matter cause col is zero, too
	var x = ascii.left_margin + col * (col_width + ascii.col_gap);
	var y = ((i-ascii.char_start)%ascii.max_rows) * ascii.line_height;

	// console.log("pt");
	// console.log(path_box,text_box);

	var composite_box = Align.halign(g, path_box, hgap_box, text_box).
	    transform_to_box({ x: x, y: y });

	col_width = Math.max(col_width, composite_box.w);

	group.add(composite_box.o);
    }

    return Align.create_box(g,{ o: group });
}

function reverse_pattern(g, p)
{
    var group = g.g(g.rect(0,0,1,1),p.clone().attr("fill","#FFFFFF"));

    return group;
}

function get_patterns(g,color, pn)
{
    var pat1 = [
	g.path("M 0 0 L 1 1 L 0 1 L 0 0"),
    ];

    var pat2 = [
	null,
    ];
	     
    var patterns = [];

    for(var i = 0; i < pat1.length; i++)
    {	
	var p1 = pat1[i];
	var p2 = pat2[i];
	
	if(p1 == null)
	{
	    p1 = reverse_pattern(g,p2);
	}
	else if(p2 == null)
	{
	    p2 = reverse_pattern(g,p1);
	}
	
	p1.toDefs();
	p2.toDefs();

	var raw_pat = pn == 1 ? p1 : p2;
    
	var patbasis = raw_pat.attr({ fill: color }).transform("scale("+pat_scales[i]+")");
	patterns[i] = patbasis.toPattern(0,0,pat_scales[i],pat_scales[i]);
    }

    return patterns;
}

function create_legend_text(g,text, is_visible)
{
    //console.log("visible? %s",is_visible);
    var o = g.text(0,legend.char_height,text).attr("font-size",legend.char_height)
	.attr("visibility", is_visible? "visible" : "hidden");

    var b = Align.create_box(g,{o: o,
				h:legend.char_height});
    //console.log(b);

    return b;
}

function create_example_coord(g, seg, pattern, is_draw_coord, text, is_draw_text)
{
    var group = g.g();

    var coord_box,text_box;

    if(is_draw_coord)
    {
	var pathtext = create_seg_path(0,0,seg.example_coord);
	var coord = g.path(pathtext);
	
	coord_box = Align.create_box(g,{ o: coord,
					 w: seg.example_coord_bb.w,
					 h: seg.example_coord_bb.h
				       }).
	    transform_to_box({ h: legend.ex_ind_coord_height});

	coord.attr({fill: pattern});
    }
    else
	//create an empty box to represent the blank area
	coord_box = Align.create_box(g,{
	    w: seg.example_coord_bb.w,
	    h: seg.example_coord_bb.h}).
	    transform_to_box({ h: legend.ex_ind_coord_height});
	
    var text = g.text(0,legend.ex_on_off_text_height,text).
	attr("font-size",legend.ex_on_off_text_height).
	attr("fill", is_draw_text ? "#000000" : "#FFFFFF" );

	
    text_box = Align.create_box(g,{ o: text,
				    h: legend.ex_on_off_text_height,
				  });

    return Align.valign(g,coord_box,
			Align.create_box(g, { w:0, h: legend.ex_vgap}),
			text_box);
}


function create_legend_seg_bit_char(g, seg, pattern, bitmap, is_visible)
{
    var pathtxt = create_seg_bit_char(0,0,seg, bitmap);
    var o = g.path(pathtxt).attr({fill: pattern});

    if(!is_visible)
	o.attr({ fill: "#FFFFFF" });

    return Align.create_box(g,{ o: o,
				w: seg.width,
				h: seg.height
		     }).transform_to_box({ h: legend.seg_height});
}


function create_legend_box(page_number, //1 or 2
		     g,seg,pattern)
{
    var item_spacer = Align.create_box(g, { w: legend.item_hgap, h: 0});
    var group_spacer = Align.create_box(g, { w: legend.group_hgap, h: 0});
    
    var legend_box = Align.halign
    (g,
     create_legend_text(g,"Legend:", page_number == 1),
     item_spacer,
     create_example_coord(g,seg,pattern, page_number==1, "on", page_number == 1),
     item_spacer,
     create_example_coord(g,seg,pattern, page_number==2, "on", page_number == 1),
     item_spacer,
     create_example_coord(g,seg,pattern, false, "off", page_number == 1),
     item_spacer,
     create_example_coord(g,seg,pattern, true, "off", page_number == 1),
     group_spacer,
     create_legend_text(g,"Example:", page_number == 1),
     item_spacer,
     create_legend_seg_bit_char(g,seg, pattern,
     				page_number == 1 ?
     				legend.example_bitmap1 :
     				legend.example_bitmap2,
				true
     				  ),
     item_spacer,
     create_legend_text(g,"=", page_number == 1),
     item_spacer,
     create_legend_seg_bit_char(g,seg, pattern,
     				 legend.example_bitmap1 ^
     				legend.example_bitmap2,
				page_number==1
     				),
     item_spacer,
     create_legend_text(g,"=", page_number == 1),
     item_spacer,
     create_legend_text(g,legend.example_char, page_number == 1)
    );

    return legend_box;
}

function show_page(name)
{
    var pages = ["mainarea","printarea","generatearea"];

    for(var i = 0; i < pages.length; i++)
    {
	document.getElementById(pages[i]).style.display = (pages[i] == name) ? "block" : "none";
    }
}

function print_page(page_number)
{
    show_page("printarea");
    var g = Snap("#p");

    var input = document.getElementById('msg').value;
    var mode = get_mode();

    var message = create_message_for_seg(input, segchar);

    var bits;
    if(page_number == 1)
    {
	var otp_bits = create_otp_bits(message.bits.length);
	bits = xor_bits(message.bits, otp_bits);
    }
    else
	bits = create_otp_bits(message.bits.length);
    
    if(mode == "grid")
    {
	//console.log('hi');
	// TODO 2 FINISH
	
	redraw_grid(g,bits, message.width,
		    g1_pattern,
		    g1_color);
    }
    else// if(mode == "sixteenseg")
    {
	g.clear();
	
	var patterns;
	
	if(page_number == 1)
	    patterns = get_patterns(g, g1_pat_color, 1);
	else
	    patterns = get_patterns(g, g2_pat_color, 2);

	var sc = draw_segchar(g,bits, message.force_wrap,
			      patterns, segchar
			     );
	var scw = sc.w;
	var sch = sc.h;

	if(scw / page_ratio > sch)
	    sch = scw / page_ratio;
	else
	    scw = sch * page_ratio;
	
	var rm = Math.round(scw * right_margin_perc);
	var bm = Math.round(sch * bottom_margin_perc);

	g.attr({viewBox:[0,0,scw+rm,sch+bm].join(' ')
    	       });

	//all tables and charts are written directly in the svg.
	if(page_number == 1)
	{
	    var at = draw_ascii_table_for_seg(g,segchar, patterns[0]);
	    at.transform_to_box({x: scw, y: 0, w: scw+rm, h: sch+bm});
	}

	var ins_height = instructions.height_perc * bm;
		
	var legend_box = create_legend_box(page_number,g,segchar, patterns[0]);
	legend_box.transform_to_box({x: 0, y: sch, w: scw, h: sch+bm - ins_height});

	//create instructions at bottom
	var ibox = create_legend_text(g,instructions.text[page_number-1], true).
	    transform_to_box({ x: 0, y: sch+bm - ins_height,
			       w: scw, h: ins_height });
    }

    window.print();
    show_page("mainarea");
}




</script>

    <style>
      textarea {
      width: 90%;
      }
      .print_button {
      float: right
      }
      .encoded_page {
      padding: 40px
      }
      .seedpoint { width: 6px; height: 6px; display: block; border-radius: 3px; background-color: #009900; position: absolute; z-index: 10; }
      .error { color: #FF0000; }

      .paranoia_perc {
      display: inline;
      white-space: nowrap;
      }
      .paranoia_label {
      display: inline;
      white-space: nowrap;
      }
    </style>

</head>

    <body>
    <div id="mainarea">
    <p>Introduction: bla bla bla</p>
    <table>
    <tr><td colspan="4">
    <!-- <input type="radio" name="mode" value="sixteenseg" checked="true" onclick="input_changed()">16 segment -->
    <!-- <input type="radio" name="mode" value="grid" onclick="input_changed()">Grid -->
    </td></tr>
    <tr>
    <td>Message
    <td width="50%"><textarea rows="5" placeholder="Enter message" autofocus="true" id="msg" onkeyup="input_changed()" onchange="input_changed()"></textarea>
    <td>OTP
    <td width="50%"><textarea rows="5" placeholder="Enter hexidecimal data or click 'Generate OTP'" id="otp"onkeyup="otp_changed()" onchange="otp_changed()"></textarea>
    <td><input type="button" value="Generate OTP" onclick="generate_seed();">
    </tr>
    </table>
    <p id="error" class="error">Have a nice day</p>
    <table>
    <tr>
    <td class="encoded_page">
    Encoded Page 1 <input class="print_button" type="button" disabled="true" onclick="print_page(1)" id="print_s2" value="Print!" />
    <br>
    <svg width="400" height="500" id="s1" />
    <br>
    </td>
    <td class="encoded_page">
    Encoded Page 2 <input class="print_button" type="button" disabled="true" onclick="print_page(2)" id="print_s1" value="Print!" />
    <br>
    <svg width="400" height="500" id="s2" />
    <br>
    </td></tr></table>
    </div>
    <div id="printarea">
    <svg width="100%" height="100%" id="p" />
    </div>
    <div id="generatearea">
    <h3><div id="paranoia_perc"></div></h3>
    </div>
</body>
    
</html>
    



